diff -durN kernel.orig/arch/alpha/config.in kernel/arch/alpha/config.in
--- kernel.orig/arch/alpha/config.in	2007-03-20 14:08:05.000000000 +1000
+++ kernel/arch/alpha/config.in	2007-03-20 14:52:52.000000000 +1000
@@ -424,3 +424,6 @@
 fi
 
 endmenu
+
+source kernel/Config.in
+
diff -durN kernel.orig/arch/alpha/defconfig kernel/arch/alpha/defconfig
--- kernel.orig/arch/alpha/defconfig	2007-03-20 14:08:05.000000000 +1000
+++ kernel/arch/alpha/defconfig	2007-03-20 14:52:52.000000000 +1000
@@ -795,3 +795,19 @@
 CONFIG_MATHEMU=y
 # CONFIG_DEBUG_SLAB is not set
 CONFIG_MAGIC_SYSRQ=y
+
+
+#
+# Linux Intrusion Detection System
+#
+# CONFIG_LIDS is not set
+
+
+#
+# LIDS features
+#
+CONFIG_LIDS_NO_FLOOD_LOG=y
+CONFIG_LIDS_RELOAD_CONF=y
+CONFIG_LIDS_ALLOW_SWITCH=y
+CONFIG_LIDS_PORT_SCAN_DETECTOR=y
+CONFIG_LIDS_MAIL_SCRIPT=y
diff -durN kernel.orig/arch/arm/config.in kernel/arch/arm/config.in
--- kernel.orig/arch/arm/config.in	2007-03-20 14:08:06.000000000 +1000
+++ kernel/arch/arm/config.in	2007-03-20 14:52:53.000000000 +1000
@@ -815,3 +815,6 @@
 dep_bool '    Kernel low-level debugging messages via footbridge serial port' CONFIG_DEBUG_DC21285_PORT $CONFIG_DEBUG_LL $CONFIG_FOOTBRIDGE
 dep_bool '    Kernel low-level debugging messages via UART2' CONFIG_DEBUG_CLPS711X_UART2 $CONFIG_DEBUG_LL $CONFIG_ARCH_CLPS711X
 endmenu
+
+source kernel/Config.in
+
diff -durN kernel.orig/arch/arm/defconfig kernel/arch/arm/defconfig
--- kernel.orig/arch/arm/defconfig	2007-03-20 14:08:06.000000000 +1000
+++ kernel/arch/arm/defconfig	2007-03-20 14:52:53.000000000 +1000
@@ -967,3 +967,19 @@
 CONFIG_DEBUG_LL=y
 # CONFIG_DEBUG_DC21285_PORT is not set
 # CONFIG_DEBUG_CLPS711X_UART2 is not set
+
+#
+# Linux Intrusion Detection System
+#
+# CONFIG_LIDS is not set
+
+
+#
+# LIDS features
+#
+CONFIG_LIDS_NO_FLOOD_LOG=y
+CONFIG_LIDS_RELOAD_CONF=y
+CONFIG_LIDS_ALLOW_SWITCH=y
+CONFIG_LIDS_PORT_SCAN_DETECTOR=y
+CONFIG_LIDS_MAIL_SCRIPT=y
+
diff -durN kernel.orig/arch/arm/def-configs/greenphone kernel/arch/arm/def-configs/greenphone
--- kernel.orig/arch/arm/def-configs/greenphone	2007-03-20 14:08:06.000000000 +1000
+++ kernel/arch/arm/def-configs/greenphone	2007-03-20 14:52:53.000000000 +1000
@@ -1006,3 +1006,30 @@
 CONFIG_DEBUG_LL=y
 # CONFIG_DEBUG_DC21285_PORT is not set
 # CONFIG_DEBUG_CLPS711X_UART2 is not set
+
+#
+# Linux Intrusion Detection System
+#
+CONFIG_LIDS=y
+CONFIG_LIDS_MAX_INODE=256
+CONFIG_LIDS_MAX_SACL=256
+CONFIG_LIDS_MAX_OACL=256
+# CONFIG_LIDS_HANGUP is not set
+# CONFIG_LIDS_SA_EXEC_UP is not set
+# CONFIG_LIDS_NO_FLOOD_LOG is not set
+CONFIG_LIDS_ALLOW_SWITCH=y
+CONFIG_LIDS_ALLOW_LFS=y
+# CONFIG_LIDS_PROTECT_PWD is not set
+# CONFIG_LIDS_RESTRICT_MODE_SWITCH is not set
+CONFIG_LIDS_MAX_TRY=3
+CONFIG_LIDS_TTW_FAIL=3
+# CONFIG_LIDS_ALLOW_ANY_PROG_SWITCH is not set
+CONFIG_LIDS_RELOAD_CONF=y
+CONFIG_LIDS_PORT_SCAN_DETECTOR=y
+# CONFIG_LIDS_SA_THROUGH_NET is not set
+# CONFIG_LIDS_NETWORK is not set
+# CONFIG_LIDS_TPE is not set
+CONFIG_LIDS_TDE=y
+CONFIG_LIDS_TDE_SANDBOX_ONLY=y
+# CONFIG_CAP_LIDS_SANDBOX_EFF_SET is not set
+# CONFIG_LIDS_DEBUG is not set
diff -durN kernel.orig/arch/cris/defconfig kernel/arch/cris/defconfig
--- kernel.orig/arch/cris/defconfig	2007-03-20 14:08:07.000000000 +1000
+++ kernel/arch/cris/defconfig	2007-03-20 14:52:53.000000000 +1000
@@ -514,3 +514,18 @@
 # Kernel hacking
 #
 # CONFIG_PROFILE is not set
+
+#
+# Linux Intrusion Detection System
+#
+# CONFIG_LIDS is not set
+
+
+#
+# LIDS features
+#
+CONFIG_LIDS_NO_FLOOD_LOG=y
+CONFIG_LIDS_RELOAD_CONF=y
+CONFIG_LIDS_ALLOW_SWITCH=y
+CONFIG_LIDS_PORT_SCAN_DETECTOR=y
+CONFIG_LIDS_MAIL_SCRIPT=y
diff -durN kernel.orig/arch/i386/config.in kernel/arch/i386/config.in
--- kernel.orig/arch/i386/config.in	2007-03-20 14:08:08.000000000 +1000
+++ kernel/arch/i386/config.in	2007-03-20 14:52:53.000000000 +1000
@@ -427,3 +427,6 @@
 fi
 
 endmenu
+
+source kernel/Config.in
+
diff -durN kernel.orig/arch/i386/defconfig kernel/arch/i386/defconfig
--- kernel.orig/arch/i386/defconfig	2007-03-20 14:08:08.000000000 +1000
+++ kernel/arch/i386/defconfig	2007-03-20 14:52:53.000000000 +1000
@@ -878,3 +878,19 @@
 # Kernel hacking
 #
 # CONFIG_DEBUG_KERNEL is not set
+
+#
+# Linux Intrusion Detection System
+#
+# CONFIG_LIDS is not set
+
+
+#
+# LIDS features
+#
+CONFIG_LIDS_NO_FLOOD_LOG=y
+CONFIG_LIDS_RELOAD_CONF=y
+CONFIG_LIDS_ALLOW_SWITCH=y
+CONFIG_LIDS_PORT_SCAN_DETECTOR=y
+CONFIG_LIDS_MAIL_SCRIPT=y
+
diff -durN kernel.orig/arch/i386/kernel/ioport.c kernel/arch/i386/kernel/ioport.c
--- kernel.orig/arch/i386/kernel/ioport.c	2007-03-20 14:08:08.000000000 +1000
+++ kernel/arch/i386/kernel/ioport.c	2007-03-20 14:52:53.000000000 +1000
@@ -59,8 +59,14 @@
 
 	if ((from + num <= from) || (from + num > IO_BITMAP_SIZE*32))
 		return -EINVAL;
-	if (turn_on && !capable(CAP_SYS_RAWIO))
+	if (turn_on && !capable(CAP_SYS_RAWIO)) {
+#ifdef CONFIG_LIDS
+		lids_security_alert("CAP_SYS_RAWIO violation: attempted to "
+				    "get authorization to use io ports %i-%i "
+				    "(ioperm() syscall)", from, from + num);
+#endif
 		return -EPERM;
+	}
 	/*
 	 * If it's the first ioperm() call in this thread's lifetime, set the
 	 * IO bitmap up. ioperm() is much less timing critical than clone(),
@@ -108,8 +114,14 @@
 		return -EINVAL;
 	/* Trying to gain more privileges? */
 	if (level > old) {
-		if (!capable(CAP_SYS_RAWIO))
+		if (!capable(CAP_SYS_RAWIO)) {
+#ifdef CONFIG_LIDS
+			lids_security_alert("CAP_SYS_RAWIO violation: "
+					    "Try to gain unlimited io "
+					    "access (iopl syscall)");
+#endif
 			return -EPERM;
+		}
 	}
 	regs->eflags = (regs->eflags & 0xffffcfff) | (level << 12);
 	return 0;
diff -durN kernel.orig/arch/i386/kernel/ptrace.c kernel/arch/i386/kernel/ptrace.c
--- kernel.orig/arch/i386/kernel/ptrace.c	2007-03-20 14:08:09.000000000 +1000
+++ kernel/arch/i386/kernel/ptrace.c	2007-03-20 14:52:53.000000000 +1000
@@ -13,6 +13,9 @@
 #include <linux/errno.h>
 #include <linux/ptrace.h>
 #include <linux/user.h>
+#ifdef CONFIG_LIDS
+#include <linux/lids.h>
+#endif
 
 #include <asm/uaccess.h>
 #include <asm/pgtable.h>
@@ -153,6 +156,14 @@
 	struct user * dummy = NULL;
 	int i, ret;
 
+#ifdef CONFIG_LIDS
+	if (!lids_cap_raised(CAP_SYS_PTRACE, 1)) {
+		lids_security_alert("CAP_SYS_PTRACE violation: "
+				    "Attempt to trace pid %ld", pid);
+		return -EPERM;
+	}
+#endif
+
 	lock_kernel();
 	ret = -EPERM;
 	if (request == PTRACE_TRACEME) {
diff -durN kernel.orig/arch/i386/kernel/vm86.c kernel/arch/i386/kernel/vm86.c
--- kernel.orig/arch/i386/kernel/vm86.c	2007-03-20 14:08:09.000000000 +1000
+++ kernel/arch/i386/kernel/vm86.c	2007-03-20 14:52:53.000000000 +1000
@@ -762,7 +762,14 @@
 			int sig = irqnumber >> 8;
 			int irq = irqnumber & 255;
 			handle_irq_zombies();
-			if (!capable(CAP_SYS_ADMIN)) return -EPERM;
+			if (!capable(CAP_SYS_ADMIN)) {
+#ifdef CONFIG_LIDS
+				lids_security_alert("CAP_SYS_ADMIN violation: "
+						    "try to request IRQ %d",
+						    irqnumber);
+#endif
+				return -EPERM;
+			}
 			if (!((1 << sig) & ALLOWED_SIGS)) return -EPERM;
 			if ( (irq<3) || (irq>15) ) return -EPERM;
 			if (vm86_irqs[irq].tsk) return -EPERM;
diff -durN kernel.orig/arch/ia64/config.in kernel/arch/ia64/config.in
--- kernel.orig/arch/ia64/config.in	2007-03-20 14:08:09.000000000 +1000
+++ kernel/arch/ia64/config.in	2007-03-20 14:52:53.000000000 +1000
@@ -280,3 +280,4 @@
 fi
 
 endmenu
+source kernel/Config.in
diff -durN kernel.orig/arch/ia64/defconfig kernel/arch/ia64/defconfig
--- kernel.orig/arch/ia64/defconfig	2007-03-20 14:08:09.000000000 +1000
+++ kernel/arch/ia64/defconfig	2007-03-20 14:52:53.000000000 +1000
@@ -889,3 +889,19 @@
 # CONFIG_DEBUG_SPINLOCK is not set
 # CONFIG_IA64_DEBUG_CMPXCHG is not set
 # CONFIG_IA64_DEBUG_IRQ is not set
+
+#
+# Linux Intrusion Detection System
+#
+# CONFIG_LIDS is not set
+
+
+#
+# LIDS features
+#
+CONFIG_LIDS_NO_FLOOD_LOG=y
+CONFIG_LIDS_RELOAD_CONF=y
+CONFIG_LIDS_ALLOW_SWITCH=y
+CONFIG_LIDS_PORT_SCAN_DETECTOR=y
+CONFIG_LIDS_MAIL_SCRIPT=y
+
diff -durN kernel.orig/arch/m68k/defconfig kernel/arch/m68k/defconfig
--- kernel.orig/arch/m68k/defconfig	2007-03-20 14:08:09.000000000 +1000
+++ kernel/arch/m68k/defconfig	2007-03-20 14:52:53.000000000 +1000
@@ -327,3 +327,18 @@
 # Kernel hacking
 #
 # CONFIG_MAGIC_SYSRQ is not set
+
+#
+# Linux Intrusion Detection System
+#
+# CONFIG_LIDS is not set
+
+
+#
+# LIDS features
+#
+CONFIG_LIDS_NO_FLOOD_LOG=y
+CONFIG_LIDS_RELOAD_CONF=y
+CONFIG_LIDS_ALLOW_SWITCH=y
+CONFIG_LIDS_PORT_SCAN_DETECTOR=y
+CONFIG_LIDS_MAIL_SCRIPT=y
diff -durN kernel.orig/arch/mips/config.in kernel/arch/mips/config.in
--- kernel.orig/arch/mips/config.in	2007-03-20 14:08:10.000000000 +1000
+++ kernel/arch/mips/config.in	2007-03-20 14:52:53.000000000 +1000
@@ -633,3 +633,6 @@
    bool 'Run uncached' CONFIG_MIPS_UNCACHED
 fi
 endmenu
+
+source kernel/Config.in
+
diff -durN kernel.orig/arch/mips64/config.in kernel/arch/mips64/config.in
--- kernel.orig/arch/mips64/config.in	2007-03-20 14:08:13.000000000 +1000
+++ kernel/arch/mips64/config.in	2007-03-20 14:52:53.000000000 +1000
@@ -337,3 +337,6 @@
    bool 'Run uncached' CONFIG_MIPS_UNCACHED
 fi
 endmenu
+
+source kernel/Config.in
+
diff -durN kernel.orig/arch/mips64/defconfig kernel/arch/mips64/defconfig
--- kernel.orig/arch/mips64/defconfig	2007-03-20 14:08:13.000000000 +1000
+++ kernel/arch/mips64/defconfig	2007-03-20 14:52:53.000000000 +1000
@@ -525,3 +525,20 @@
 CONFIG_CROSSCOMPILE=y
 # CONFIG_REMOTE_DEBUG is not set
 # CONFIG_MAGIC_SYSRQ is not set
+
+
+#
+# Linux Intrusion Detection System
+#
+# CONFIG_LIDS is not set
+
+
+#
+# LIDS features
+#
+CONFIG_LIDS_NO_FLOOD_LOG=y
+CONFIG_LIDS_RELOAD_CONF=y
+CONFIG_LIDS_ALLOW_SWITCH=y
+CONFIG_LIDS_PORT_SCAN_DETECTOR=y
+CONFIG_LIDS_MAIL_SCRIPT=y
+
diff -durN kernel.orig/arch/parisc/config.in kernel/arch/parisc/config.in
--- kernel.orig/arch/parisc/config.in	2007-03-20 14:08:14.000000000 +1000
+++ kernel/arch/parisc/config.in	2007-03-20 14:52:54.000000000 +1000
@@ -208,4 +208,5 @@
 #bool 'Debug kmalloc/kfree' CONFIG_DEBUG_MALLOC
 bool 'Magic SysRq key' CONFIG_MAGIC_SYSRQ
 endmenu
+source kernel/Config.in
 
diff -durN kernel.orig/arch/parisc/defconfig kernel/arch/parisc/defconfig
--- kernel.orig/arch/parisc/defconfig	2007-03-20 14:08:14.000000000 +1000
+++ kernel/arch/parisc/defconfig	2007-03-20 14:52:54.000000000 +1000
@@ -361,3 +361,18 @@
 # Kernel hacking
 #
 CONFIG_MAGIC_SYSRQ=y
+
+#
+# Linux Intrusion Detection System
+#
+# CONFIG_LIDS is not set
+
+
+#
+# LIDS features
+#
+CONFIG_LIDS_NO_FLOOD_LOG=y
+CONFIG_LIDS_RELOAD_CONF=y
+CONFIG_LIDS_ALLOW_SWITCH=y
+CONFIG_LIDS_PORT_SCAN_DETECTOR=y
+CONFIG_LIDS_MAIL_SCRIPT=y
diff -durN kernel.orig/arch/ppc/config.in kernel/arch/ppc/config.in
--- kernel.orig/arch/ppc/config.in	2007-03-20 14:08:14.000000000 +1000
+++ kernel/arch/ppc/config.in	2007-03-20 14:52:54.000000000 +1000
@@ -403,3 +403,4 @@
 bool 'Include kgdb kernel debugger' CONFIG_KGDB
 bool 'Include xmon kernel debugger' CONFIG_XMON
 endmenu
+source kernel/Config.in
diff -durN kernel.orig/arch/ppc/defconfig kernel/arch/ppc/defconfig
--- kernel.orig/arch/ppc/defconfig	2007-03-20 14:08:14.000000000 +1000
+++ kernel/arch/ppc/defconfig	2007-03-20 14:52:54.000000000 +1000
@@ -978,3 +978,19 @@
 CONFIG_MAGIC_SYSRQ=y
 # CONFIG_KGDB is not set
 CONFIG_XMON=y
+
+#
+# Linux Intrusion Detection System
+#
+# CONFIG_LIDS is not set
+
+
+#
+# LIDS features
+#
+CONFIG_LIDS_NO_FLOOD_LOG=y
+CONFIG_LIDS_RELOAD_CONF=y
+CONFIG_LIDS_ALLOW_SWITCH=y
+CONFIG_LIDS_PORT_SCAN_DETECTOR=y
+CONFIG_LIDS_MAIL_SCRIPT=y
+
diff -durN kernel.orig/arch/s390/config.in kernel/arch/s390/config.in
--- kernel.orig/arch/s390/config.in	2007-03-20 14:08:17.000000000 +1000
+++ kernel/arch/s390/config.in	2007-03-20 14:52:54.000000000 +1000
@@ -75,3 +75,5 @@
 bool 'Magic SysRq key' CONFIG_MAGIC_SYSRQ
 endmenu
 
+source kernel/Config.in
+
diff -durN kernel.orig/arch/s390/defconfig kernel/arch/s390/defconfig
--- kernel.orig/arch/s390/defconfig	2007-03-20 14:08:17.000000000 +1000
+++ kernel/arch/s390/defconfig	2007-03-20 14:52:54.000000000 +1000
@@ -268,3 +268,19 @@
 # Kernel hacking
 #
 CONFIG_MAGIC_SYSRQ=y
+
+#
+# Linux Intrusion Detection System
+#
+# CONFIG_LIDS is not set
+
+
+#
+# LIDS features
+#
+CONFIG_LIDS_NO_FLOOD_LOG=y
+CONFIG_LIDS_RELOAD_CONF=y
+CONFIG_LIDS_ALLOW_SWITCH=y
+CONFIG_LIDS_PORT_SCAN_DETECTOR=y
+CONFIG_LIDS_MAIL_SCRIPT=y
+
diff -durN kernel.orig/arch/s390x/defconfig kernel/arch/s390x/defconfig
--- kernel.orig/arch/s390x/defconfig	2007-03-20 14:08:17.000000000 +1000
+++ kernel/arch/s390x/defconfig	2007-03-20 14:52:54.000000000 +1000
@@ -268,3 +268,19 @@
 # Kernel hacking
 #
 CONFIG_MAGIC_SYSRQ=y
+
+#
+# Linux Intrusion Detection System
+#
+# CONFIG_LIDS is not set
+
+
+#
+# LIDS features
+#
+CONFIG_LIDS_NO_FLOOD_LOG=y
+CONFIG_LIDS_RELOAD_CONF=y
+CONFIG_LIDS_ALLOW_SWITCH=y
+CONFIG_LIDS_PORT_SCAN_DETECTOR=y
+CONFIG_LIDS_MAIL_SCRIPT=y
+
diff -durN kernel.orig/arch/sh/config.in kernel/arch/sh/config.in
--- kernel.orig/arch/sh/config.in	2007-03-20 14:08:18.000000000 +1000
+++ kernel/arch/sh/config.in	2007-03-20 14:52:54.000000000 +1000
@@ -387,3 +387,6 @@
    bool 'Early printk support' CONFIG_SH_EARLY_PRINTK
 fi
 endmenu
+
+source kernel/Config.in
+
diff -durN kernel.orig/arch/sh/defconfig kernel/arch/sh/defconfig
--- kernel.orig/arch/sh/defconfig	2007-03-20 14:08:18.000000000 +1000
+++ kernel/arch/sh/defconfig	2007-03-20 14:52:54.000000000 +1000
@@ -202,3 +202,18 @@
 # CONFIG_MAGIC_SYSRQ is not set
 CONFIG_SH_STANDARD_BIOS=y
 CONFIG_SH_EARLY_PRINTK=y
+
+#
+# Linux Intrusion Detection System
+#
+# CONFIG_LIDS is not set
+
+
+#
+# LIDS features
+#
+CONFIG_LIDS_NO_FLOOD_LOG=y
+CONFIG_LIDS_RELOAD_CONF=y
+CONFIG_LIDS_ALLOW_SWITCH=y
+CONFIG_LIDS_PORT_SCAN_DETECTOR=y
+CONFIG_LIDS_MAIL_SCRIPT=y
diff -durN kernel.orig/arch/sparc/config.in kernel/arch/sparc/config.in
--- kernel.orig/arch/sparc/config.in	2007-03-20 14:08:18.000000000 +1000
+++ kernel/arch/sparc/config.in	2007-03-20 14:52:54.000000000 +1000
@@ -272,3 +272,6 @@
 
 bool 'Magic SysRq key' CONFIG_MAGIC_SYSRQ
 endmenu
+
+source kernel/Config.in
+
diff -durN kernel.orig/arch/sparc/defconfig kernel/arch/sparc/defconfig
--- kernel.orig/arch/sparc/defconfig	2007-03-20 14:08:18.000000000 +1000
+++ kernel/arch/sparc/defconfig	2007-03-20 14:52:54.000000000 +1000
@@ -416,3 +416,19 @@
 # Kernel hacking
 #
 # CONFIG_MAGIC_SYSRQ is not set
+
+#
+# Linux Intrusion Detection System
+#
+# CONFIG_LIDS is not set
+
+
+#
+# LIDS features
+#
+CONFIG_LIDS_NO_FLOOD_LOG=y
+CONFIG_LIDS_RELOAD_CONF=y
+CONFIG_LIDS_ALLOW_SWITCH=y
+CONFIG_LIDS_PORT_SCAN_DETECTOR=y
+CONFIG_LIDS_MAIL_SCRIPT=y
+
diff -durN kernel.orig/arch/sparc64/config.in kernel/arch/sparc64/config.in
--- kernel.orig/arch/sparc64/config.in	2007-03-20 14:08:18.000000000 +1000
+++ kernel/arch/sparc64/config.in	2007-03-20 14:52:54.000000000 +1000
@@ -309,3 +309,6 @@
 fi
 
 endmenu
+
+source kernel/Config.in
+
diff -durN kernel.orig/base.patch kernel/base.patch
--- kernel.orig/base.patch	1970-01-01 10:00:00.000000000 +1000
+++ kernel/base.patch	2007-03-20 14:52:54.000000000 +1000
@@ -0,0 +1,159 @@
+--- kernel/fs/proc/base.c	Fri Mar 16 01:42:10 2007
++++ kernel/fs/proc/base.c	Fri Mar 16 01:42:10 2007
+@@ -26,6 +26,10 @@
+ #include <linux/seq_file.h>
+ #include <linux/namespace.h>
+ 
++#ifdef CONFIG_LIDS
++#include <linux/lids.h>
++#endif
++
+ /*
+  * For hysterical raisins we keep the same inumbers as in the old procfs.
+  * Feel free to change the macro below - just keep the range distinct from
+@@ -513,6 +517,84 @@
+ 	return error;
+ }
+ 
++#ifdef CONFIG_LIDS
++static int proc_pid_lids_key(struct task_struct *task, char * buffer)
++{
++	int res = 0;
++        if ( buffer == 0 ) {
++            printk( "proc_pid_lids_key - can't put data in null buffer\n" );
++            return -EIO;
++        }
++        if ( task == 0 ) {
++            printk( "proc_pid_lids_key - can't do key for null task\n" );
++            return -EIO;
++        }
++	if ( task->pid != current->pid ) {
++		lids_security_alert("Attempt to read /proc/%d/key by pid %d",
++				    task->pid, current->pid );
++		res = -EPERM;
++	} else {
++		res = lids_get_key( task, buffer );
++	}
++	return res;
++}
++
++
++/*
++   Check the permissions for opening a file.  Note that being denied
++   permission here is not a lids alert, since a process can validly
++   use the access (2) call to check for permissions without operating
++   on the file.
++*/
++static int proc_lids_key_permission(struct inode *inode, int mask)
++{
++        int res = 0;
++	struct task_struct *task;
++
++        /* normal permission checks */
++	res = vfs_permission(inode, mask);
++        if ( res != 0 )
++                goto out;
++
++        /* check for chroot or namespace traversal via bind mount */
++	res = proc_check_root(inode);
++        if ( res != 0 )
++                goto out;
++
++        /* pid can only read its own key */
++	task = inode->u.proc_i.task;
++	if ( task->pid != current->pid )
++                res = -EACCES;
++out:
++        printk( "lids proc key permissions check: %d\n", res );
++        return res;
++}
++
++static int proc_lids_key_open(struct inode* inode, struct file* file)
++{
++        int res = 0;
++	struct task_struct *task = inode->u.proc_i.task;
++	if ( task->pid != current->pid ) {
++		lids_security_alert("Attempt to read /proc/%d/key by pid %d",
++				    task->pid, current->pid );
++		res = -EPERM;
++        }
++	file->private_data = (void*)1;
++        printk( "lids proc key open: %d\n", res );
++	return 0;
++}
++
++static struct inode_operations proc_lids_key_inode_operations = {
++	permission:	proc_lids_key_permission,
++};
++
++
++static struct file_operations proc_lids_key_file_operations = {
++	open:		proc_lids_key_open,
++	read:		proc_info_read,
++};
++#endif
++
+ static struct inode_operations proc_pid_link_inode_operations = {
+ 	readlink:	proc_pid_readlink,
+ 	follow_link:	proc_pid_follow_link
+@@ -540,6 +622,9 @@
+ 	PROC_PID_MAPS,
+ 	PROC_PID_CPU,
+ 	PROC_PID_MOUNTS,
++#ifdef CONFIG_LIDS
++        PROC_PID_LIDS_KEY,
++#endif
+ 	PROC_PID_FD_DIR = 0x8000,	/* 0x8000-0xffff */
+ };
+ 
+@@ -560,6 +645,9 @@
+   E(PROC_PID_ROOT,	"root",		S_IFLNK|S_IRWXUGO),
+   E(PROC_PID_EXE,	"exe",		S_IFLNK|S_IRWXUGO),
+   E(PROC_PID_MOUNTS,	"mounts",	S_IFREG|S_IRUGO),
++#ifdef CONFIG_LIDS
++  E(PROC_PID_LIDS_KEY,	"lids_key",	S_IFREG|S_IRUSR),
++#endif
+   {0,0,NULL,0}
+ };
+ #undef E
+@@ -928,6 +1016,13 @@
+ 		case PROC_PID_MOUNTS:
+ 			inode->i_fop = &proc_mounts_operations;
+ 			break;
++#ifdef CONFIG_LIDS
++		case PROC_PID_LIDS_KEY:
++			inode->i_op = &proc_lids_key_inode_operations;
++			inode->i_fop = &proc_lids_key_file_operations;
++			inode->u.proc_i.op.proc_read = proc_pid_lids_key;
++			break;
++#endif
+ 		default:
+ 			printk("procfs: impossible type (%d)",p->type);
+ 			iput(inode);
+@@ -1018,6 +1113,12 @@
+ 	read_unlock(&tasklist_lock);
+ 	if (!task)
+ 		goto out;
++#ifdef CONFIG_LIDS
++	if (cap_raised(task->lids_cap, CAP_HIDDEN) &&
++	    lids_load && lids_local_load && !lids_acl_discovery)
++		inode = NULL;
++	else
++#endif
+ 
+ 	inode = proc_pid_make_inode(dir->i_sb, task, PROC_PID_INO);
+ 
+@@ -1065,6 +1166,12 @@
+ 		int pid = p->pid;
+ 		if (!pid)
+ 			continue;
++#ifdef CONFIG_LIDS
++		if (cap_raised(p->lids_cap,CAP_HIDDEN) &&
++		    lids_load && lids_local_load &&
++		    !lids_acl_discovery)
++			continue;
++#endif
+ 		if (--index >= 0)
+ 			continue;
+ 		pids[nr_pids] = pid;
+
diff -durN kernel.orig/Documentation/Configure.help kernel/Documentation/Configure.help
--- kernel.orig/Documentation/Configure.help	2007-03-20 14:08:02.000000000 +1000
+++ kernel/Documentation/Configure.help	2007-03-20 14:52:54.000000000 +1000
@@ -22893,6 +22893,347 @@
   a debugging option; you probably do not want to set it unless you
   are an S390 port maintainer.
 
+Intrusion Detection System support (EXPERIMENTAL)
+CONFIG_LIDS
+  If you say Y here, you will be able to make you linux system more secure.
+
+  Please read help provided with each option carefully. At the end of
+  each option we indicate what answer will increase security.
+  Be aware that security always has side effects, and some programs could
+  break.
+
+  If you have any questions about LIDS, mail to the authors :
+                   Huagang Xie (xie at lids.org)
+                   Philippe.biondi (biondi at cartel-securite.fr)
+		   Yusuf Wilajati Purna (ywpurna at users.sourceforge.net)
+
+  or visit lids home ,
+                http://www.lids.org/
+  or mirrors:
+                http://www.lids.org/mirrors.html
+
+  And you can get help from the LIDS Mailing list at
+		http://www.lids.org/maillist.html
+  and the FAQ by Sander Klein and Steve Bremer at
+		http://www.lids.org/lids-faq/lids-faq.html
+
+  If your want to secure your linux kernel, say "Y" here , if not , say "N".
+
+Hang up console when raising a security alert
+CONFIG_LIDS_HANGUP
+  If you say yes here, each time a program violates the rules, LIDS will
+  try to hang up the console the program is currently attached to.
+
+  Warning: If the LIDS ACLs are not properly set up, and you select this
+           option you may lock yourself out of your linux box.
+
+Security alert when executing unprotected programs before sealing
+CONFIG_LIDS_SA_EXEC_UP
+  Saying yes will generate a security alert for each unprotected program
+  that is executed before LIDS is sealed (with lidsadm -I).
+  This can help a lot to check whether your boot sequence is secured.
+  This can also warn you if a weakness has been exploited and an
+  unprotected program has been added to the boot process.
+
+  Saying yes increases security.
+
+Do not execute unprotected programs before sealing
+CONFIG_LIDS_NO_EXEC_UP
+  This option makes LIDS refuse the execution of the unprotected programs
+  before it is sealed. Be aware that you can prevent the system from
+  booting with an incomplete lids.conf.
+
+  Saying yes increases security.
+
+  Warning: Selecting this may cause your system to fail to boot, you must
+	   create proper ACLs to protect all the programs running before
+	   sealing. So, if you got problem with booting, disable this option,
+           recompile and boot again.
+
+Enable LIDS Trusted Path Execution (TPE) mode feature
+CONFIG_LIDS_TPE
+  This option configures Trusted Path Execution (TPE) mode in LIDS.
+  If you say Yes here, you will be allowed to switch TPE mode on and
+  off in LIDS by using "lidsadm -S -- +TPE" and " lidsadm -S -- -TPE".
+  The TPE mode can be switched on as well when sealing the kernel,
+  using "lidsadm -I +TPE".
+
+  If this option is not selected, TPE mode won't be available in LIDS.
+
+  In TPE mode, i.e., when TPE mode is on, LIDS will only execute programs
+  as well as libraries, and load kernel modules  as far as they are
+  at least protected with READONLY.
+
+  Please be aware that script-based programs, such as Bash, Perl, Phyton
+  programs and so on, can be executed by running the corresponding
+  interpreter and passing the programs to the interpreter. In this case,
+  if the interpeter is protected LIDS cannot prevent the programs from
+  running even in TPE mode.
+
+  Saying yes increases security.
+
+Enable LIDS Trusted Domain Enforcement (TDE) feature
+CONFIG_LIDS_TDE
+  This option enables Trusted Domain Enforcement (TDE) feature in LIDS.
+  If you say Yes here, LIDS will enforce a TDE policy: A privileged process
+  that reads unprotected input, including character devices, files, etc,
+  will be moved into the untrusted domain.
+
+  A process moved into the untrusted domain still runs, but loses its
+  privileges, including granted capabilities, set in LIDS ACLs.
+  This will help reduce security risks to a certain extent in case
+  the process is abused with malicious input.
+
+  Granting CAP_PROTECTED to a process will force LIDS not to move the
+  process into the untrusted domain even if the process reads unprotected
+  input. In some cases, you need to grant CAP_PROTECTED to special
+  processes that really need input from the standard input to make them
+  run properly. The '/bin/su' program is an example. But care must
+  be taken when granting CAP_PROTECTED to a process. Granting this
+  capability to a not-so-well written script/binary increases the risks of
+  the privileges/capabilities being abused by malicious input.
+
+  TDE also enables an application sandboxing feature in LIDS.
+  Once you put an application (say, /opt/myls) into a sandbox as follows:
+
+	# lidsconf -A -s /opt/myls -o LIDS_SANDBOX -j ENABLE
+
+  All rules for '/opt/myls' in order to run properly must be explicitly
+  set. Thus, the basic principle for a sandboxed application is
+  not "Default first, specific follows" but "All must be specified".
+  The more specific the rules are, the tighter the sandbox is.
+
+  Saying yes increases security.
+
+Enable only sandbox feature of LIDS TDE
+CONFIG_LIDS_TDE_SANDBOX_ONLY
+  If you say Yes here, only the sandbox feature of LIDS TDE will be
+  enabled.
+
+Enable LIDS Sandbox Effective Capability Set
+CONFIG_CAP_LIDS_SANDBOX_EFF_SET
+  If you say Yes here,  LIDS Sandbox Effective Capability Set is
+  defined. All capabilities for a sandboxed process, except the
+  following, are enabled by default:
+	CAP_SETPCAP
+	CAP_SYS_RAWIO
+	CAP_MKNOD
+	CAP_SYS_PTRACE
+	CAP_HIDDEN
+	CAP_PROTECTED
+
+  Saying no will increase security.
+
+Logging behaviour
+CONFIG_LIDS_NO_FLOOD_LOG
+  If you say Yes here, LIDS will try not to flood logs with the
+  same message repeated a lot of times.
+
+  Saying yes will increase security.
+
+Number of similiar log events to allow within a given interval(Experimental)
+CONFIG_LIDS_FLOOD_EVENT_THRESHOLD
+  This is the maximum number of similiar events that LIDS will
+  log within the interval defined in:
+     CONFIG_LIDS_FLOOD_EVENT_INTERVAL
+
+  This is to compensate for the problem of multiple different
+  LIDS alerts for "exec() before LIDS sealing" as well as
+  for other cases.
+
+Threshold interval period for the maximum number of LIDS events(Experimental)
+CONFIG_LIDS_FLOOD_EVENT_INTERVAL
+  This is the interval in which we count the number of similiar
+  events that may be flooding the LIDS logs.
+
+Port Scanner Detector in kernel(NEW)
+CONFIG_LIDS_PORT_SCAN_DETECTOR
+  If you say Yes here, LIDS will also build a port scanner detector in
+  kernel. When somebody uses a port scanner to scan your host, LIDS will
+  report it to you by logging the necessary message. It can detect many
+  scanners, including nmap, satan, sscan with many methods including half
+  open scanning.
+
+  When you disable raw socket (disable sniffer) by LIDS, it can replace
+  the user space portscan detector, for it does not use any socket at all.
+
+  Saying yes will increase security.
+
+Time between two logs
+CONFIG_LIDS_TIMEOUT_AFTER_FLOOD
+  This is the minimum time (in seconds) allowed between two different
+  security alerts. When a security alert occurs, no more alerts will be
+  logged before expiration of this timeout. (Except the first alert, with
+  a flood warning).
+
+Allow switching LIDS protections/features
+CONFIG_LIDS_ALLOW_SWITCH
+  If you say Yes here, using the lids admin tool (lidsadm) you will be
+  able to switch on and off the following LIDS features:
+	- LIDS acl discovery mode
+	- LIDS TPE
+	- LIDS global capabilities
+	- LIDS states (POSTBOOT, SHUTDOWN)
+	- etc.
+
+  Note: You must set a LIDS admin password with 'lidsconf -P'.
+
+  Saying no increases security.
+
+Allow switching LIDS/LIDS_GLOBAL
+CONFIG_LIDS_ALLOW_LFS
+  If you say Yes here, you will be able to switch LIDS/LIDS_GLOBAL
+  on and off.
+
+  Saying no increases security.
+
+Implicitly protect LIDS admin passwd
+CONFIG_LIDS_PROTECT_PWD
+  If you say Yes here, LIDS will implicitly protect the LIDS admin
+  password in DENY mode. Thus, even though "lidsconf -L" doesn't
+  list the ACL, the following ACL is implicitly enforced by LIDS:
+
+	#lidsconf -A -o /etc/lids/lids.pw -j DENY
+
+  The ACL can be neither removed nor overwritten.
+
+  Setting a new LIDS admin password can still be done, however,
+  by disabling LIDS or when ACL_DISCOVERY mode is on.
+
+  Saying yes increases security.
+
+Restrict mode switching to specified terminal types
+CONFIG_LIDS_RESTRICT_MODE_SWITCH
+  If you enable this option, mode switching will be only allowed
+  from specified terminal types.
+
+Allow mode switching from Linux Console
+CONFIG_LIDS_MODE_SWITCH_CONSOLE
+  Allow mode switching from a Linux Console.
+
+Allow mode switching from serial Console
+CONFIG_LIDS_MODE_SWITCH_SERIAL
+  Allow mode switching from a serial Console.
+
+Allow mode switching from a PTY
+CONFIG_LIDS_MODE_SWITCH_PTY
+  Allow mode switching from a PTY.
+
+Number of attempts to submit password
+CONFIG_LIDS_MAX_TRY
+  Here you put the number of tries you will allow before disabling the
+  switch capability for a while.
+
+  The lower it is, the more secure the system will be.
+
+Time to wait after a fail
+CONFIG_LIDS_TTW_FAIL
+  Here you put the time (in seconds) the switch capability will be
+  disabled when the authorised number of fails is reached.
+
+  The higher it is, the more secure the system will be.
+
+Allow remote users to switch LIDS on/off
+CONFIG_LIDS_REMOTE_SWITCH
+  Say Yes here if you want to allow users which are not logged
+  on through the console to be able switch LIDS on and off.
+
+  If you have access to the console, you might disable this
+  option, so that a remote user can not disable LIDS, even
+  with the password.
+
+  Saying no is more secure.
+
+Allow any program to switch LIDS on/off
+CONFIG_LIDS_ALLOW_ANY_PROG_SWITCH
+  If you say Yes here, you will allow programs others than
+  /sbin/lidsadm to feed /proc/sys/lids/locks.
+
+  Notes : * It is strongly recommended to leave this option
+            unmarked ! Don't say yes !
+          * I don't know what it could be useful for :)
+
+  Say no.
+
+Allow reloading config file when switched off
+CONFIG_LIDS_RELOAD_CONF
+  Saying Yes here will compile the necessary code to reload the config
+  file. Each time you pass +RELOAD_CONF argument to lidsadm, LIDS reloads
+  /etc/lids.conf and re-reads dev/inode numbers of special programs
+  (/sbin/lidsadm and every program you allow to do something LIDS
+  forbids)
+
+  If an error occurs during the reload phase, the kernel does not panic
+  as it does at startup, because it considers you see the error
+  immediately and correct it.
+
+Send security alerts through network
+CONFIG_LIDS_SA_THROUGH_NET
+  Say yes here if you want to send LIDS security alerts to
+  a remote machine through the network, directly from the
+  kernel, without the help of any potentially corrupted
+  user space program (especially mailer programs)
+  You can send them via mail or via UDP datagrams to a
+  remote syslog, http POST, or anything else you can imagine.
+
+  A pseudo scripting language a la expect is provided to
+  use some communication protocols (as the mail one).
+
+  Below is a summary of the important parameters for the
+  connection. See their respective help section for more
+  help.
+
+  You must provide
+     - the IP of the remote machine
+     - the TCP/UDP port for the connection
+
+  If you choose to use the provided mailer script
+     - Name of the source machine
+     - Name of the sender
+     - Mail address of the receiver
+     - Subject of the mail
+
+  If you choose to use your own script
+  (or the remote syslog one, provided) :
+     - Socket type (TCP/UDP)
+     - Path of the script
+
+Hide klids kernel thread
+CONFIG_LIDS_HIDE_KLIDS
+  If you say Y here, the klids kernel thread won't appear in
+  /proc (thus neither in ps nor in top, nor in anything else)
+  and its network connection won't appear in netstat.
+
+  Moreover, klids network errors (can't connect, etc.) will
+  be silently ignored instead of being logged in syslog.
+
+Number of connection tries before giving up
+CONFIG_LIDS_NET_MAX_TRIES
+  How many times klids will try to send the security alert, if
+  it can't connect (you forgot a firewall ? :) ), or if there
+  is a protocol error (remote sendmail doesn't accept your mail ?).
+  After this number of tries, the message is deleted, even
+  if it was not send (we can imagine that, for some unknown
+  reason (protocol error, defectious IP stack on the road,..)
+  the message can't be send and block the remaining of the
+  queue).
+
+  If you don't want to loose any messages, put a big number
+  of tries here, and give a reasonnable sleep period.
+
+Sleep time after a failed connection
+CONFIG_LIDS_NET_TIMEOUT
+  When klids fails to send the security alert, how many seconds
+  will it sleep before retrying ?
+
+Message queue size
+CONFIG_LIDS_MSGQUEUE_SIZE
+  The security alerts are stored in a message queue. Give
+  the number of messages that could be queued before loosing
+  new messages here.
+
+Use generic mailer pseudo-script
+
 #
 # ARM options
 #
diff -durN kernel.orig/fs/buffer.c kernel/fs/buffer.c
--- kernel.orig/fs/buffer.c	2007-03-20 14:08:46.000000000 +1000
+++ kernel/fs/buffer.c	2007-03-20 14:52:55.000000000 +1000
@@ -2845,8 +2845,13 @@
 
 asmlinkage long sys_bdflush(int func, long data)
 {
-	if (!capable(CAP_SYS_ADMIN))
+	if (!capable(CAP_SYS_ADMIN)) {
+#ifdef CONFIG_LIDS
+		lids_security_alert("CAP_SYS_ADMIN violation: "
+				    "Attempt to use sys_bdflush");
+#endif
 		return -EPERM;
+	}
 
 	if (func == 1) {
 		/* do_exit directly and let kupdate to do its work alone. */
diff -durN kernel.orig/fs/exec.c kernel/fs/exec.c
--- kernel.orig/fs/exec.c	2007-03-20 14:08:47.000000000 +1000
+++ kernel/fs/exec.c	2007-03-20 14:56:12.000000000 +1000
@@ -48,6 +48,10 @@
 
 int core_uses_pid;
 
+#ifdef CONFIG_LIDS
+#include <linux/lids.h>
+#endif
+
 static struct linux_binfmt *formats;
 static rwlock_t binfmt_lock = RW_LOCK_UNLOCKED;
 
@@ -687,6 +691,10 @@
 {
 	kernel_cap_t new_permitted, working;
 	int do_unlock = 0;
+#ifdef CONFIG_LIDS_TDE
+	struct dentry *dentry = dget(bprm->file->f_dentry);
+	struct lids_sys_acl *lids_sys_acl;
+#endif
 
 	new_permitted = cap_intersect(bprm->cap_permitted, cap_bset);
 	working = cap_intersect(bprm->cap_inheritable,
@@ -698,6 +706,16 @@
                 current->mm->dumpable = 0;
 		
 		lock_kernel();
+#ifdef CONFIG_LIDS
+		if (!lids_cap_raised(CAP_SETUID, 1)) {
+			bprm->e_uid = current->uid;
+			lids_cap_log(CAP_SETUID);
+		}
+		if (!lids_cap_raised(CAP_SETGID, 1)) {
+			bprm->e_gid = current->gid;
+			lids_cap_log(CAP_SETGID);
+		}
+#endif
 		if (must_not_trace_exec(current)
 		    || atomic_read(&current->fs->count) > 1
 		    || atomic_read(&current->files->count) > 1
@@ -729,6 +747,38 @@
         current->suid = current->euid = current->fsuid = bprm->e_uid;
         current->sgid = current->egid = current->fsgid = bprm->e_gid;
 
+#ifdef CONFIG_LIDS_TDE
+	 /* if parent is already sandboxed current must be sandboxed */
+	if (current->lids_sys_acl && current->lids_sys_acl->sandbox) {
+		LIDS_DBG("Parent process [pid %d] is already "
+			 "sandboxed, current_pid=%d, current_caps=0x%lx, "
+			 "parent_caps=0x%lx\n", current->p_pptr->pid,
+			 current->pid, current->lids_cap,
+			 current->p_pptr->lids_cap);
+
+		goto lids_sandbox_out;
+	}
+
+	if (dentry && dentry->d_inode) {
+		lids_sys_acl = lids_search_acl(dentry->d_inode->i_ino,
+					       dentry->d_inode->i_dev,
+					       lids_current);
+		if (current->lids_sys_acl && lids_sys_acl &&
+		    test_bit(LIDS_SANDBOX, &(lids_sys_acl->socket))) {
+			current->lids_sys_acl->sandbox = 1;
+			current->lids_sys_acl->flags =
+				current->lids_cap |
+				(lids_cap_val & CAP_LIDS_SANDBOX_EFF_SET);
+			current->lids_cap = current->lids_sys_acl->flags;
+
+			LIDS_DBG("Process [pid %d ppid %d] is sandboxed, "
+				 "caps=0x%lx\n", current->pid,
+				 current->p_pptr->pid, current->lids_cap);
+		}
+	}
+lids_sandbox_out:
+	dput(dentry);
+#endif
 	if(do_unlock)
 		unlock_kernel();
 	current->keep_capabilities = 0;
@@ -862,6 +912,11 @@
 	struct file *file;
 	int retval;
 	int i;
+#ifdef CONFIG_LIDS
+	struct dentry *dentry;
+	char **lidsenvp = envp;
+	struct lids_sys_acl *current_sys_acl = current->lids_sys_acl;
+#endif
 
 	file = open_exec(filename);
 
@@ -869,6 +924,12 @@
 	if (IS_ERR(file))
 		return retval;
 
+#ifdef CONFIG_LIDS
+	LIDS_DBG("##### pid %i exec [%s]: lids_cap=0x%lx\n", current->pid,
+		 filename, current->lids_cap);
+	dentry = file->f_dentry;
+#endif
+
 	bprm.p = PAGE_SIZE*MAX_ARG_PAGES-sizeof(void *);
 	memset(bprm.page, 0, MAX_ARG_PAGES*sizeof(bprm.page[0])); 
 
@@ -906,6 +967,181 @@
 	if (retval < 0) 
 		goto out; 
 
+#ifdef CONFIG_LIDS_TPE
+	retval = lids_exec_tpe_permission(&bprm);
+	if (retval < 0)
+		goto out;
+#endif
+
+#ifdef CONFIG_LIDS
+	if (lids_load && lids_socket_perm(current, LIDS_EXEC) < 0) {
+		if (dentry->d_inode->i_ino != current_sys_acl->ino ||
+		    dentry->d_inode->i_dev !=  current_sys_acl->dev) {
+			lids_security_alert("Attempt to exec [%s]\n",
+					    bprm.filename);
+			retval = -EPERM;
+			goto out;
+		}
+	}
+
+	/*
+	 * if current is sandboxed, sandbox the program in
+	 * the same sandbox as well.
+	 */
+	if (lids_sandboxed(current))
+		goto lids_sandbox_out;
+
+        lids_init_key(&bprm, current);
+
+	/* if dentry is protected compute and set the ACLs, capabilities. */
+	if (lids_protected(dentry, LIDS_APPEND)) {
+		struct lids_task_acl current_acl, computed_acl;
+		struct lids_sys_acl *new_sys_acl;
+
+		LIDS_DBG("%s (dev %d:%d inode %ld) is protected\n", filename,
+			 MAJOR(dentry->d_inode->i_dev),
+			 MINOR(dentry->d_inode->i_dev),
+			 dentry->d_inode->i_ino);
+
+		lids_get_task_acl(&current_acl, current);
+		new_sys_acl = lids_search_acl(dentry->d_inode->i_ino,
+					      dentry->d_inode->i_dev,
+					      lids_current);
+		if (lids_compute_acls(&current_acl, new_sys_acl,
+				      &computed_acl, 1) < 0) {
+			retval = -EPERM;
+			goto out;
+		}
+
+		/*
+		 * if LD_PRELOAD, LD_LIBRARY_PATH, etc are set but
+		 * CAP_SYS_PTRACE is not enabled clear computed ACLs,
+		 * capabilities.
+		 */
+		if (lidsenvp &&
+		    (computed_acl.lids_sys_acl->lids_acl ||
+		     computed_acl.lids_sys_acl->flags) &&
+		    !capable2(CAP_SYS_PTRACE)) {
+			char *env, e;
+			for (;;) {
+				if (get_user(env, lidsenvp++)) {
+					LIDS_DBG("EFAULT !?\n");
+					retval = -EFAULT;
+					goto out;
+				}
+				if (!env)
+					break;
+				if (!get_user(e, env) && (e == 'L') &&
+				    !get_user(e, env+1) && (e == 'D') &&
+				    !get_user(e, env+2) && (e == '_')) {
+					char str[128] = "{not found}";
+
+					copy_from_user(str, env, 128);
+					lids_security_alert
+						("Attempt to give [%.128s] to "
+						 "privileged program %.128s "
+						 "(dev %d:%d inode %ld)",
+						 env, filename,
+						 MAJOR(dentry->d_inode->i_dev),
+						 MINOR(dentry->d_inode->i_dev),
+						 dentry->d_inode->i_ino);
+					lids_clear_lids_task_acl(&computed_acl);
+				}
+			}
+		}
+		lids_set_task_acl(&computed_acl, current);
+		lids_free_lids_task_acl(&current_acl);
+	/* if dentry is not protected clear inherited ACLs, capabilities. */
+	} else {
+
+		LIDS_DBG("%s (dev %d:%d inode %ld) is not protected\n",
+			 filename, MAJOR(dentry->d_inode->i_dev),
+			 MINOR(dentry->d_inode->i_dev),
+			 dentry->d_inode->i_ino);
+
+#ifdef CONFIG_LIDS_SA_EXEC_UP
+		if (lids_first_time && lids_load) {
+#ifdef CONFIG_LIDS_NO_EXEC_UP
+			lids_security_alert("Attempt to exec unprotected "
+					    "program %s (dev %d:%d inode %ld) "
+					    "before sealing LIDS",
+					    filename,
+					    MAJOR(dentry->d_inode->i_dev),
+					    MINOR(dentry->d_inode->i_dev),
+					    dentry->d_inode->i_ino);
+			if (lids_acl_discovery)
+				printk(KERN_INFO
+				       "LIDS_ACL_DISCOVERY:[state %d]"
+				       "%d:%d::%d:0:%ld:%d:%s:0-0\n",
+				       lids_state, 0, 0, LIDS_READONLY,
+				       dentry->d_inode->i_ino,
+				       dentry->d_inode->i_dev,
+				       filename);
+			else {
+				retval = -EPERM;
+				goto out;
+			}
+#else
+			lids_security_alert("Exec'ed unprotected program %s "
+					    "(dev %d:%d inode %ld) before "
+					    "sealing LIDS",
+					    filename,
+					    MAJOR(dentry->d_inode->i_dev),
+					    MINOR(dentry->d_inode->i_dev),
+					    dentry->d_inode->i_ino);
+#endif
+		}
+#endif
+		if (current->lids_sys_acl) {
+			/* The program may inherit. let's check that */
+			struct lids_task_acl current_acl, computed_acl;
+			struct lids_sys_acl *new_sys_acl;
+
+			lids_get_task_acl(&current_acl, current);
+			new_sys_acl = lids_search_acl(dentry->d_inode->i_ino,
+						      dentry->d_inode->i_dev,
+						      lids_current);
+			if (lids_compute_acls(&current_acl, new_sys_acl,
+					      &computed_acl, 0) < 0) {
+				retval = -EPERM;
+				goto out;
+			}
+
+			if (computed_acl.lids_sys_acl->flags) {
+				lids_security_alert
+					("Attempt to transmit privileges to "
+					 "an unprotected program "
+					 "(%s dev %d:%d inode %ld)",
+					 filename,
+					 MAJOR(dentry->d_inode->i_dev),
+					 MINOR(dentry->d_inode->i_dev),
+					 dentry->d_inode->i_ino);
+				computed_acl.lids_sys_acl->flags = 0x0UL;
+				computed_acl.lids_cap = 0x0UL;
+			}
+
+			if (computed_acl.lids_sys_acl->socket != 0)
+				lids_set_task_acl(&computed_acl, current);
+			else {
+				/* Reset ACLs anyway */
+				task_lock(current);
+				current->lids_cap = 0x0UL;
+				current->lids_sys_acl = NULL;
+				task_unlock(current);
+				lids_free_lids_task_acl(&computed_acl);
+			}
+			lids_free_lids_task_acl(&current_acl);
+		} else {
+			LIDS_DBG("%i has no lids_sys_acl, and try to exec %s\n",
+				 current->pid, filename);
+
+		}
+	}
+lids_sandbox_out:
+	LIDS_DBG("##### pid %i: lids_cap=0x%lx: [%s]\n", current->pid,
+		 current->lids_cap, filename);
+#endif
+
 	retval = search_binary_handler(&bprm,regs);
 	if (retval >= 0)
 		/* execve success */
diff -durN kernel.orig/fs/namei.c kernel/fs/namei.c
--- kernel.orig/fs/namei.c	2007-03-20 14:08:49.000000000 +1000
+++ kernel/fs/namei.c	2007-03-20 14:52:55.000000000 +1000
@@ -22,6 +22,9 @@
 #include <linux/dnotify.h>
 #include <linux/smp_lock.h>
 #include <linux/personality.h>
+#ifdef CONFIG_LIDS
+#include <linux/lids.h>
+#endif
 
 #include <asm/namei.h>
 #include <asm/uaccess.h>
@@ -453,7 +456,10 @@
 	struct inode *inode;
 	int err;
 	unsigned int lookup_flags = nd->flags;
-
+#ifdef CONFIG_LIDS
+	char *lids_filename;
+	lids_filename = (char *)name;
+#endif
 	while (*name=='/')
 		name++;
 	if (!*name)
@@ -641,6 +647,27 @@
 			}
 		}
 return_base:
+#ifdef CONFIG_LIDS
+		if (lids_load && lids_local_load &&
+		    lids_check_base(nd->dentry, LIDS_READONLY) < 0) {
+#ifdef CONFIG_LIDS_HANGUP
+			if (current->tty != NULL)
+				set_bit(TTY_LIDS_NO_HANGUP,
+					&(current->tty->flags));
+#endif
+			if (nd->dentry->d_inode)
+				lids_alert(LIDS_READONLY, nd->dentry,
+					   nd->dentry->d_inode->i_ino,
+					   nd->dentry->d_inode->i_dev,
+					   lids_filename, "open");
+			else
+				lids_security_alert("access hidden file %s",
+						    lids_filename);
+			err = (lids_acl_discovery ? 0 : -ENOENT);
+			if (err)
+				break;
+		}
+#endif
 		return 0;
 out_dput:
 		dput(dentry);
@@ -995,6 +1022,61 @@
 	struct dentry *dir;
 	int count = 0;
 
+#ifdef CONFIG_LIDS
+	/* search the dentry */
+	if (lids_load && lids_local_load) {
+                if (path_init(pathname, lookup_flags(flag), nd))
+                    error = path_walk(pathname, nd);
+
+		if (error)
+			return error;
+
+		dentry = nd->dentry;
+
+		if (dentry && ((flag & O_ACCMODE) > 1)) {
+			if (flag & O_APPEND) {
+				error = lids_check_base(dentry, LIDS_APPEND);
+				if (error) {
+					if (dentry->d_inode) {
+						lids_alert(LIDS_APPEND, dentry,
+							   dentry->d_inode->i_ino,
+							   dentry->d_inode->i_dev,
+							   (char *) pathname, "open");
+
+					} else {
+						lids_security_alert("Attempt to open "
+								    "%.1024s for "
+								    "appending, "
+								    "flag = %d",
+								    pathname, flag);
+					}
+				}
+			} else {
+				error = lids_check_base(dentry, LIDS_WRITE);
+				if (error) {
+					if (dentry->d_inode) {
+						lids_alert(LIDS_WRITE, dentry,
+							   dentry->d_inode->i_ino,
+							   dentry->d_inode->i_dev,
+							   (char *) pathname, "open");
+					} else {
+						lids_security_alert("Attempt to open "
+								    "%.1024s for "
+								    "writing, "
+								    "flag = %d",
+								    pathname, flag);
+					}
+				}
+			}
+			if (error < 0 ) {
+				error = (lids_acl_discovery ? 0 : -EPERM);
+				if (error)
+					goto exit;
+			}
+		}
+		path_release(nd);
+	}
+#endif
 	acc_mode = ACC_MODE(flag);
 
 	/*
@@ -1258,6 +1340,10 @@
 	char * tmp;
 	struct dentry * dentry;
 	struct nameidata nd;
+#ifdef CONFIG_LIDS
+	char *lids_filename;
+	lids_filename = (char *)filename;
+#endif
 
 	if (S_ISDIR(mode))
 		return -EPERM;
@@ -1274,6 +1360,25 @@
 
 	mode &= ~current->fs->umask;
 	if (!IS_ERR(dentry)) {
+#ifdef CONFIG_LIDS
+		if (lids_load && lids_local_load &&
+		    lids_check_base(dentry, LIDS_WRITE)) {
+			if (dentry->d_inode)
+				lids_alert(LIDS_WRITE, dentry,
+					   dentry->d_inode->i_ino,
+					   dev, lids_filename, "mknod");
+			else
+				lids_security_alert("Attempt to mknod "
+						    "%.1024s (%d %d)",
+						    filename, MAJOR(dev),
+						    MINOR(dev));
+			error = (lids_acl_discovery ? 0 : -EPERM);
+			if (error) {
+				dput(dentry);
+				goto pout;
+			}
+		}
+#endif
 		switch (mode & S_IFMT) {
 		case 0: case S_IFREG:
 			error = vfs_create(nd.dentry->d_inode,dentry,mode);
@@ -1289,6 +1394,7 @@
 		}
 		dput(dentry);
 	}
+pout:
 	up(&nd.dentry->d_inode->i_sem);
 	path_release(&nd);
 out:
@@ -1327,6 +1433,10 @@
 {
 	int error = 0;
 	char * tmp;
+#ifdef CONFIG_LIDS
+	char *lids_pathname;
+	lids_pathname = (char *)pathname;
+#endif
 
 	tmp = getname(pathname);
 	error = PTR_ERR(tmp);
@@ -1341,6 +1451,24 @@
 		dentry = lookup_create(&nd, 1);
 		error = PTR_ERR(dentry);
 		if (!IS_ERR(dentry)) {
+#ifdef CONFIG_LIDS
+			error = 0; /* FIXME, do we need this? */
+			if (lids_load && lids_local_load &&
+			    lids_check_base(dentry, LIDS_WRITE)) {
+				if (dentry->d_inode)
+					lids_alert(LIDS_WRITE,
+						   dentry,
+						   dentry->d_inode->i_ino,
+						   dentry->d_inode->i_dev,
+						   lids_pathname,
+						   "mkdir");
+				else
+					lids_security_alert("Attempt to mkdir %.1024s",
+							    pathname);
+				error = (lids_acl_discovery ? 0 : -EPERM);
+			}
+			if (!error)
+#endif
 			error = vfs_mkdir(nd.dentry->d_inode, dentry,
 					  mode & ~current->fs->umask);
 			dput(dentry);
@@ -1426,6 +1554,10 @@
 	char * name;
 	struct dentry *dentry;
 	struct nameidata nd;
+#ifdef CONFIG_LIDS
+	char *lids_pathname;
+	lids_pathname = (char *)pathname;
+#endif
 
 	name = getname(pathname);
 	if(IS_ERR(name))
@@ -1451,6 +1583,24 @@
 	dentry = lookup_hash(&nd.last, nd.dentry);
 	error = PTR_ERR(dentry);
 	if (!IS_ERR(dentry)) {
+#ifdef CONFIG_LIDS
+		error = 0; /* FIXME, do we actually need this ?*/
+		if (lids_load && lids_local_load) {
+			if (lids_check_base(dentry, LIDS_WRITE)) {
+				if (dentry->d_inode)
+					lids_alert(LIDS_WRITE,
+						   dentry,
+						   dentry->d_inode->i_ino,
+						   dentry->d_inode->i_dev,
+						   lids_pathname, "rmdir");
+				else
+					lids_security_alert("Attempt to rmdir %.1024s",
+							    name);
+				error = (lids_acl_discovery ? 0 : -EPERM);
+			}
+		}
+		if (!error)
+#endif
 		error = vfs_rmdir(nd.dentry->d_inode, dentry);
 		dput(dentry);
 	}
@@ -1495,6 +1645,10 @@
 	char * name;
 	struct dentry *dentry;
 	struct nameidata nd;
+#ifdef CONFIG_LIDS
+	char *lids_pathname;
+	lids_pathname = (char *)pathname;
+#endif
 
 	name = getname(pathname);
 	if(IS_ERR(name))
@@ -1514,6 +1668,23 @@
 		/* Why not before? Because we want correct error value */
 		if (nd.last.name[nd.last.len])
 			goto slashes;
+#ifdef CONFIG_LIDS
+		error = 0; /* FIXME, do we actually need this ?*/
+		if (lids_load && lids_local_load &&
+		    lids_check_base(dentry, LIDS_WRITE)) {
+			if (dentry->d_inode)
+				lids_alert(LIDS_WRITE,
+					   dentry,
+					   dentry->d_inode->i_ino,
+					   dentry->d_inode->i_dev,
+					   lids_pathname, "unlink");
+			else
+				lids_security_alert("Attempt to unlink %.1024s",
+						     pathname);
+			error = (lids_acl_discovery ? 0 : -EPERM);
+		}
+		if (!error)
+#endif
 		error = vfs_unlink(nd.dentry->d_inode, dentry);
 	exit2:
 		dput(dentry);
@@ -1562,6 +1733,10 @@
 	int error = 0;
 	char * from;
 	char * to;
+#ifdef CONFIG_LIDS
+	char *lids_newname;
+	lids_newname = (char *)newname;
+#endif
 
 	from = getname(oldname);
 	if(IS_ERR(from))
@@ -1579,6 +1754,24 @@
 		dentry = lookup_create(&nd, 0);
 		error = PTR_ERR(dentry);
 		if (!IS_ERR(dentry)) {
+#ifdef CONFIG_LIDS
+			error = 0; /* FIXME, do we actually need this ?*/
+			if (lids_load && lids_local_load &&
+			    lids_check_base(dentry, LIDS_WRITE)) {
+				if (dentry->d_inode)
+					lids_alert(LIDS_WRITE,
+						   dentry,
+						   dentry->d_inode->i_ino,
+						   dentry->d_inode->i_dev,
+						   lids_newname, "symlink");
+				else
+					lids_security_alert("Attempt to symlink "
+							    "%.1024s to %.1024s",
+							    oldname, newname);
+				error = (lids_acl_discovery ? 0 : -EPERM);
+			}
+			if (!error)
+#endif
 			error = vfs_symlink(nd.dentry->d_inode, dentry, from);
 			dput(dentry);
 		}
@@ -1645,6 +1838,10 @@
 	int error;
 	char * from;
 	char * to;
+#ifdef CONFIG_LIDS
+	char *lids_newname;
+	lids_newname = (char *)newname;
+#endif
 
 	from = getname(oldname);
 	if(IS_ERR(from))
@@ -1670,6 +1867,25 @@
 		new_dentry = lookup_create(&nd, 0);
 		error = PTR_ERR(new_dentry);
 		if (!IS_ERR(new_dentry)) {
+#ifdef CONFIG_LIDS
+			error = 0; /* FIXME, do we actually need this ?*/
+			if (lids_load && lids_local_load &&
+			    (lids_check_base(old_nd.dentry, LIDS_WRITE) ||
+			     lids_check_base(new_dentry, LIDS_WRITE))) {
+				if (new_dentry->d_inode)
+					lids_alert(LIDS_WRITE,
+						   new_dentry,
+						   new_dentry->d_inode->i_ino,
+						   new_dentry->d_inode->i_dev,
+						   lids_newname, "link");
+				else
+					lids_security_alert("Attempt to link "
+							    "%.1024s to %.1024s",
+							    oldname, newname);
+				error = (lids_acl_discovery ? 0 : -EPERM);
+			}
+			if (!error)
+#endif
 			error = vfs_link(old_nd.dentry, nd.dentry->d_inode, new_dentry);
 			dput(new_dentry);
 		}
@@ -1858,6 +2074,10 @@
 	struct dentry * old_dir, * new_dir;
 	struct dentry * old_dentry, *new_dentry;
 	struct nameidata oldnd, newnd;
+#ifdef CONFIG_LIDS
+	char *lids_newname;
+	lids_newname = (char *)newname;
+#endif
 
 	if (path_init(oldname, LOOKUP_PARENT, &oldnd))
 		error = path_walk(oldname, &oldnd);
@@ -1906,11 +2126,34 @@
 	if (IS_ERR(new_dentry))
 		goto exit4;
 
+#ifdef CONFIG_LIDS
+	error = 0;
+	if (lids_load && lids_local_load &&
+	    (lids_check_base(old_dentry, LIDS_WRITE) ||
+	     lids_check_base(new_dentry, LIDS_WRITE))) {
+		if (new_dentry->d_inode)
+			lids_alert(LIDS_WRITE,
+				   new_dentry,
+				   new_dentry->d_inode->i_ino,
+				   new_dentry->d_inode->i_dev,
+				   lids_newname, "rename");
+		else
+			lids_security_alert("Attempt to rename "
+					    "%.1024s to %.1024s",
+					    oldname, newname);
+		error = (lids_acl_discovery ? 0 : -EPERM);
+		if (error)
+			goto exit_new;
+	}
+	if (!error)
+#endif
+	{
 	lock_kernel();
 	error = vfs_rename(old_dir->d_inode, old_dentry,
-				   new_dir->d_inode, new_dentry);
+			   new_dir->d_inode, new_dentry);
 	unlock_kernel();
-
+	}
+exit_new:
 	dput(new_dentry);
 exit4:
 	dput(old_dentry);
diff -durN kernel.orig/fs/namespace.c kernel/fs/namespace.c
--- kernel.orig/fs/namespace.c	2007-03-20 14:08:49.000000000 +1000
+++ kernel/fs/namespace.c	2007-03-20 14:52:55.000000000 +1000
@@ -379,8 +379,13 @@
 		goto dput_and_out;
 
 	retval = -EPERM;
-	if (!capable(CAP_SYS_ADMIN))
+	if (!capable(CAP_SYS_ADMIN)) {
+#ifdef CONFIG_LIDS
+		lids_security_alert("CAP_SYS_ADMIN violation: "
+				    "try to umount %s", name);
+#endif
 		goto dput_and_out;
+	}
 
 	retval = do_umount(nd.mnt, flags);
 dput_and_out:
@@ -400,9 +405,13 @@
 
 static int mount_is_safe(struct nameidata *nd)
 {
-	if (capable(CAP_SYS_ADMIN))
+	if (capable(CAP_SYS_ADMIN)) {
 		return 0;
-	return -EPERM;
+	}
+#ifdef CONFIG_LIDS
+	lids_security_alert("CAP_SYS_ADMIN violation: mount_is_safe");
+#endif
+ 	return -EPERM;
 #ifdef notyet
 	if (S_ISLNK(nd->dentry->d_inode->i_mode))
 		return -EPERM;
@@ -537,8 +546,12 @@
 	int err;
 	struct super_block * sb = nd->mnt->mnt_sb;
 
-	if (!capable(CAP_SYS_ADMIN))
+	if (!capable(CAP_SYS_ADMIN)) {
+#ifdef CONFIG_LIDS
+	lids_security_alert("CAP_SYS_ADMIN violation: do_remount");
+#endif
 		return -EPERM;
+	}
 
 	if (!check_mnt(nd->mnt))
 		return -EINVAL;
@@ -625,8 +638,13 @@
 		return -EINVAL;
 
 	/* we need capabilities... */
-	if (!capable(CAP_SYS_ADMIN))
+	if (!capable(CAP_SYS_ADMIN)) {
+#ifdef CONFIG_LIDS
+		lids_security_alert("CAP_SYS_ADMIN violation: "
+				    "try to mount %s", name);
+#endif
 		return -EPERM;
+	}
 
 	mnt = do_kern_mount(type, flags, name, data);
 	err = PTR_ERR(mnt);
@@ -913,8 +931,12 @@
 	char *name;
 	int error;
 
-	if (!capable(CAP_SYS_ADMIN))
+	if (!capable(CAP_SYS_ADMIN)) {
+#ifdef CONFIG_LIDS
+	lids_security_alert("CAP_SYS_ADMIN violation: sys_pivot_root");
+#endif
 		return -EPERM;
+	}
 
 	lock_kernel();
 
diff -durN kernel.orig/fs/open.c kernel/fs/open.c
--- kernel.orig/fs/open.c	2007-03-20 14:08:50.000000000 +1000
+++ kernel/fs/open.c	2007-03-20 14:52:55.000000000 +1000
@@ -15,6 +15,9 @@
 #include <linux/slab.h>
 #include <linux/tty.h>
 #include <linux/iobuf.h>
+#ifdef CONFIG_LIDS
+#include <linux/lids.h>
+#endif
 
 #include <asm/uaccess.h>
 
@@ -105,6 +108,19 @@
 	if (length < 0)
 		return -EINVAL;
 
+#ifdef CONFIG_LIDS
+	if (lids_load && lids_local_load &&
+	    (lids_check_base(dentry, LIDS_WRITE) < 0)) {
+		lids_alert(LIDS_WRITE, dentry,
+			   dentry->d_inode->i_ino,
+			   dentry->d_inode->i_dev,
+			   dentry->d_iname, "truncate");
+		error = (lids_acl_discovery ? 0 : -EPERM);
+		if (error)
+			return error;
+	}
+#endif
+
 	down(&inode->i_sem);
 	newattrs.ia_size = length;
 	newattrs.ia_valid = ATTR_SIZE | ATTR_CTIME;
@@ -259,6 +275,10 @@
 	struct nameidata nd;
 	struct inode * inode;
 	struct iattr newattrs;
+#ifdef CONFIG_LIDS
+	char *lids_file_name;
+	lids_file_name = (char *)filename;
+#endif
 
 	error = user_path_walk(filename, &nd);
 	if (error)
@@ -268,7 +288,17 @@
 	error = -EROFS;
 	if (IS_RDONLY(inode))
 		goto dput_and_out;
-
+#ifdef CONFIG_LIDS
+ 	if(lids_load && lids_local_load &&
+	   lids_check_base(nd.dentry, LIDS_WRITE)) {
+		lids_alert(LIDS_WRITE, nd.dentry,
+			   inode->i_ino, inode->i_dev,
+			   lids_file_name, "utime");
+		error = (lids_acl_discovery ? 0 : -EPERM);
+		if (error)
+			goto dput_and_out;
+ 	}
+#endif
 	/* Don't worry, the checks are done in inode_change_ok() */
 	newattrs.ia_valid = ATTR_CTIME | ATTR_MTIME | ATTR_ATIME;
 	if (times) {
@@ -347,6 +377,11 @@
 	int old_fsuid, old_fsgid;
 	kernel_cap_t old_cap;
 	int res;
+#ifdef CONFIG_LIDS
+	char *lids_file_name;
+	lids_file_name = (char *)filename;
+#endif
+
 
 	if (mode & ~S_IRWXO)	/* where's F_OK, X_OK, W_OK, R_OK? */
 		return -EINVAL;
@@ -371,6 +406,17 @@
 		if(!res && (mode & S_IWOTH) && IS_RDONLY(nd.dentry->d_inode)
 		   && !special_file(nd.dentry->d_inode->i_mode))
 			res = -EROFS;
+#ifdef CONFIG_LIDS
+                if(!res && (mode & S_IWOTH ) &&
+		   lids_load && lids_local_load &&
+		   lids_check_base(nd.dentry, LIDS_WRITE)) {
+			lids_alert(LIDS_WRITE, nd.dentry,
+				   nd.dentry->d_inode->i_ino,
+				   nd.dentry->d_inode->i_dev,
+				   lids_file_name, "access");
+			res = (lids_acl_discovery ? 0 : -EPERM);
+                }
+#endif
 		path_release(&nd);
 	}
 
@@ -464,8 +510,13 @@
 		goto dput_and_out;
 
 	error = -EPERM;
-	if (!capable(CAP_SYS_CHROOT))
+	if (!capable(CAP_SYS_CHROOT)) {
+#ifdef CONFIG_LIDS
+		lids_security_alert("CAP_SYS_CHROOT violation: "
+				    "Attempt to chroot %s", filename);
+#endif
 		goto dput_and_out;
+	}
 
 	set_fs_root(current->fs, nd.mnt, nd.dentry);
 	set_fs_altroot();
@@ -494,6 +545,16 @@
 	err = -EROFS;
 	if (IS_RDONLY(inode))
 		goto out_putf;
+#ifdef CONFIG_LIDS
+        if (lids_load && lids_local_load &&
+	    lids_check_base(dentry, LIDS_WRITE)) {
+		lids_alert(LIDS_WRITE, dentry, inode->i_ino,
+			   inode->i_dev, dentry->d_iname, "fchmod");
+		err = (lids_acl_discovery ? 0 : -EPERM);
+		if (err)
+			goto out_putf;
+        }
+#endif
 	err = -EPERM;
 	if (IS_IMMUTABLE(inode) || IS_APPEND(inode))
 		goto out_putf;
@@ -515,6 +576,10 @@
 	struct inode * inode;
 	int error;
 	struct iattr newattrs;
+#ifdef CONFIG_LIDS
+	char *lids_file_name;
+	lids_file_name = (char *)filename;
+#endif
 
 	error = user_path_walk(filename, &nd);
 	if (error)
@@ -525,6 +590,16 @@
 	if (IS_RDONLY(inode))
 		goto dput_and_out;
 
+#ifdef CONFIG_LIDS
+        if (lids_load && (nd.dentry != NULL) && lids_local_load &&
+	    lids_check_base(nd.dentry, LIDS_WRITE)) {
+		lids_alert(LIDS_WRITE, nd.dentry, inode->i_ino,
+			   inode->i_dev, lids_file_name, "chmod");
+		error = (lids_acl_discovery ? 0 : -EPERM);
+		if (error)
+			goto dput_and_out;
+        }
+#endif
 	error = -EPERM;
 	if (IS_IMMUTABLE(inode) || IS_APPEND(inode))
 		goto dput_and_out;
@@ -555,6 +630,16 @@
 	error = -EROFS;
 	if (IS_RDONLY(inode))
 		goto out;
+#ifdef CONFIG_LIDS
+        if (lids_load && (dentry != NULL) && lids_local_load &&
+	    (lids_check_base(dentry,LIDS_WRITE) < 0)) {
+		lids_alert(LIDS_WRITE, dentry, inode->i_ino,
+			   inode->i_dev, dentry->d_iname, "chown");
+		error = (lids_acl_discovery ? 0 : -EPERM);
+		if (error)
+			goto out;
+        }
+#endif
 	error = -EPERM;
 	if (IS_IMMUTABLE(inode) || IS_APPEND(inode))
 		goto out;
diff -durN kernel.orig/fs/proc/base.c kernel/fs/proc/base.c
--- kernel.orig/fs/proc/base.c	2007-03-20 14:08:50.000000000 +1000
+++ kernel/fs/proc/base.c	2007-03-20 14:55:48.000000000 +1000
@@ -26,6 +26,10 @@
 #include <linux/seq_file.h>
 #include <linux/namespace.h>
 
+#ifdef CONFIG_LIDS
+#include <linux/lids.h>
+#endif
+
 /*
  * For hysterical raisins we keep the same inumbers as in the old procfs.
  * Feel free to change the macro below - just keep the range distinct from
@@ -513,6 +517,84 @@
 	return error;
 }
 
+#ifdef CONFIG_LIDS
+static int proc_pid_lids_key(struct task_struct *task, char * buffer)
+{
+	int res = 0;
+        if ( buffer == 0 ) {
+            printk( "proc_pid_lids_key - can't put data in null buffer\n" );
+            return -EIO;
+        }
+        if ( task == 0 ) {
+            printk( "proc_pid_lids_key - can't do key for null task\n" );
+            return -EIO;
+        }
+	if ( task->pid != current->pid ) {
+		lids_security_alert("Attempt to read /proc/%d/key by pid %d",
+				    task->pid, current->pid );
+		res = -EPERM;
+	} else {
+		res = lids_get_key( task, buffer );
+	}
+	return res;
+}
+
+
+/*
+   Check the permissions for opening a file.  Note that being denied
+   permission here is not a lids alert, since a process can validly
+   use the access (2) call to check for permissions without operating
+   on the file.
+*/
+static int proc_lids_key_permission(struct inode *inode, int mask)
+{
+        int res = 0;
+	struct task_struct *task;
+
+        /* normal permission checks */
+	res = vfs_permission(inode, mask);
+        if ( res != 0 )
+                goto out;
+
+        /* check for chroot or namespace traversal via bind mount */
+	res = proc_check_root(inode);
+        if ( res != 0 )
+                goto out;
+
+        /* pid can only read its own key */
+	task = inode->u.proc_i.task;
+	if ( task->pid != current->pid )
+                res = -EACCES;
+out:
+        /* printk( "lids proc key permissions check: %d\n", res ); */
+        return res;
+}
+
+static int proc_lids_key_open(struct inode* inode, struct file* file)
+{
+        int res = 0;
+	struct task_struct *task = inode->u.proc_i.task;
+	if ( task->pid != current->pid ) {
+		lids_security_alert("Attempt to read /proc/%d/key by pid %d",
+				    task->pid, current->pid );
+		res = -EPERM;
+        }
+	file->private_data = (void*)1;
+        /* printk( "lids proc key open: %d\n", res ); */
+	return 0;
+}
+
+static struct inode_operations proc_lids_key_inode_operations = {
+	permission:	proc_lids_key_permission,
+};
+
+
+static struct file_operations proc_lids_key_file_operations = {
+	open:		proc_lids_key_open,
+	read:		proc_info_read,
+};
+#endif
+
 static struct inode_operations proc_pid_link_inode_operations = {
 	readlink:	proc_pid_readlink,
 	follow_link:	proc_pid_follow_link
@@ -540,6 +622,9 @@
 	PROC_PID_MAPS,
 	PROC_PID_CPU,
 	PROC_PID_MOUNTS,
+#ifdef CONFIG_LIDS
+        PROC_PID_LIDS_KEY,
+#endif
 	PROC_PID_FD_DIR = 0x8000,	/* 0x8000-0xffff */
 };
 
@@ -560,6 +645,9 @@
   E(PROC_PID_ROOT,	"root",		S_IFLNK|S_IRWXUGO),
   E(PROC_PID_EXE,	"exe",		S_IFLNK|S_IRWXUGO),
   E(PROC_PID_MOUNTS,	"mounts",	S_IFREG|S_IRUGO),
+#ifdef CONFIG_LIDS
+  E(PROC_PID_LIDS_KEY,	"lids_key",	S_IFREG|S_IRUSR),
+#endif
   {0,0,NULL,0}
 };
 #undef E
@@ -928,6 +1016,13 @@
 		case PROC_PID_MOUNTS:
 			inode->i_fop = &proc_mounts_operations;
 			break;
+#ifdef CONFIG_LIDS
+		case PROC_PID_LIDS_KEY:
+			inode->i_op = &proc_lids_key_inode_operations;
+			inode->i_fop = &proc_lids_key_file_operations;
+			inode->u.proc_i.op.proc_read = proc_pid_lids_key;
+			break;
+#endif
 		default:
 			printk("procfs: impossible type (%d)",p->type);
 			iput(inode);
@@ -1018,6 +1113,12 @@
 	read_unlock(&tasklist_lock);
 	if (!task)
 		goto out;
+#ifdef CONFIG_LIDS
+	if (cap_raised(task->lids_cap, CAP_HIDDEN) &&
+	    lids_load && lids_local_load && !lids_acl_discovery)
+		inode = NULL;
+	else
+#endif
 
 	inode = proc_pid_make_inode(dir->i_sb, task, PROC_PID_INO);
 
@@ -1065,6 +1166,12 @@
 		int pid = p->pid;
 		if (!pid)
 			continue;
+#ifdef CONFIG_LIDS
+		if (cap_raised(p->lids_cap,CAP_HIDDEN) &&
+		    lids_load && lids_local_load &&
+		    !lids_acl_discovery)
+			continue;
+#endif
 		if (--index >= 0)
 			continue;
 		pids[nr_pids] = pid;
diff -durN kernel.orig/fs/readdir.c kernel/fs/readdir.c
--- kernel.orig/fs/readdir.c	2007-03-20 14:08:50.000000000 +1000
+++ kernel/fs/readdir.c	2007-03-20 14:52:55.000000000 +1000
@@ -10,6 +10,9 @@
 #include <linux/stat.h>
 #include <linux/file.h>
 #include <linux/smp_lock.h>
+#ifdef CONFIG_LIDS
+#include <linux/lids.h>
+#endif
 
 #include <asm/uaccess.h>
 
@@ -17,6 +20,7 @@
 {
 	struct inode *inode = file->f_dentry->d_inode;
 	int res = -ENOTDIR;
+
 	if (!file->f_op || !file->f_op->readdir)
 		goto out;
 	down(&inode->i_sem);
@@ -181,6 +185,9 @@
 struct readdir_callback {
 	struct old_linux_dirent * dirent;
 	int count;
+#ifdef CONFIG_LIDS
+	struct dentry *r_dentry;
+#endif
 };
 
 static int fillonedir(void * __buf, const char * name, int namlen, loff_t offset,
@@ -191,6 +198,18 @@
 
 	if (buf->count)
 		return -EINVAL;
+#ifdef CONFIG_LIDS
+	if (lids_load && lids_local_load &&
+	    (lids_check_hidden_inode(ino, buf->r_dentry->d_inode->i_dev) < 0)) {
+		struct dentry d = *(buf->r_dentry);
+		struct inode i = *(buf->r_dentry->d_inode);
+		i.i_ino = ino;
+		d.d_inode = &i;
+		if (lids_check_base(&d, LIDS_READONLY) &&
+		    !lids_acl_discovery)
+			return 0;
+	}
+#endif
 	buf->count++;
 	dirent = buf->dirent;
 	put_user(ino, &dirent->d_ino);
@@ -214,7 +233,16 @@
 
 	buf.count = 0;
 	buf.dirent = dirent;
-
+#ifdef CONFIG_LIDS
+	/* FIXME, may be a member of dentry will be good*/
+	buf.r_dentry = 0;
+	if (file->f_dentry) {
+		if (file->f_dentry->d_inode)
+			buf.r_dentry = file->f_dentry;
+		else
+			printk("%s :bug!!\n", __FUNCTION__);
+	}
+#endif
 	error = vfs_readdir(file, fillonedir, &buf);
 	if (error >= 0)
 		error = buf.count;
@@ -242,6 +270,9 @@
 	struct linux_dirent * previous;
 	int count;
 	int error;
+#ifdef CONFIG_LIDS
+	struct dentry *g_dentry;
+#endif
 };
 
 static int filldir(void * __buf, const char * name, int namlen, loff_t offset,
@@ -255,6 +286,19 @@
 	if (reclen > buf->count)
 		return -EINVAL;
 	dirent = buf->previous;
+#ifdef CONFIG_LIDS
+	/* added by xhg at 2000-4-14 */
+	if (lids_load && lids_local_load &&
+	    (lids_check_hidden_inode(ino, buf->g_dentry->d_inode->i_dev) < 0)) {
+		struct dentry d = *(buf->g_dentry);
+		struct inode i = *(buf->g_dentry->d_inode);
+		i.i_ino = ino;
+		d.d_inode = &i;
+		if (lids_check_base(&d, LIDS_READONLY) &&
+		    !lids_acl_discovery)
+			return 0;
+	}
+#endif
 	if (dirent)
 		put_user(offset, &dirent->d_off);
 	dirent = buf->current_dir;
@@ -285,7 +329,16 @@
 	buf.previous = NULL;
 	buf.count = count;
 	buf.error = 0;
-
+#ifdef CONFIG_LIDS
+/* FIXME, may be a member of dentry will be good*/
+	buf.g_dentry = 0;
+	if(file->f_dentry) {
+		if(file->f_dentry->d_inode)
+			buf.g_dentry = file->f_dentry;
+		else
+			printk("%s :BUG!!", __FUNCTION__);
+	}
+#endif
 	error = vfs_readdir(file, filldir, &buf);
 	if (error < 0)
 		goto out_putf;
@@ -320,6 +373,9 @@
 	struct linux_dirent64 * previous;
 	int count;
 	int error;
+#ifdef CONFIG_LIDS
+	struct dentry *g_dentry;
+#endif
 };
 
 static int filldir64(void * __buf, const char * name, int namlen, loff_t offset,
@@ -333,6 +389,19 @@
 	if (reclen > buf->count)
 		return -EINVAL;
 	dirent = buf->previous;
+#ifdef CONFIG_LIDS
+        /* added by xhg at 2000-4-14 */
+	if (lids_load && lids_local_load &&
+	    (lids_check_hidden_inode(ino, buf->g_dentry->d_inode->i_dev) < 0)) {
+		struct dentry d = *(buf->g_dentry);
+		struct inode i = *(buf->g_dentry->d_inode);
+		i.i_ino = ino;
+		d.d_inode = &i;
+		if (lids_check_base(&d, LIDS_READONLY) &&
+		    !lids_acl_discovery)
+			return 0;
+	}
+#endif
 	if (dirent) {
 		d.d_off = offset;
 		copy_to_user(&dirent->d_off, &d.d_off, sizeof(d.d_off));
@@ -368,7 +437,16 @@
 	buf.previous = NULL;
 	buf.count = count;
 	buf.error = 0;
-
+#ifdef CONFIG_LIDS
+/* FIXME, may be a member of dentry will be good*/
+	buf.g_dentry = 0;
+	if (file->f_dentry) {
+		if (file->f_dentry->d_inode)
+			buf.g_dentry = file->f_dentry;
+		else
+			printk("%s :BUG!!", __FUNCTION__);
+	}
+#endif
 	error = vfs_readdir(file, filldir64, &buf);
 	if (error < 0)
 		goto out_putf;
diff -durN kernel.orig/fs/read_write.c kernel/fs/read_write.c
--- kernel.orig/fs/read_write.c	2007-03-20 14:08:50.000000000 +1000
+++ kernel/fs/read_write.c	2007-03-20 14:52:55.000000000 +1000
@@ -26,6 +26,9 @@
 #include <linux/uio.h>
 #include <linux/smp_lock.h>
 #include <linux/dnotify.h>
+#ifdef CONFIG_LIDS
+#include <linux/lids.h>
+#endif
 
 #include <asm/uaccess.h>
 
@@ -168,6 +171,23 @@
 	file = fget(fd);
 	if (file) {
 		if (file->f_mode & FMODE_READ) {
+#ifdef CONFIG_LIDS
+			struct inode *inode;
+			inode = file->f_dentry->d_inode;
+			if (inode && S_ISBLK(inode->i_mode) &&
+			    (!lids_cap_raised(CAP_SYS_RAWIO, 1)))
+				if ((lids_load) && lids_local_load) {
+					lids_security_alert("CAP_SYS_RAWIO violation: "
+							    "Attempt to read to raw device %d:%d",
+							    MAJOR(inode->i_dev),
+							    MINOR(inode->i_dev));
+					fput(file);
+					return ret;
+				}
+#endif
+#if defined(CONFIG_LIDS_TDE) && !defined(CONFIG_LIDS_TDE_SANDBOX_ONLY)
+			lids_tde_policy(file->f_dentry, current);
+#endif
 			ret = locks_verify_area(FLOCK_VERIFY_READ, file->f_dentry->d_inode,
 						file, file->f_pos, count);
 			if (!ret) {
@@ -199,8 +219,18 @@
 			if (!ret) {
 				ssize_t (*write)(struct file *, const char *, size_t, loff_t *);
 				ret = -EINVAL;
-				if (file->f_op && (write = file->f_op->write) != NULL)
+				if (file->f_op && (write = file->f_op->write) != NULL) {
+#ifdef CONFIG_LIDS
+					if (inode && S_ISBLK(inode->i_mode) &&
+					    (!lids_cap_raised(CAP_SYS_RAWIO, 1)))
+						lids_security_alert("CAP_SYS_RAWIO violation: "
+								    "Attempt to write to raw device %d:%d",
+								    MAJOR(inode->i_dev),
+								    MINOR(inode->i_dev));
+					else
+#endif
 					ret = write(file, buf, count, &file->f_pos);
+				}
 			}
 		}
 		if (ret > 0)
diff -durN kernel.orig/include/linux/capability.h kernel/include/linux/capability.h
--- kernel.orig/include/linux/capability.h	2007-03-20 14:09:01.000000000 +1000
+++ kernel/include/linux/capability.h	2007-03-20 14:52:58.000000000 +1000
@@ -279,11 +279,26 @@
 
 #define CAP_LEASE            28
 
+#ifdef CONFIG_LIDS
+/* hide the process from the system */
+#define CAP_HIDDEN           29
+
+/* Allow the process to KILL protected programms */
+#define CAP_KILL_PROTECTED   30
+
+/* Protect the process from signals */
+#define CAP_PROTECTED        31
+#endif
+
+
 #ifdef __KERNEL__
 /* 
  * Bounding set
  */
 extern kernel_cap_t cap_bset;
+#ifdef CONFIG_LIDS
+extern kernel_cap_t lids_cap_val;
+#endif
 
 /*
  * Internal kernel functions only
diff -durN kernel.orig/include/linux/fs.h kernel/include/linux/fs.h
--- kernel.orig/include/linux/fs.h	2007-03-20 14:09:02.000000000 +1000
+++ kernel/include/linux/fs.h	2007-03-20 14:52:58.000000000 +1000
@@ -485,6 +485,9 @@
 
 	atomic_t		i_writecount;
 	unsigned int		i_attr_flags;
+#ifdef CONFIG_LIDS_NF_MARK
+	void			*i_security;
+#endif
 	__u32			i_generation;
 	union {
 		struct minix_inode_info		minix_i;
diff -durN kernel.orig/include/linux/lidsext.h kernel/include/linux/lidsext.h
--- kernel.orig/include/linux/lidsext.h	1970-01-01 10:00:00.000000000 +1000
+++ kernel/include/linux/lidsext.h	2007-03-20 14:52:59.000000000 +1000
@@ -0,0 +1,103 @@
+#ifndef LIDSEXT_H
+#define LIDSEXT_H
+
+/*
+ * This file contains LIDS macros needed for logging and debugging,
+ * used about everywhere in the kernel.
+ *
+ */
+
+/* needed extern declarations */
+
+#include <linux/config.h>
+
+extern void lids_cap_log(int);
+extern int lids_cap_time_checker(const int);
+extern int lids_cap_raised(const int, int);
+extern int lids_local_off(void);
+extern int lids_reload_conf;
+extern int lids_load;
+extern int lids_local_on;
+extern int lids_local_pid;
+extern int lids_first_time;
+extern int lids_acl_discovery;
+extern int lids_state;
+extern char *lids_caps_desc[];
+
+#ifdef CONFIG_LIDS_DEBUG
+#define LIDS_DEBUG
+#endif
+
+#ifdef LIDS_DEBUG
+#define LIDS_DBG(fmt, arg...)					\
+	do {							\
+		printk(KERN_DEBUG "LIDS: %s:%i: " fmt,		\
+		       __FUNCTION__ , __LINE__ , ## arg);	\
+	} while (0)
+#else
+#define LIDS_DBG(fmt, arg...) do {} while (0)
+#endif
+
+#ifdef CONFIG_LIDS_HANGUP
+extern void lids_hangup_console(void);
+#else
+#define lids_hangup_console() do {} while (0)
+#endif
+
+extern void lids_log(int flood, char *message, ...);
+
+#ifdef CONFIG_LIDS_NO_FLOOD_LOG
+
+#define lids_security_alert(message, args...)					    \
+do {										    \
+	if (lids_load && lids_local_load) {					    \
+		static unsigned long warning_time = 0, no_flood_yet = 0;	    \
+		static spinlock_t lids_security_alert_lock = SPIN_LOCK_UNLOCKED;    \
+										    \
+		spin_lock(&lids_security_alert_lock);				    \
+										    \
+/* Make sure at least CONFIG_LIDS_TIMEOUT_AFTER_FLOOD				    \
+ * passed since the last warning logged						    \
+ */ 										    \
+		if ((!warning_time) || 						    \
+		    (jiffies-warning_time > CONFIG_LIDS_TIMEOUT_AFTER_FLOOD*HZ)) {  \
+			warning_time = jiffies; no_flood_yet = 1;		    \
+			lids_log(0, message , ## args);				    \
+		} else if (no_flood_yet) {					    \
+			warning_time = jiffies; no_flood_yet = 0;		    \
+			lids_log(1, message , ## args);				    \
+		}								    \
+		spin_unlock(&lids_security_alert_lock);				    \
+		lids_hangup_console();						    \
+	}									    \
+} while(0)
+
+#else				/* CONFIG_LIDS_NO_FLOOD_LOG */
+
+#define lids_security_alert(message, args...)                                      \
+do {                                                                       	   \
+	if (lids_load && lids_local_load) {					   \
+		static spinlock_t lids_security_alert_lock = SPIN_LOCK_UNLOCKED;   \
+										   \
+		spin_lock(&lids_security_alert_lock);                              \
+		lids_log(0, message , ## args);                                    \
+		spin_unlock(&lids_security_alert_lock);                            \
+		lids_hangup_console();    					   \
+	}				   					   \
+} while(0)
+
+#endif				/* CONFIG_LIDS_NO_FLOOD_LOG */
+
+#ifdef CONFIG_LIDS_ALLOW_SWITCH
+#define lids_local_load (lids_local_on || (!lids_local_off()))
+#else
+#define lids_local_load 1
+#endif				/* CONFIG_LIDS_ALLOW_SWITCH */
+
+#ifdef CONFIG_LIDS_TDE
+#define lids_tde 1
+#else
+#define lids_tde 0
+#endif
+
+#endif				/* LIDSEXT_H */
diff -durN kernel.orig/include/linux/lids.h kernel/include/linux/lids.h
--- kernel.orig/include/linux/lids.h	1970-01-01 10:00:00.000000000 +1000
+++ kernel/include/linux/lids.h	2007-03-20 14:52:59.000000000 +1000
@@ -0,0 +1,251 @@
+#ifndef LIDS_H
+#define LIDS_H
+
+/*
+ * This file include everything needed for LIDS internals.
+ * The biggest part is included from in lidsif.h
+ *
+ */
+
+#include <linux/kernel.h>
+#include <linux/sysctl.h>
+#include <linux/slab.h>
+#include <linux/tty.h>
+
+#include <linux/lidsext.h>
+#include <linux/lidsif.h>
+
+#define LIDS_VERSION	"1.2.2"
+
+/* FIXME: some more externals in kernel/signal.c and kernel/sysctl.c */
+
+extern int lids_load;		/* 1 = load ids protection , 0 = don't load */
+extern int lids_local_on;
+extern int lids_acl_discovery;
+extern unsigned long lids_current;
+extern lids_flags_t lids_flags;
+
+int _open_namei(const char *pathname, int flag, int mode, struct nameidata *nd);
+struct file *_filp_open(const char *filename, int flags, int mode);
+
+extern int lids_proc_locks_sysctl(ctl_table * table, int write,
+				  struct file *filp, void *buffer,
+				  size_t * lenp);
+extern int lids_init(void);
+extern void exit_lids(struct task_struct *tsk);
+
+extern int lids_init_task_acl(struct lids_task_acl *acl);
+extern int lids_compute_acls(struct lids_task_acl *current_acl,
+			     struct lids_sys_acl *new_sys_acl,
+			     struct lids_task_acl *computed_acl, int protect);
+extern void lids_get_task_acl(struct lids_task_acl *acl,
+			      struct task_struct *task);
+extern void lids_set_task_acl(struct lids_task_acl *acl,
+			      struct task_struct *task);
+extern int lids_task_acl_deep_copy(struct lids_task_acl *dst,
+				   struct lids_task_acl *src);
+extern void lids_free_lids_task_acl(struct lids_task_acl *acl);
+extern void lids_clear_lids_task_acl(struct lids_task_acl *acl);
+
+extern void lids_init_key(struct linux_binprm *bin, struct task_struct *task);
+extern int lids_get_key(struct task_struct *task, char *buffer);
+
+extern struct lids_sys_acl *lids_search_acl(unsigned long int ino, kdev_t dev,
+					    unsigned long lids_curr);
+extern int lids_check_base(struct dentry *base, int flag);
+extern int lids_protected(struct dentry *base, int prot);
+extern int lids_set_flags(struct lids_sys_acl *);
+extern int lids_check_hidden_inode(unsigned long int ino, kdev_t dev);
+extern int lids_bind_checker(const int);
+extern int lids_broadcast_port(const int);
+extern int lids_local_off(void);
+
+#ifdef CONFIG_LIDS_SA_THROUGH_NET
+extern int lids_klids_init(void);
+extern void lids_send_message(char *msg, int len);
+#endif
+#ifdef CONFIG_LIDS_PORT_SCAN_DETECTOR
+extern void lids_port_scanner_detector_init(void);
+extern int lids_check_scan(__u32 addr, __u16 port);
+#endif
+extern void lids_alert(int type, struct dentry *dentry, long dst, long dst2,
+		       char *name, char *action);
+extern int lids_socket_perm(struct task_struct *tsk, int type);
+extern int lids_socket_create(int family, int type, int protocol);
+extern void lids_socket_post_create(struct socket *sock, int family, int type,
+				    int protocol);
+extern int lids_socket_bind(struct socket *sock, struct sockaddr *address,
+			    int addrlen);
+extern int lids_socket_connect(struct socket *sock, struct sockaddr *address,
+			       int addrlen);
+extern int lids_socket_listen(struct socket *sock, int backlog);
+extern int lids_socket_accept(struct socket *sock, struct socket *newsock);
+extern void lids_socket_post_accept(struct socket *sock,
+				    struct socket *newsock);
+extern int lids_socket_sendmsg(struct socket *sock);
+extern int lids_socket_recvmsg(struct socket *sock);
+extern int lids_socket_getsockname(struct socket *sock);
+extern int lids_socket_getpeername(struct socket *sock);
+extern int lids_socket_setsockopt(struct socket *sock, int level, int optname);
+extern int lids_socket_getsockopt(struct socket *sock, int level, int optname);
+extern int lids_socket_shutdown(struct socket *sock, int how);
+
+extern char *lids_find_fullpathname(struct dentry *dentry, char *path,
+				    int buflen);
+
+#ifdef CONFIG_LIDS_TPE
+extern int lids_exec_tpe_permission(struct linux_binprm *bprm);
+extern int lids_mmap_tpe_permission(struct file *file, unsigned long prot, unsigned long flags);
+extern int lids_module_tpe_permission(struct module *mod);
+extern int lids_tpe;
+#endif
+
+#ifdef CONFIG_LIDS_TDE
+extern void lids_tde_policy(struct dentry *dentry, struct task_struct *task);
+#define LIDS_DEV_TTY_PATH	"/dev/tty"
+extern struct allowed_ino lidsdevtty;
+extern int lids_dev_tty(struct dentry *dentry);
+extern int lids_read_dev_tty(void);
+#define lids_sandboxed(task)			\
+	(task && task->lids_sys_acl && task->lids_sys_acl->sandbox)
+#define CAP_LIDS_SANDBOX_SAFE_SET	to_cap_t(~0 &			\
+					~CAP_TO_MASK(CAP_SETPCAP) &	\
+					~CAP_TO_MASK(CAP_SYS_RAWIO) &	\
+					~CAP_TO_MASK(CAP_SYS_MODULE) &	\
+					~CAP_TO_MASK(CAP_MKNOD) &	\
+					~CAP_TO_MASK(CAP_SYS_PTRACE) &	\
+					~CAP_TO_MASK(CAP_HIDDEN) &	\
+					~CAP_TO_MASK(CAP_PROTECTED))
+#ifdef CONFIG_CAP_LIDS_SANDBOX_EFF_SET
+#define CAP_LIDS_SANDBOX_EFF_SET	CAP_LIDS_SANDBOX_SAFE_SET
+#else
+#define CAP_LIDS_SANDBOX_EFF_SET	0
+#endif	/* CONFIG_CAP_LIDS_SANDBOX_EFF_SET */
+#else
+#define lids_dev_tty(dentry)	0
+#define lids_read_dev_tty(void)	do {} while (0)
+#define lids_sandboxed(task)	0
+#define CAP_LIDS_SANDBOX_EFF_SET	0
+#endif  /* CONFIG_LIDS_TDE */
+
+#ifdef CONFIG_LIDS_RESTRICT_MODE_SWITCH
+static __inline__ int
+lids_check_tty(int write)
+{
+	if (current->tty && !(0
+#ifdef CONFIG_LIDS_MODE_SWITCH_CONSOLE
+	    || current->tty->driver.type == TTY_DRIVER_TYPE_CONSOLE
+#endif
+#ifdef CONFIG_LIDS_MODE_SWITCH_SERIAL
+	    || current->tty->driver.type == TTY_DRIVER_TYPE_SERIAL
+#endif
+#ifdef CONFIG_LIDS_MODE_SWITCH_PTY
+	    || current->tty->driver.type == TTY_DRIVER_TYPE_PTY
+#endif
+	    )) {
+		lids_security_alert("Attempt to %s locks sysctl "
+				    "(unauthorized terminal)",
+                                    write ? "write" : "read");
+		return -EPERM;
+	}
+	return 0;
+}
+#else
+static __inline__ int
+lids_check_tty(int write)
+{
+	return 0;
+}
+#endif	/* CONFIG_LIDS_RESTRICT_MODE_SWITCH */
+
+#ifndef CONFIG_LIDS_ALLOW_ANY_PROG_SWITCH
+static __inline__ int
+lids_check_lidsadm(struct allowed_ino lidsadm, int write)
+{
+	struct vm_area_struct *vma;
+	unsigned long ino;
+	dev_t dev;
+
+	ino = -1;
+	dev = -1;
+	if (current->mm) {
+		down_read(&current->mm->mmap_sem);
+		vma = current->mm->mmap;
+		while (vma) {
+			if ((vma->vm_flags & VM_EXECUTABLE) &&
+			    vma->vm_file && vma->vm_file->f_dentry &&
+			    vma->vm_file->f_dentry->d_inode) {
+				ino = vma->vm_file->f_dentry->d_inode->i_ino;
+				dev = vma->vm_file->f_dentry->d_inode->i_dev;
+				break;
+			}
+			vma = vma->vm_next;
+		}
+		up_read(&current->mm->mmap_sem);
+	}
+	if ((ino != lidsadm.ino) || (dev != lidsadm.dev)) {
+		lids_security_alert("Attempt to %s locks sysctl "
+				    "(unauthorised program)",
+				    write ? "write" : "read");
+		return -EPERM;
+	}
+	return 0;
+}
+#else
+static __inline__ int
+lids_check_lidsadm(struct allowed_ino lidsadm, int write)
+{
+	return 0;
+}
+#endif	/* not CONFIG_LIDS_ALLOW_ANY_PROG_SWITCH */
+
+#ifdef CONFIG_LIDS_ALLOW_SWITCH
+#define lids_set_locks_passwd(void)					\
+	do {								\
+		byte hashcode[RMDsize / 8];				\
+		int i;							\
+									\
+		if (!lids_first_time || locks.passwd[0]) {		\
+			RMD((byte *) locks.passwd, hashcode);		\
+			memset((char *) locks.passwd, '\0',		\
+			       sizeof(passwd_t));			\
+			for (i = 0; i < RMDsize / 8; i++)		\
+				sprintf(rmd160sig + 2 * i, "%02x",	\
+					hashcode[i]);			\
+		}							\
+	} while (0)
+#define lids_allow_switch(void)				\
+	((lids_first_time && !locks.passwd[0]) ||	\
+	 !strncmp(rmd160sig, lids_pw, LIDS_PW_LEN))
+#define lids_not_allow_switch(void)					  \
+	do {								  \
+		number_failed++;					  \
+		lids_security_alert("Give incorrect password (try #%d) "  \
+				    "with caps=0x%x and flags=0x%x",	  \
+				    number_failed, cap_t(locks.cap_bset), \
+				    locks.flags);			  \
+		if (number_failed >= CONFIG_LIDS_MAX_TRY) {		  \
+			wait_after_fail = 1;				  \
+			init_timer(&fail_timer);			  \
+			fail_timer.function = reenable_sysctl;		  \
+			fail_timer.data = (unsigned long) NULL;		  \
+			fail_timer.expires = jiffies +			  \
+					     CONFIG_LIDS_TTW_FAIL * HZ;	  \
+			add_timer(&fail_timer);				  \
+		}							  \
+	} while (0)
+#else
+#define lids_set_locks_passwd(void)	do {} while (0)
+#define lids_allow_switch(void)				\
+	(lids_first_time && !locks.passwd[0])
+#define lids_not_allow_switch(void)					    \
+	do {								    \
+		lids_security_alert("Attempt %d to switch caps/flags with " \
+				    "caps=0x%x and flags=0x%x "		    \
+				    "(feature disabled)",		    \
+				    number_failed, cap_t(locks.cap_bset),   \
+				    locks.flags);			    \
+	} while (0)
+#endif	/* CONFIG_LIDS_ALLOW_SWITCH */
+
+#endif				/* LIDS_H */
diff -durN kernel.orig/include/linux/lidsif.h kernel/include/linux/lidsif.h
--- kernel.orig/include/linux/lidsif.h	1970-01-01 10:00:00.000000000 +1000
+++ kernel/include/linux/lidsif.h	2007-03-20 14:52:59.000000000 +1000
@@ -0,0 +1,176 @@
+#ifndef LIDSIF_H
+#define LIDSIF_H
+
+/*
+ * This file contains every definitions needed for interfacing
+ * kernel part and user space part of LIDS
+ *
+ */
+
+/*
+ * If the file is not compiled for the kernel,
+ * it must include  replacement file which contains
+ * a copy of every internal structure needed
+ *
+ */
+
+#ifdef __KERNEL__
+#include <linux/kdev_t.h>
+#include <linux/capability.h>
+#else
+#include <kernel_inc.h>
+#endif
+
+/*
+ * Here begin the common structures, shared by LIDS and
+ * lidstools
+ *
+ */
+
+#define LIDS_FLAGS_LIDS_ON		0
+#define LIDS_FLAGS_RELOAD_CONF		1
+#define LIDS_FLAGS_LIDS_LOCAL_ON	2
+#define LIDS_FLAGS_STATUS		3
+#define LIDS_FLAGS_INIT			4
+#define LIDS_FLAGS_POSTBOOT		5
+#define LIDS_FLAGS_SHUTDOWN		6
+#define LIDS_FLAGS_ACL_DISCOVERY_ON	7
+#define LIDS_FLAGS_TPE_ON		8
+
+/*
+ *      ACL target.
+ */
+
+#define LIDS_DENY       0	/* DENY ACCESS */
+#define LIDS_READONLY   1	/* Read Only File */
+#define LIDS_APPEND     2	/* APPEND ONLY FILE */
+#define LIDS_WRITE      4	/* Protect Writing to device */
+#define LIDS_IGNORE     8	/* Ignore the protection */
+#define LIDS_CAP        16	/* acl type is capability */
+#define LIDS_SOCKET     32	/* acl type is socket */
+
+/*  SOCKET CAP */
+
+#define LIDS_SOCKET_CREATE	0
+#define LIDS_SOCKET_CONNECT	1
+#define LIDS_SOCKET_BIND	2
+#define LIDS_SOCKET_LISTEN	3
+#define LIDS_SOCKET_ACCEPT	4
+#define LIDS_SOCKET_SENDMSG	5
+#define LIDS_SOCKET_RECVMSG	6
+#define LIDS_SOCKET_GETSOCKNAME	7
+#define LIDS_SOCKET_GETPEERNAME	8
+#define LIDS_SOCKET_GETSOCKOPT	9
+#define LIDS_SOCKET_SETSOCKOPT	10
+#define LIDS_SOCKET_SHUTDOWN	11
+#define LIDS_SOCKET_CREATE_TCP	12
+#define LIDS_SOCKET_CREATE_UDP	13
+#define LIDS_SOCKET_NF_MARK	14
+#define LIDS_EXEC		15
+#define LIDS_SANDBOX		16
+
+/* LIDS STATE */
+#define LIDS_STATE_GLOBAL	0
+#define LIDS_STATE_BOOT		1
+#define LIDS_STATE_POSTBOOT	2
+#define LIDS_STATE_SHUTDOWN	3
+
+/*
+ * Me ? Paranoiac !?
+ *
+ * The magic numbers are all around the encrypted password.
+ * They have a null byte to bother ASCIIZ functions.
+ */
+
+#define LIDS_MAGIC_1 0x004e6741
+#define LIDS_MAGIC_2 0x68002d62
+#define LIDS_MAGIC_3 0xe68400c3
+#define LIDS_MAGIC_4 0xd94aa400
+
+#define LIDS_FLAG_FULL_SET            (~0)
+#define LIDS_FLAG_TO_MASK(flag)       (1 << (flag))
+#define lids_flag_raise(flag, bit)    ((flag) |= LIDS_FLAG_TO_MASK(bit))
+#define lids_flag_lower(flag, bit)    ((flag) &= ~LIDS_FLAG_TO_MASK(bit))
+#define lids_flag_raised(flag, bit)   ((flag) & LIDS_FLAG_TO_MASK(bit) & LIDS_FLAG_FULL_SET)
+
+#define LIDS_TIME_ITEM  2
+#define LIDS_PORT_ITEM  16
+
+typedef __u32 lids_flags_t;
+
+typedef char passwd_t[64];
+
+typedef struct lids_locks_s {
+	int magic1;
+	kernel_cap_t cap_bset;
+	int magic2;
+	lids_flags_t flags;
+	int magic3;
+	passwd_t passwd;
+	int magic4;
+} lids_locks_t;
+
+struct secure_ino {
+	unsigned long int ino;	/* the inode number */
+	kdev_t dev;		/* the dev number */
+	int type;		/* the file type */
+	time_t from_time;
+	time_t to_time;
+};
+
+struct allowed_ino {
+	unsigned long int ino;
+	kdev_t dev;
+};
+
+/* use in task struct to represent the acl */
+struct lids_acl {
+	struct lids_acl *next;
+	unsigned long int ino;
+	kdev_t dev;
+	int type;			/* READ WRITE APPEND DENY  */
+	int inherit;			/* inheritance level */
+	time_t time[LIDS_TIME_ITEM][2];	/* time restriction */
+};
+
+struct lids_cap {
+	int inherit;			/* capability inheritance level */
+	time_t time[LIDS_TIME_ITEM][2];	/* time restriction */
+};
+
+/* save all the system defined acl here */
+struct lids_sys_acl {
+	unsigned long int ino;		/* the subject node number */
+	unsigned long flags;		/* capability flags */
+	struct lids_cap cap[32];	/* inheritable array */
+	int socket;			/* socket */
+	int mark;
+#ifdef CONFIG_LIDS_TDE
+	int sandbox;			/* sandbox flag */
+#endif
+	int port[LIDS_PORT_ITEM][2];	/* ports for CAP_NET_BIND_SERVICE */
+	int cport[LIDS_PORT_ITEM][2];	/* ports for CAP_NET_BROADCAST */
+	struct lids_acl *lids_acl;	/* object acl */
+	kdev_t dev;			/* the subject dev number */
+};
+
+struct lids_task_acl {
+	/* LIDS refrence box */
+	struct lids_sys_acl *lids_sys_acl;
+	unsigned long lids_cap;
+};
+
+#define LIDS_KEY_SIZE 16
+
+struct usr_key_entry {
+	char key[LIDS_KEY_SIZE];
+#ifdef __KERNEL__
+        __u32 ino;
+        __u64 dev;
+#else
+	ino_t ino;
+	dev_t dev;
+#endif
+};
+
+#endif				/* LIDSIF_H */
diff -durN kernel.orig/include/linux/rmd160.h kernel/include/linux/rmd160.h
--- kernel.orig/include/linux/rmd160.h	1970-01-01 10:00:00.000000000 +1000
+++ kernel/include/linux/rmd160.h	2007-03-20 14:52:59.000000000 +1000
@@ -0,0 +1,138 @@
+/********************************************************************\
+ *
+ *      FILE:     rmd160.h
+ *
+ *      CONTENTS: Header file for a sample C-implementation of the
+ *                RIPEMD-160 hash-function.
+ *      TARGET:   any computer with an ANSI C compiler
+ *
+ *      AUTHOR:   Antoon Bosselaers, ESAT-COSIC
+ *      DATE:     1 March 1996
+ *      VERSION:  1.0
+ *
+ *      Copyright (c) Katholieke Universiteit Leuven
+ *      1996, All Rights Reserved
+ *
+\********************************************************************/
+
+#ifndef  RMD160H           /* make sure this file is read only once */
+#define  RMD160H
+
+#define RMDsize 160
+
+/********************************************************************/
+
+/* typedef 8 and 32 bit types, resp.  */
+/* adapt these, if necessary,
+   for your operating system and compiler */
+typedef    u8        byte;
+typedef    u32        dword;
+
+
+/********************************************************************/
+
+/* macro definitions */
+
+/* collect four bytes into one word: */
+#define BYTES_TO_DWORD(strptr)                    \
+            (((dword) *((strptr)+3) << 24) | \
+             ((dword) *((strptr)+2) << 16) | \
+             ((dword) *((strptr)+1) <<  8) | \
+             ((dword) *(strptr)))
+
+/* ROL(x, n) cyclically rotates x over n bits to the left */
+/* x must be of an unsigned 32 bits type and 0 <= n < 32. */
+#define ROL(x, n)        (((x) << (n)) | ((x) >> (32-(n))))
+
+/* the five basic functions F(), G() and H() */
+#define F(x, y, z)        ((x) ^ (y) ^ (z))
+#define G(x, y, z)        (((x) & (y)) | (~(x) & (z)))
+#define H(x, y, z)        (((x) | ~(y)) ^ (z))
+#define I(x, y, z)        (((x) & (z)) | ((y) & ~(z)))
+#define J(x, y, z)        ((x) ^ ((y) | ~(z)))
+
+/* the ten basic operations FF() through III() */
+#define FF(a, b, c, d, e, x, s)        {\
+      (a) += F((b), (c), (d)) + (x);\
+      (a) = ROL((a), (s)) + (e);\
+      (c) = ROL((c), 10);\
+   }
+#define GG(a, b, c, d, e, x, s)        {\
+      (a) += G((b), (c), (d)) + (x) + 0x5a827999UL;\
+      (a) = ROL((a), (s)) + (e);\
+      (c) = ROL((c), 10);\
+   }
+#define HH(a, b, c, d, e, x, s)        {\
+      (a) += H((b), (c), (d)) + (x) + 0x6ed9eba1UL;\
+      (a) = ROL((a), (s)) + (e);\
+      (c) = ROL((c), 10);\
+   }
+#define II(a, b, c, d, e, x, s)        {\
+      (a) += I((b), (c), (d)) + (x) + 0x8f1bbcdcUL;\
+      (a) = ROL((a), (s)) + (e);\
+      (c) = ROL((c), 10);\
+   }
+#define JJ(a, b, c, d, e, x, s)        {\
+      (a) += J((b), (c), (d)) + (x) + 0xa953fd4eUL;\
+      (a) = ROL((a), (s)) + (e);\
+      (c) = ROL((c), 10);\
+   }
+#define FFF(a, b, c, d, e, x, s)        {\
+      (a) += F((b), (c), (d)) + (x);\
+      (a) = ROL((a), (s)) + (e);\
+      (c) = ROL((c), 10);\
+   }
+#define GGG(a, b, c, d, e, x, s)        {\
+      (a) += G((b), (c), (d)) + (x) + 0x7a6d76e9UL;\
+      (a) = ROL((a), (s)) + (e);\
+      (c) = ROL((c), 10);\
+   }
+#define HHH(a, b, c, d, e, x, s)        {\
+      (a) += H((b), (c), (d)) + (x) + 0x6d703ef3UL;\
+      (a) = ROL((a), (s)) + (e);\
+      (c) = ROL((c), 10);\
+   }
+#define III(a, b, c, d, e, x, s)        {\
+      (a) += I((b), (c), (d)) + (x) + 0x5c4dd124UL;\
+      (a) = ROL((a), (s)) + (e);\
+      (c) = ROL((c), 10);\
+   }
+#define JJJ(a, b, c, d, e, x, s)        {\
+      (a) += J((b), (c), (d)) + (x) + 0x50a28be6UL;\
+      (a) = ROL((a), (s)) + (e);\
+      (c) = ROL((c), 10);\
+   }
+
+/********************************************************************/
+
+/* function prototypes */
+
+void MDinit(dword *MDbuf);
+/*
+ *  initializes MDbuffer to "magic constants"
+ */
+
+void compress(dword *MDbuf, dword *X);
+/*
+ *  the compression function.
+ *  transforms MDbuf using message bytes X[0] through X[15]
+ */
+
+void MDfinish(dword *MDbuf, byte *strptr, dword lswlen, dword mswlen);
+/*
+ *  puts bytes from strptr into X and pad out; appends length
+ *  and finally, compresses the last block(s)
+ *  note: length in bits == 8 * (lswlen + 2^32 mswlen).
+ *  note: there are (lswlen mod 64) bytes left in strptr.
+ */
+
+void RMD(byte *message,byte *hashcode);
+/*
+ * Return hash in hascode variable.
+ * Need RMDSize/8 bytes.
+ */
+
+#endif  /* RMD160H */
+
+/*********************** end of file rmd160.h ***********************/
+
diff -durN kernel.orig/include/linux/sched.h kernel/include/linux/sched.h
--- kernel.orig/include/linux/sched.h	2007-03-20 14:09:02.000000000 +1000
+++ kernel/include/linux/sched.h	2007-03-20 14:52:59.000000000 +1000
@@ -26,6 +26,9 @@
 #include <linux/signal.h>
 #include <linux/securebits.h>
 #include <linux/fs_struct.h>
+#ifdef CONFIG_LIDS
+#include <linux/lidsext.h>
+#endif
 
 struct exec_domain;
 
@@ -410,6 +413,13 @@
 
 /* journalling filesystem info */
 	void *journal_info;
+
+#ifdef CONFIG_LIDS
+	/* LIDS refrence box */
+	struct lids_sys_acl *lids_sys_acl;
+	unsigned long lids_cap;
+#endif
+
 };
 
 /*
@@ -737,23 +747,72 @@
 	return 0;
 }
 
+#ifdef CONFIG_LIDS
+/* capable2() is called to know wether or not a process has some privilege,
+ * but the result won't be used to decide if an access is granted or not,
+ * thus, not having the privilege is not a violation (==> nothing logged)
+ * and the process is not flagged with PF_SUPERPRIV
+ */
+static inline int capable2(int cap)
+{
+        LIDS_DBG("CCC +-< cap_needed=%x cap_eff=%x cap_bset=%x uid=%i euid=%i "
+		 "fsuid=%i lids_cap=%li timeok=%i lidsload=%i lidslocload=%i "
+		 "lids_cap_val=%x cap_combine=%x capok?=%i capraised?=%i "
+		 "lidscapok?=%i lidsoff?=%i lids_first?=%i\n",
+		 cap, current->cap_effective, cap_bset,current->uid,
+		 current->euid, current->fsuid, current->lids_cap,
+		 !lids_cap_time_checker(cap), lids_load, lids_local_load,
+		 lids_cap_val, cap_combine(current->lids_cap, lids_cap_val),
+		 cap_raised(current->cap_effective, cap),
+		 cap_raised(cap_combine(current->lids_cap, lids_cap_val), cap),
+		 (cap_raised(cap_combine(current->lids_cap, lids_cap_val), cap)
+		 && !lids_cap_time_checker(cap)),
+		 !(lids_load && lids_local_load), lids_first_time);
+
+	if (cap_raised(current->cap_effective, cap) && lids_cap_raised(cap, 0))
+		return 1;
+	return 0;
+}
+#endif
+
+
 /*
  * capable() checks for a particular capability.  
  * New privilege checks should use this interface, rather than suser() or
  * fsuser(). See include/linux/capability.h for defined capabilities.
  */
-
 static inline int capable(int cap)
 {
+#ifdef CONFIG_LIDS
+        LIDS_DBG("CCC +-< cap_needed=%x cap_eff=%x cap_bset=%x uid=%i euid=%i "
+		 "fsuid=%i lids_cap=%li timeok=%i lidsload=%i lidslocload=%i "
+		 "lids_cap_val=%x cap_combine=%x capok?=%i capraised?=%i "
+		 "lidscapok?=%i lidsoff?=%i lids_first?=%i\n",
+		 cap, current->cap_effective, cap_bset,current->uid,
+		 current->euid, current->fsuid, current->lids_cap,
+		 !lids_cap_time_checker(cap), lids_load, lids_local_load,
+		 lids_cap_val, cap_combine(current->lids_cap, lids_cap_val),
+		 cap_raised(current->cap_effective, cap),
+		 cap_raised(cap_combine(current->lids_cap, lids_cap_val), cap),
+		 (cap_raised(cap_combine(current->lids_cap, lids_cap_val), cap)
+		 && !lids_cap_time_checker(cap)),
+		 !(lids_load && lids_local_load), lids_first_time);
+
+	if (cap_raised(current->cap_effective, cap) && lids_cap_raised(cap, 1))
+#else  /* CONFIG_LIDS */
 #if 1 /* ok now */
 	if (cap_raised(current->cap_effective, cap))
 #else
 	if (cap_is_fs_cap(cap) ? current->fsuid == 0 : current->euid == 0)
 #endif
+#endif /* CONFIG_LIDS */
 	{
 		current->flags |= PF_SUPERPRIV;
 		return 1;
 	}
+#ifdef CONFIG_LIDS
+	lids_cap_log(cap);
+#endif /* CONFIG_LIDS */
 	return 0;
 }
 
diff -durN kernel.orig/include/linux/sysctl.h kernel/include/linux/sysctl.h
--- kernel.orig/include/linux/sysctl.h	2007-03-20 14:09:03.000000000 +1000
+++ kernel/include/linux/sysctl.h	2007-03-20 14:52:59.000000000 +1000
@@ -64,7 +64,10 @@
 	CTL_BUS=8,		/* Busses */
 	CTL_ABI=9,		/* Binary emulation */
 	CTL_CPU=10,		/* CPU stuff (speed scaling, etc) */
-	CTL_CPU_VOLTAGE=11  /*  CPU voltage staff   */
+	CTL_CPU_VOLTAGE=11,	/*  CPU voltage staff   */
+#ifdef CONFIG_LIDS
+ 	CTL_LIDS=12		/* LIDS */
+#endif
 };
 
 /* CTL_BUS names: */
@@ -579,6 +582,13 @@
 	DEV_MAC_HID=5
 };
 
+#ifdef CONFIG_LIDS
+/* CTL_LIDS names: */
+enum {
+	LIDS_LOCKS=1,
+};
+#endif
+
 /* /proc/sys/dev/cdrom */
 enum {
 	DEV_CDROM_INFO=1,
diff -durN kernel.orig/include/linux/tty.h kernel/include/linux/tty.h
--- kernel.orig/include/linux/tty.h	2007-03-20 14:09:03.000000000 +1000
+++ kernel/include/linux/tty.h	2007-03-20 14:52:59.000000000 +1000
@@ -343,6 +343,9 @@
 #define TTY_HW_COOK_IN 15
 #define TTY_PTY_LOCK 16
 #define TTY_NO_WRITE_SPLIT 17
+#ifdef CONFIG_LIDS
+#define TTY_LIDS_NO_HANGUP 18
+#endif
 
 #define TTY_WRITE_FLUSH(tty) tty_write_flush((tty))
 
diff -durN kernel.orig/init/main.c kernel/init/main.c
--- kernel.orig/init/main.c	2007-03-20 14:09:05.000000000 +1000
+++ kernel/init/main.c	2007-03-20 14:52:59.000000000 +1000
@@ -36,6 +36,10 @@
 #include <asm/ccwcache.h>
 #endif
 
+#ifdef CONFIG_LIDS
+#include <linux/lids.h>
+#endif
+
 #ifdef CONFIG_PCI
 #include <linux/pci.h>
 #endif
@@ -56,6 +60,10 @@
 #include <linux/nubus.h>
 #endif
 
+#ifdef CONFIG_LIDS
+static int __init lids_setup(char *str);
+#endif
+
 #ifdef CONFIG_ISAPNP
 #include <linux/isapnp.h>
 #endif
@@ -123,6 +131,11 @@
 
 char *execute_command;
 
+#ifdef CONFIG_LIDS
+int _lids_load = 1;
+#endif
+
+
 static char * argv_init[MAX_INIT_ARGS+2] = { "init", NULL, };
 char * envp_init[MAX_INIT_ENVS+2] = { "HOME=/", "TERM=linux", NULL, };
 
@@ -151,6 +164,23 @@
 	return 0;
 }
 
+#ifdef CONFIG_LIDS
+
+/*
+ *     lids_setup , read lids info from the kernel.
+ */
+static int __init lids_setup(char *str)
+{
+	if(strncmp(str,"0",1) == 0)
+		_lids_load = 0;
+	return 0;
+}
+
+__setup("lids=",lids_setup);
+#endif
+
+
+
 /* this should be approx 2 Bo*oMips to start (note initial shift), and will
    still work even if initially too large, it will just take slightly longer */
 unsigned long loops_per_jiffy = (1<<12);
@@ -559,6 +589,35 @@
 #endif
 }
 
+#ifdef CONFIG_LIDS
+void do_lids_setup(void)
+{
+        /* init the ids file system */
+        lids_load = _lids_load;
+        lids_local_on = 1;
+	lids_flags = 0;
+	lids_state = LIDS_STATE_BOOT;
+        lids_flag_raise(lids_flags, LIDS_FLAGS_LIDS_LOCAL_ON);
+	lids_flag_raise(lids_flags, LIDS_FLAGS_INIT);
+
+	if (lids_load)
+		lids_flag_raise(lids_flags, LIDS_FLAGS_LIDS_ON);
+
+        printk("Linux Intrusion Detection System %s %s \n",
+	       LIDS_VERSION,
+	       lids_load == 1 ? "started" : "*not* started");
+	if (lids_load) {
+#ifdef CONFIG_LIDS_SA_THROUGH_NET
+        	lids_klids_init();
+#endif
+#ifdef CONFIG_LIDS_PORT_SCAN_DETECTOR
+		lids_port_scanner_detector_init();
+#endif
+		lids_init();
+	}
+}
+#endif
+
 extern void prepare_namespace(void);
 
 static int init(void * unused)
@@ -568,6 +627,10 @@
 
 	prepare_namespace();
 
+#ifdef CONFIG_LIDS
+	do_lids_setup();
+#endif
+
 	/*
 	 * Ok, we have completed the initial bootup, and
 	 * we're essentially up and running. Get rid of the
diff -durN kernel.orig/kernel/Config.in kernel/kernel/Config.in
--- kernel.orig/kernel/Config.in	1970-01-01 10:00:00.000000000 +1000
+++ kernel/kernel/Config.in	2007-03-20 14:52:59.000000000 +1000
@@ -0,0 +1,66 @@
+#
+#	Config.in for LIDS
+#
+
+if [ "$CONFIG_SYSCTL" = "y" ]; then
+  mainmenu_option next_comment
+  comment 'Linux Intrusion Detection System'
+  bool  'Linux Intrusion Detection System support  (EXPERIMENTAL)' CONFIG_LIDS
+  if [ "$CONFIG_LIDS" != "n" ]; then
+
+     comment 'LIDS features'
+     int '  Maximum protected objects to manage' CONFIG_LIDS_MAX_INODE 256
+     int '  Maximum ACL subjects to manage' CONFIG_LIDS_MAX_SACL 256
+     int '  Maximum ACL objects to manage' CONFIG_LIDS_MAX_OACL 256
+     bool '  Hang up console when raising a security alert' CONFIG_LIDS_HANGUP
+     bool '  Security alert when execing unprotected programs before sealing LIDS' CONFIG_LIDS_SA_EXEC_UP
+     if [ "$CONFIG_LIDS_SA_EXEC_UP" = "y" ]; then
+         bool '    Do not execute unprotected programs before sealing LIDS' CONFIG_LIDS_NO_EXEC_UP
+     fi
+     bool '  Attempt not to flood logs' CONFIG_LIDS_NO_FLOOD_LOG
+     if [ "$CONFIG_LIDS_NO_FLOOD_LOG" = "y" ]; then
+        int '    Authorised time between two identic logs (seconds)' CONFIG_LIDS_TIMEOUT_AFTER_FLOOD 60
+     fi
+     bool '  Allow switching LIDS protections/features' CONFIG_LIDS_ALLOW_SWITCH
+     if [ "$CONFIG_LIDS_ALLOW_SWITCH" = "y" ]; then
+	bool '    Allow switching LIDS/LIDS_GLOBAL' CONFIG_LIDS_ALLOW_LFS
+	bool '    Implicitly protect LIDS admin passwd' CONFIG_LIDS_PROTECT_PWD
+	bool '    Restrict mode switching to specified terminals' CONFIG_LIDS_RESTRICT_MODE_SWITCH
+	if [ "$CONFIG_LIDS_RESTRICT_MODE_SWITCH" = "y" ]; then
+	   bool '      Allow mode switching from a Linux Console' CONFIG_LIDS_MODE_SWITCH_CONSOLE
+	   bool '      Allow mode switching from a serial Console' CONFIG_LIDS_MODE_SWITCH_SERIAL
+	   bool '      Allow mode switching from a PTY' CONFIG_LIDS_MODE_SWITCH_PTY
+	fi
+        int '    Number of attempts to submit password' CONFIG_LIDS_MAX_TRY 3
+        int '    Time to wait after a fail (seconds)' CONFIG_LIDS_TTW_FAIL 3
+        bool '    Allow any program to switch LIDS protections' CONFIG_LIDS_ALLOW_ANY_PROG_SWITCH
+        bool '    Allow reloading config. file' CONFIG_LIDS_RELOAD_CONF
+     fi
+     bool '  Port Scanner Detector in kernel' CONFIG_LIDS_PORT_SCAN_DETECTOR
+
+     bool '  Send security alerts through network' CONFIG_LIDS_SA_THROUGH_NET
+     if [ "$CONFIG_LIDS_SA_THROUGH_NET" = "y" ]; then
+        bool '     Hide klids kernel thread' CONFIG_LIDS_HIDE_KLIDS
+        int '     Number of connection tries before giving up' CONFIG_LIDS_NET_MAX_TRIES 3
+        int '    Sleep time after a failed connection' CONFIG_LIDS_NET_TIMEOUT 30
+        int '    Message queue size' CONFIG_LIDS_MSGQUEUE_SIZE 16
+     fi
+     bool '  Enable security network' CONFIG_LIDS_NETWORK
+     if [ "$CONFIG_LIDS_NETWORK" = "y" ]; then
+	if [ "$CONFIG_IP_NF_TARGET_MARK" != "n" ]; then
+		bool '      Enable NETFILTER MARK' CONFIG_LIDS_NF_MARK
+	fi
+     fi
+     bool '  Enable Trusted Path Execution (TPE) mode feature' CONFIG_LIDS_TPE
+     bool '  Enable Trusted Domain Enforcement (TDE) feature' CONFIG_LIDS_TDE
+     if [ "$CONFIG_LIDS_TDE" = "y" ]; then
+	bool '    Only enable TDE Sandbox feature' CONFIG_LIDS_TDE_SANDBOX_ONLY
+     fi
+     if [ "$CONFIG_LIDS_TDE" = "y" ]; then
+	bool '    Enable CAP_LIDS_SANDBOX_EFF_SET' CONFIG_CAP_LIDS_SANDBOX_EFF_SET
+     fi
+
+  bool '   LIDS Debug ' CONFIG_LIDS_DEBUG
+  fi
+  endmenu
+fi
diff -durN kernel.orig/kernel/exit.c kernel/kernel/exit.c
--- kernel.orig/kernel/exit.c	2007-03-20 14:09:05.000000000 +1000
+++ kernel/kernel/exit.c	2007-03-20 14:52:59.000000000 +1000
@@ -21,6 +21,9 @@
 #include <asm/pgtable.h>
 #include <asm/mmu_context.h>
 
+#ifdef CONFIG_LIDS
+#include <linux/lids.h>
+#endif
 extern void sem_exit (void);
 extern struct task_struct *child_reaper;
 
@@ -446,6 +449,18 @@
 		panic("Attempted to kill the idle task!");
 	if (tsk->pid == 1)
 		panic("Attempted to kill init!");
+
+#ifdef CONFIG_LIDS
+        if ((!lids_local_on) &&
+	    (lids_local_pid == tsk->pid)) {
+                lids_local_on = 1;
+                lids_flag_raise(lids_flags, LIDS_FLAGS_LIDS_LOCAL_ON);
+                lids_security_alert("LIDS locally switched on after "
+				    "the termination of process %i",
+				    (int)tsk->pid);
+        }
+#endif
+
 	tsk->flags |= PF_EXITING;
 	del_timer_sync(&tsk->real_timer);
 
@@ -472,6 +487,9 @@
 
 	tsk->exit_code = code;
 	exit_notify();
+#ifdef CONFIG_LIDS
+	exit_lids(tsk);
+#endif
 	schedule();
 	BUG();
 /*
diff -durN kernel.orig/kernel/fork.c kernel/kernel/fork.c
--- kernel.orig/kernel/fork.c	2007-03-20 14:09:05.000000000 +1000
+++ kernel/kernel/fork.c	2007-03-20 14:53:00.000000000 +1000
@@ -22,6 +22,9 @@
 #include <linux/namespace.h>
 #include <linux/personality.h>
 #include <linux/compiler.h>
+#ifdef CONFIG_LIDS
+#include <linux/lids.h>
+#endif
 
 #include <asm/pgtable.h>
 #include <asm/pgalloc.h>
@@ -560,6 +563,23 @@
 	return 0;
 }
 
+#ifdef CONFIG_LIDS
+static inline int copy_lids_sys_acl(struct task_struct * tsk)
+{
+	struct lids_task_acl src,dst;
+
+	lids_get_task_acl(&src, current);
+	if (lids_task_acl_deep_copy(&dst,&src) < 0) {
+		LIDS_DBG("lids_task_acl_deep_copy error\n");
+		return -1;
+	}
+/*	dst.lids_sys_acl->forked=1;*/
+	lids_set_task_acl(&dst, tsk);
+	return 0;
+}
+#endif
+
+
 static inline void copy_flags(unsigned long clone_flags, struct task_struct *p)
 {
 	unsigned long new_flags = p->flags;
@@ -721,9 +741,18 @@
 		goto bad_fork_cleanup_sighand;
 	if (copy_namespace(clone_flags, p))
 		goto bad_fork_cleanup_mm;
+#ifdef CONFIG_LIDS
+	if (copy_lids_sys_acl(p))
+		goto bad_fork_cleanup_namespace;
+	LIDS_DBG("#### pid %i fork to pid %i\n",current->pid, p->pid);
+#endif
 	retval = copy_thread(0, clone_flags, stack_start, stack_size, p, regs);
 	if (retval)
+#ifdef CONFIG_LIDS
+		goto bad_fork_cleanup_lids;
+#else
 		goto bad_fork_cleanup_namespace;
+#endif
 	p->semundo = NULL;
 	
 	/* Our parent execution domain becomes current domain
@@ -790,6 +819,10 @@
 fork_out:
 	return retval;
 
+#ifdef CONFIG_LIDS
+bad_fork_cleanup_lids:
+	/* nothing to do */
+#endif
 bad_fork_cleanup_namespace:
 	exit_namespace(p);
 bad_fork_cleanup_mm:
diff -durN kernel.orig/kernel/klids.c kernel/kernel/klids.c
--- kernel.orig/kernel/klids.c	1970-01-01 10:00:00.000000000 +1000
+++ kernel/kernel/klids.c	2007-03-20 14:53:00.000000000 +1000
@@ -0,0 +1,395 @@
+/******************************************************
+ *
+ * This is klids, the LIDS kernel thread.
+ * It is used to send security alerts through network
+ * to remote mail servers (or other listening daemon)
+ * without the help of any user space program.
+ *
+ * Philippe BIONDI (philippe.biondi@webmotion.com)
+ * March 25, 2000
+ *
+ */
+
+#define __KERNEL_SYSCALLS__
+
+#include <linux/sched.h>
+#include <linux/unistd.h>
+#include <linux/smp_lock.h>
+#include <linux/fs.h>
+#include <asm/uaccess.h>
+#include <linux/slab.h>
+#include <linux/net.h>
+#include <linux/inet.h>
+#include <net/sock.h>
+#include <linux/poll.h>
+#include <linux/file.h>
+#include <linux/lids.h>
+
+#define POLLIN_SET (POLLRDNORM | POLLRDBAND | POLLIN | POLLHUP | POLLERR)
+#define DEFAULT_POLLMASK (POLLIN | POLLOUT | POLLRDNORM | POLLWRNORM)
+
+/* debug messages : */
+#if 0
+#define dprintk(fmt, args...) printk(KERN_DEBUG fmt , ## args)
+#else
+#define dprintk(fmt, args...)
+#endif
+
+#ifdef CONFIG_LIDS_HIDE_KLIDS
+#define eprintk(fmt, args...)
+#else
+#define eprintk(fmt, args...) printk(KERN_ERR fmt , ## args)
+#endif
+
+/*
+ * Pseudo-scripting language commands
+ *
+ * About the Pseudo-scripting language :
+ * C purists won't like it, saying that code
+ * which is not pretty is bad code. (see latter :))
+ * I'll say that is the prettiest manner,
+ * until they give me a prettier one (if they can)
+ *
+ */
+
+#define lids_send(x) lids_send_sock(sock, x, strlen(x));
+#define lids_expect(x) if (lids_expect_sock(sock,x) <= 0) {	\
+	dprintk("Didn't get %s\n", x);				\
+	goto err_expect;					\
+	}
+#define LIDS_MESSAGE lids_msgqueue[0].msg[lids_msgqueue[0].head]
+
+extern void poll_freewait(poll_table * p);
+extern int sock_map_fd(struct socket *);
+extern char lids_mail_source[64], lids_mail_from[64],
+	    lids_mail_to[64], lids_mail_subject[128],
+	    lids_rcpt_to[64];
+
+extern int lids_mail_switch;
+extern unsigned long int lids_mail_relay;
+extern unsigned int lids_mail_port;
+
+typedef struct t_lids_msgqueue {
+	char *msg[CONFIG_LIDS_MSGQUEUE_SIZE];
+	int msg_size[CONFIG_LIDS_MSGQUEUE_SIZE];
+	int head, tail, nbmsg;
+	wait_queue_head_t writeq, readq;	/* read and write queues */
+} lids_msgqueue_s;
+
+lids_msgqueue_s lids_msgqueue[1];		/* Actually, there is just one. For now.. */
+
+static struct semaphore lids_msgqueue_mutex;
+
+int
+lids_send_sock(struct socket *sock, const char *buffer, const size_t length)
+{
+	struct msghdr msg;
+	struct iovec iov;
+	int len;
+
+	if (!sock->sk)
+		return -ECONNRESET;
+
+	msg.msg_name = 0;
+	msg.msg_namelen = 0;
+	msg.msg_iov = &iov;
+	msg.msg_iovlen = 1;
+	msg.msg_control = NULL;
+	msg.msg_controllen = 0;
+	msg.msg_flags = MSG_NOSIGNAL;
+	msg.msg_iov->iov_base = (char *) buffer;
+	msg.msg_iov->iov_len = (__kernel_size_t) length;
+	len = sock_sendmsg(sock, &msg, (size_t) (length));
+	return len;
+}
+
+int
+lids_expect_sock(struct socket *sock, char *msgnum)
+{
+	struct msghdr msg;
+	struct iovec iov;
+	int len;
+	char buffer[1024];
+
+	unsigned long mask;
+	poll_table wait_table, *wait;
+	int retval;
+	long timeout = CONFIG_LIDS_NET_TIMEOUT * HZ;
+	struct file *file;
+
+	if (sock->sk == NULL)
+		return -ECONNRESET;
+
+	poll_initwait(&wait_table);
+	wait = &wait_table;
+
+	/* wait tables initialization */
+	/*
+	wait_table = (poll_table *) __get_free_page(GFP_KERNEL);
+	if (!wait_table)
+	return -ENOMEM;
+
+	wait_table->nr = 0;
+	wait_table->entry = (struct poll_table_entry *)(wait_table + 1);
+	wait_table->next = NULL;
+	wait = wait_table;
+	 */
+
+	/* polling */
+
+	lock_kernel();
+
+	retval = 0;
+	file = sock->file;
+	for (;;) {
+		current->state = TASK_INTERRUPTIBLE;
+		mask = POLLNVAL;
+		if (file) {
+			mask = DEFAULT_POLLMASK;
+			if (file->f_op && file->f_op->poll)
+				mask = file->f_op->poll(file, wait);
+		}
+		if ((mask & POLLIN_SET) || !timeout || signal_pending(current))
+			break;
+		wait = NULL;
+		timeout = schedule_timeout(timeout);
+	}
+	current->state = TASK_RUNNING;
+	poll_freewait(&wait_table);
+
+	unlock_kernel();
+
+	/* receiving */
+
+	msg.msg_name = 0;
+	msg.msg_namelen = 0;
+	msg.msg_iov = &iov;
+	msg.msg_iovlen = 1;
+	msg.msg_control = NULL;
+	msg.msg_controllen = 0;
+	msg.msg_flags = MSG_DONTWAIT;
+
+	msg.msg_iov->iov_base = buffer;
+	msg.msg_iov->iov_len = (__kernel_size_t) 1024;
+
+	len = sock_recvmsg(sock, &msg, 1024, MSG_DONTWAIT);
+	if (len > 0)
+		buffer[len - 1] = 0;
+	return ((len > 0) && (strstr(buffer, msgnum)));
+}
+
+int
+lids_klids_thread(void *m)
+{
+	struct socket *sock;
+	struct sockaddr_in loc;
+	struct sockaddr_in rem;
+	int retval, sockfd;
+	int try;
+
+	LIDS_DBG("Launching klids kernel thread %i\n", current->pid);
+
+	/*  Adjust thread parameters */
+	current->session = 1;
+	current->pgrp = 1;
+	strcpy(current->comm, "klids");
+	current->p_opptr = &init_task;
+	current->p_pptr = &init_task;
+	sigfillset(&current->blocked);
+
+#ifdef CONFIG_LIDS_HIDE_KLIDS
+	current->lids_cap = 0x0UL;
+	set_bit(CAP_HIDDEN, &current->lids_cap);
+#endif
+
+	/* Allow args to be in kernel space. */
+	set_fs(KERNEL_DS);
+
+	while (1) {
+		/* if switch is off, do not send msg, FIXME: or sleep */
+		if (!lids_mail_switch) {
+			LIDS_DBG("sleep a while before retrying\n");
+			current->state = TASK_INTERRUPTIBLE;
+			schedule_timeout(CONFIG_LIDS_NET_TIMEOUT * HZ);
+			continue;
+		}
+
+		if (lids_msgqueue[0].nbmsg == 0) {
+			LIDS_DBG("klids: go to sleep...\n");
+			interruptible_sleep_on(&(lids_msgqueue[0].readq));
+			LIDS_DBG("klids: wake up\n");
+
+		}
+
+		while (lids_msgqueue[0].nbmsg > 0) {
+			try = CONFIG_LIDS_NET_MAX_TRIES;
+			while (1) {
+				lock_kernel();
+				/* create socket */
+#ifdef CONFIG_LIDS_NET_UDP
+				retval = sock_create(PF_INET, SOCK_DGRAM,
+						     IPPROTO_UDP, &sock);
+#else
+				retval = sock_create(PF_INET, SOCK_STREAM,
+						     IPPROTO_TCP, &sock);
+#endif
+				if (retval < 0) {
+					eprintk("klids: Error %d: can't create socket\n",
+						retval);
+					goto err_crsock;
+				}
+				/* create a file descriptor for the socket */
+				sockfd = retval = sock_map_fd(sock);
+				if (retval < 0) {
+					eprintk("klids: Error %d: can't create socket fd\n",
+						retval);
+					goto err_crfd;
+				}
+				sock->file = fcheck(retval);
+
+				unlock_kernel();
+				/* bind */
+				loc.sin_family = AF_INET;
+				loc.sin_addr.s_addr = INADDR_ANY;
+				loc.sin_port = 0;	/* any port */
+
+				retval =
+				    sock->ops->bind(sock, (struct sockaddr *) &loc,
+						    sizeof (loc));
+				if (retval < 0) {
+					eprintk("klids: Error %d: can't bind socket\n",
+						retval);
+					goto err_bind;
+				}
+
+				/* connect */
+				sock->sk->reuse = 1;	/* setsockopt... */
+				sock->sk->linger = 1;
+
+				rem.sin_family = AF_INET;
+				rem.sin_addr.s_addr = lids_mail_relay;
+				rem.sin_port = htons(lids_mail_port);
+
+				retval = sock->ops->connect(sock, (struct sockaddr *) &rem,
+							    sizeof (rem), 0);
+
+				if (retval < 0) {
+					eprintk("klids: Error %d: can't connect to "
+						"%u.%u.%u.%u:%u\n",
+						-retval, NIPQUAD(lids_mail_relay),
+						lids_mail_port);
+					goto err_conn;
+				}
+
+				/* scripting ... */
+
+				/*
+				 * Well, that seem strange, at first sight.
+				 * Let's say that it is a special language that
+				 * need to be preprocessed before having gcc fed with.
+				 * It just happens that the preprocessor is also the C
+				 * preprocessor.
+				 */
+
+				#include "lids_mail_script.c"
+
+				try = 1;	/* as if it was the last try */
+				dprintk("Message sent successfully\n");
+
+				goto all_ok;
+
+			err_expect:
+				eprintk("Timeout/Protocol error\n");
+
+			all_ok:
+			err_conn:
+			err_bind:
+				sys_close(sockfd);
+				/*
+				 * release has just been done by sys_close()
+				 * so we must prevent sock_release to be recalled.
+				 */
+				goto err_crsock;
+			err_crfd:
+				sock_release(sock);
+
+			err_crsock:
+				/* nothing to dealloc */
+
+				/* sleep a while */
+				if (--try > 0) {
+					dprintk("sleep a while before retrying\n");
+					current->state = TASK_INTERRUPTIBLE;
+					schedule_timeout(CONFIG_LIDS_NET_TIMEOUT
+							 * HZ);
+				} else
+					break;
+
+			}
+
+			/*
+			 * Remove the message, even if it has not
+			 * been successfully sent. It is maybe the cause
+			 * of the error and it is blocking the whole
+			 * message queue.
+			 */
+			dprintk("Removing message from the queue\n");
+			down(&lids_msgqueue_mutex);
+			lids_msgqueue[0].nbmsg--;
+			kfree(lids_msgqueue[0].msg[lids_msgqueue[0].head]);
+			lids_msgqueue[0].head++;
+			lids_msgqueue[0].head %= CONFIG_LIDS_MSGQUEUE_SIZE;
+			up(&lids_msgqueue_mutex);
+			wake_up_interruptible(&(lids_msgqueue[0].writeq));
+		}
+	}
+	return 0;		/* Never reached ... */
+}
+
+void
+lids_send_message(char *msg, int len)
+{
+	down(&lids_msgqueue_mutex);
+	if (lids_msgqueue[0].nbmsg < CONFIG_LIDS_MSGQUEUE_SIZE) {
+		/* for qmail that does not understand \n\r\n but needs ?\r\n.
+		We suppress the ending \n */
+		msg[len - 1] = 0;
+		lids_msgqueue[0].msg[lids_msgqueue[0].tail] = msg;
+		lids_msgqueue[0].msg_size[lids_msgqueue[0].tail++] = len - 1;
+		lids_msgqueue[0].tail %= CONFIG_LIDS_MSGQUEUE_SIZE;
+		lids_msgqueue[0].nbmsg++;
+
+		dprintk("Msg : <%s>\n", msg);
+		dprintk("head:%d tail:%d nbmsg:%d\n", lids_msgqueue[0].head,
+			lids_msgqueue[0].tail, lids_msgqueue[0].nbmsg);
+		up(&lids_msgqueue_mutex);
+
+		wake_up_interruptible(&(lids_msgqueue[0].readq));
+	} else {
+		up(&lids_msgqueue_mutex);
+		/* It is safer to loose the message
+		than to block the process */
+		dprintk("Message queue full. One message lost.\n");
+		kfree(msg);
+	}
+}
+
+int
+lids_klids_init(void)
+{
+	init_MUTEX(&lids_msgqueue_mutex);
+	/* Initialize lids_msgqueue */
+	lids_msgqueue[0].nbmsg = 0;
+	lids_msgqueue[0].tail = 0;
+	lids_msgqueue[0].head = 0;
+	init_waitqueue_head(&(lids_msgqueue[0].readq));
+	init_waitqueue_head(&(lids_msgqueue[0].writeq));
+	/*
+	lids_msgqueue[0].readq=NULL;
+	lids_msgqueue[0].writeq=NULL;
+	 */
+
+	kernel_thread(lids_klids_thread, (void *) 0, 0);
+
+	return 0;
+}
diff -durN kernel.orig/kernel/ksyms.c kernel/kernel/ksyms.c
--- kernel.orig/kernel/ksyms.c	2007-03-20 14:09:05.000000000 +1000
+++ kernel/kernel/ksyms.c	2007-03-20 14:53:00.000000000 +1000
@@ -50,6 +50,10 @@
 #include <linux/firmware.h>
 #include <asm/checksum.h>
 
+#ifdef CONFIG_LIDS
+#include <linux/lids.h>
+#endif
+
 #if defined(CONFIG_PROC_FS)
 #include <linux/proc_fs.h>
 #endif
@@ -584,3 +588,32 @@
 
 EXPORT_SYMBOL(tasklist_lock);
 EXPORT_SYMBOL(pidhash);
+
+
+/* LIDS */
+#ifdef CONFIG_LIDS
+#ifdef CONFIG_MODULES
+EXPORT_SYMBOL(lids_alert);
+EXPORT_SYMBOL(lids_load);
+EXPORT_SYMBOL(lids_cap_raised);
+EXPORT_SYMBOL(lids_cap_log);
+EXPORT_SYMBOL(lids_cap_val);
+EXPORT_SYMBOL(lids_first_time);
+EXPORT_SYMBOL(lids_log);
+EXPORT_SYMBOL(lids_bind_checker);
+EXPORT_SYMBOL(lids_cap_time_checker);
+EXPORT_SYMBOL(lids_acl_discovery);
+EXPORT_SYMBOL(lids_caps_desc);
+#ifdef CONFIG_LIDS_ALLOW_SWITCH
+EXPORT_SYMBOL(lids_local_on);
+EXPORT_SYMBOL(lids_local_pid);
+EXPORT_SYMBOL(lids_local_off);
+EXPORT_SYMBOL(tty_name);
+#endif	/*  CONFIG_LIDS_ALLOW_SWITCH */
+#ifdef CONFIG_LIDS_HANGUP
+EXPORT_SYMBOL(tty_vhangup);
+EXPORT_SYMBOL(lids_hangup_console);
+#endif	/* CONFIG_LIDS_HANGUP */
+#endif	/* CONFIG_MODULES */
+#endif	/* CONFIG_LIDS */
+
diff -durN kernel.orig/kernel/lids.c kernel/kernel/lids.c
--- kernel.orig/kernel/lids.c	1970-01-01 10:00:00.000000000 +1000
+++ kernel/kernel/lids.c	2007-03-20 14:55:08.000000000 +1000
@@ -0,0 +1,3168 @@
+/*
+ *  linux/kernel/lids.c
+ *
+ *  Author : Huagang Xie, (xie@lids.org)
+ *
+ *	This file contain the lids security options.
+ *
+ *  Changes:
+ *
+ *	[Oct 14 1999, Xie Hua Gang] initial creation
+ *	[Oct 17 1999, Xie Hua Gang] Added to do_truncate,do_link().
+ *	[Oct 27 1999, Xie Hua Gang] Added Append Only ,Device MBR protection.
+ *      [Dec 05 1999, Philippe Biondi] New design. Added hidding process
+ *		support. Added /dev/[k]mem protection.
+ *      [Dec 08 1999, Xie Hua Gang] Added firewall rules protection.
+ *      [Dec 09 1999, Philippe Biondi] Added ptrace protection. Permission
+ *		flags for /dev/mem.
+ *      [Dec 17 1999, Philippe Biondi] Added raw disk access, ioperm,
+ *		iopl protection.
+ *      [Jan 08 2000, Philippe Biondi] Use of capabilities bounding set.
+ * 	[May 07 2000, Xie Huagang] Add ACL in kernel, reference monitor.
+ * 	[Sep 26 2000, Xie Huagang] Port to linux 2.4.0-test8
+ * 	[Jan 10 2001, Xie Huagang] LIDS for Linux 2.4.0 released!
+ * 	[Jun 29 2001, Xie Huagang] Add time restriction support.
+ *	[March, 2004, Yusuf Wilajati Purna] Added LIDS TPE.
+ *	[July, 2004, Yusuf Wilajati Purna] Added LIDS TDE.
+ *		Decided not to add any more changes here.
+ *		See "ChangeLog" in the LIDS package for any new changes.
+ */
+
+/*
+ * [September, 2004, Yusuf Wilajati Purna]
+ *		Commented, refactored, cleaned up most of functions for
+ *		code clearity, readability, and maintainablity.
+ */
+
+#include <linux/mm.h>
+#include <linux/proc_fs.h>
+#include <linux/smp_lock.h>
+#include <linux/quotaops.h>
+
+#include <asm/uaccess.h>
+#include <asm/unaligned.h>
+#include <asm/semaphore.h>
+#include <asm/page.h>
+#include <asm/pgtable.h>
+
+#include <asm/namei.h>
+
+#include <linux/utime.h>
+#include <linux/file.h>
+#include <linux/fs.h>
+
+#include <linux/kernel.h>
+#include <linux/slab.h>
+#include <linux/file.h>
+#include <linux/config.h>
+#include <linux/fs.h>
+#include <linux/tty.h>
+#include <linux/sysctl.h>
+#include <linux/rmd160.h>
+#include <linux/random.h>
+#include <linux/string.h>
+#include <linux/sched.h>
+
+#include <linux/lids.h>
+
+/***********************************************************************
+ ***********************************************************************
+ *
+ *  Here are some consts and type definitions
+ *
+ ***********************************************************************
+ ***********************************************************************/
+
+#define LIDS_CONF_DIR		"/etc/lids"
+#define LIDS_ADM_PATH		"/sbin/lidsadm"
+#define LIDS_PW_FILE		"/etc/lids/lids.pw"
+#define LIDS_PW_LEN		32
+
+#define LIDS_INI_FILE		"/etc/lids/lids.ini"
+#define LIDS_GLOBAL_CONF_FILE	"/etc/lids/lids.conf"
+#define LIDS_GLOBAL_CAP_FILE	"/etc/lids/lids.cap"
+#define LIDS_BOOT_CONF_FILE	"/etc/lids/lids.boot.conf"
+#define LIDS_BOOT_CAP_FILE	"/etc/lids/lids.boot.cap"
+#define LIDS_POSTBOOT_CONF_FILE	"/etc/lids/lids.postboot.conf"
+#define LIDS_POSTBOOT_CAP_FILE	"/etc/lids/lids.postboot.cap"
+#define LIDS_SHUTDOWN_CONF_FILE	"/etc/lids/lids.shutdown.conf"
+#define LIDS_SHUTDOWN_CAP_FILE	"/etc/lids/lids.shutdown.cap"
+
+typedef struct {
+	int last_secure;
+	int last_s_acl;
+	int last_o_acl;
+	unsigned long search_secure;
+	unsigned long search_s_acl;
+	unsigned long fastguess[2048];
+	struct secure_ino secure[CONFIG_LIDS_MAX_INODE];
+	struct lids_sys_acl s_acl[CONFIG_LIDS_MAX_SACL];
+	struct lids_acl o_acl[CONFIG_LIDS_MAX_OACL];
+} _lids_data_t;
+
+struct key_entry {
+	struct list_head list;
+	char key[16];
+	unsigned long int ino;
+	kdev_t dev;
+};
+
+struct pid_key_entry {
+	struct list_head list;
+	pid_t pid;
+	struct key_entry *key_ent;
+};
+
+/***********************************************************************
+ ***********************************************************************
+ *
+ * General variables
+ *
+ ***********************************************************************
+ ***********************************************************************/
+
+int lids_load = 0;		/* it is raised to 1 when kernel boot */
+int lids_local_on = 1;
+int lids_acl_discovery = 0;
+lids_flags_t lids_flags = 0;
+int lids_local_pid = 0;
+unsigned long lids_current = 0;
+int lids_first_time = 1;
+
+int lids_state = LIDS_STATE_BOOT;	/* initial state is boot */
+kernel_cap_t lids_cap_val = CAP_INIT_EFF_SET;
+kernel_cap_t lids_conf_cap = 0;
+
+#ifdef CONFIG_LIDS_ALLOW_SWITCH
+static char lids_pw[160];
+#endif
+
+static char lids_cap_file[4][30] =
+    { LIDS_GLOBAL_CAP_FILE, LIDS_BOOT_CAP_FILE, LIDS_POSTBOOT_CAP_FILE,
+LIDS_SHUTDOWN_CAP_FILE };
+static char lids_acl_file[4][29] =
+    { LIDS_GLOBAL_CONF_FILE, LIDS_BOOT_CONF_FILE, LIDS_POSTBOOT_CONF_FILE,
+LIDS_SHUTDOWN_CONF_FILE };
+static char lids_state_name[3][9] = { "BOOT\0", "POSTBOOT\0", "SHUTDOWN\0" };
+
+static struct allowed_ino lidsadm;
+
+static _lids_data_t lids_data[2] = { {0, 0}, {0, 0} };
+
+extern int lids_read_net(void);
+
+static unsigned long lids_bittab[32] = {
+	0x00000001, 0x00000002, 0x00000004, 0x00000008,
+	0x00000010, 0x00000020, 0x00000040, 0x00000080,
+	0x00000100, 0x00000200, 0x00000400, 0x00000800,
+	0x00001000, 0x00002000, 0x00004000, 0x00008000,
+	0x00010000, 0x00020000, 0x00040000, 0x00080000,
+	0x00100000, 0x00200000, 0x00400000, 0x00800000,
+	0x01000000, 0x02000000, 0x04000000, 0x08000000,
+	0x10000000, 0x20000000, 0x40000000, 0x80000000
+};
+
+char *lids_caps_desc[] = {
+	"CAP_CHOWN",
+	"CAP_DAC_OVERRIDE",
+	"CAP_DAC_READ_SEARCH",
+	"CAP_FOWNER",
+	"CAP_FSETID",
+	"CAP_KILL",
+	"CAP_SETGID",
+	"CAP_SETUID",
+	"CAP_SETPCAP",
+	"CAP_LINUX_IMMUTABLE",
+	"CAP_NET_BIND_SERVICE",
+	"CAP_NET_BROADCAST",
+	"CAP_NET_ADMIN",
+	"CAP_NET_RAW",
+	"CAP_IPC_LOCK",
+	"CAP_IPC_OWNER",
+	"CAP_SYS_MODULE",
+	"CAP_SYS_RAWIO",
+	"CAP_SYS_CHROOT",
+	"CAP_SYS_PTRACE",
+	"CAP_SYS_PACCT",
+	"CAP_SYS_ADMIN",
+	"CAP_SYS_BOOT",
+	"CAP_SYS_NICE",
+	"CAP_SYS_RESOURCE",
+	"CAP_SYS_TIME",
+	"CAP_SYS_TTY_CONFIG",
+	"CAP_MKNOD",
+	"CAP_LEASE",
+	"CAP_HIDDEN",
+	"CAP_KILL_PROTECTED",
+	"CAP_PROTECTED",
+	NULL
+};
+
+#ifdef CONFIG_PROC_FS
+/* SJS - for key mgmnt */
+spinlock_t lids_proc_lock = SPIN_LOCK_UNLOCKED;
+static struct proc_dir_entry *lids_proc_key = 0;
+static struct proc_dir_entry *lids_proc_dir = 0;
+static int lids_key_list_count = 0;
+static LIST_HEAD(lids_key_list);
+static LIST_HEAD(lids_key_proc_list);
+#endif
+
+/***********************************************************************
+ ***********************************************************************
+ *
+ * LIDS protection management
+ *
+ ***********************************************************************
+ ***********************************************************************/
+
+/**
+ * lids_local_off - check if the current process or its ancestor is
+ *		    LFS (LIDS Free Session).
+ *		    Return 1 if true. Otherwise, return 0.
+ */
+int
+lids_local_off(void)
+{
+	struct task_struct *t;
+
+	read_lock(&tasklist_lock);
+	t = current;
+	while (t && (t->pid > 1)) {
+		if (t->pid == lids_local_pid) {
+			read_unlock(&tasklist_lock);
+			return 1;
+		}
+		t = t->p_pptr;
+	}
+	read_unlock(&tasklist_lock);
+	return 0;
+}
+
+/**
+ * lids_time_checker - check the ACL time restriction.
+ *		       Return 0 if success. Otherwise, return -1.
+ *
+ * @currenttime - current time
+ * @time - time restriction
+ */
+static __inline__ int
+lids_time_checker(const time_t currenttime, time_t time[][2])
+{
+	time_t from_time, to_time;
+	int i;
+
+	for (i = 0; i < LIDS_TIME_ITEM && time[i][0] != -1; i++) {
+		from_time = time[i][0];
+		to_time = time[i][1];
+
+		if (from_time > to_time) {
+			if (!(currenttime > to_time &&
+			      currenttime < from_time))
+				return 0;
+		} else if ((currenttime >= from_time &&
+			    currenttime <= to_time)) {
+			return 0;
+		}
+	}
+	/* we may now have an empty time array */
+	if (!i)
+		return 0;
+
+	return -1;
+}
+
+/**
+ * lids_bind_checker - check if the 'current' process can bind a given port#
+ *		       to a listening socket.
+ *		       Return 1 if success. Otherwise, return 0.
+ *
+ * @port - target port number to check
+ *
+ * This is used in conjunction with CAP_NET_BIND_SERVICE.
+ */
+int
+lids_bind_checker(const int port)
+{
+	int i = 0;
+
+	if (!(lids_load && lids_local_load))
+		return 1;
+
+	if (port == 0)
+		return 1;
+
+	if (lids_sandboxed(current) &&
+	    cap_raised(CAP_LIDS_SANDBOX_EFF_SET, CAP_NET_BIND_SERVICE))
+		return 1;
+
+	if (!lids_sandboxed(current)) {
+		if (cap_raised(lids_cap_val, CAP_NET_BIND_SERVICE))
+			return 1;
+		if (port >= 1024 || !current->lids_sys_acl)
+			return 1;
+	}
+
+	for (i = 0;
+	     i < LIDS_PORT_ITEM && current->lids_sys_acl->port[i][0] != -1;
+	     i++) {
+		if (port <= current->lids_sys_acl->port[i][1]
+		    && port >= current->lids_sys_acl->port[i][0])
+			return 1;
+	}
+
+	if (lids_acl_discovery) {
+		lids_alert(LIDS_CAP, NULL, port, CAP_NET_BIND_SERVICE,
+			   "CAP_NET_BIND_SERVICE", "CAP_NET_BIND_SERVICE");
+		return 1;
+	}
+
+	return 0;
+}
+
+/**
+ * lids_broadcast_port - check if the 'current' process can connect to a given
+ *			 port#.
+ *			 Return 1 if success. Otherwise, return 0.
+ *
+ * @port - target port number
+ *
+ * This is used in conjunction with CAP_NET_BROADCAST.
+ */
+int
+lids_broadcast_port(const int port)
+{
+	int i = 0;
+
+	if (!(lids_load && lids_local_load))
+		return 1;
+
+	if (lids_sandboxed(current) &&
+	    cap_raised(CAP_LIDS_SANDBOX_EFF_SET, CAP_NET_BROADCAST))
+		return 1;
+
+	if (!lids_sandboxed(current) &&
+	    cap_raised(lids_cap_val, CAP_NET_BROADCAST))
+		return 1;
+
+	for (i = 0;
+	     i < LIDS_PORT_ITEM && current->lids_sys_acl->cport[i][0] != -1;
+	     i++) {
+		if (port <= current->lids_sys_acl->cport[i][1] &&
+		    port >= current->lids_sys_acl->cport[i][0])
+			return 1;
+	}
+
+	if (lids_acl_discovery) {
+		lids_alert(LIDS_CAP, NULL, port, CAP_NET_BROADCAST,
+			   "CAP_NET_BROADCAST", "CAP_NET_BROADCAST");
+		return 1;
+	}
+
+	return 0;
+}
+
+/**
+ * lids_cap_time_checker - check the time restriction for a granted
+ *			   capability.
+ *			   Return 0 if success. Otherwise, return -1.
+ *			   (See lids_time_checker() for details.)
+ *
+ * @cap - target capability
+ *
+ * This function is mainly called from lids_cap_raised().
+ */
+int
+lids_cap_time_checker(const int cap)
+{
+	if (!current->lids_sys_acl)
+		return -1;
+
+	return lids_time_checker(CURRENT_TIME % (60 * 60 * 24),
+				 current->lids_sys_acl->cap[cap].time);
+
+}
+
+/**
+ * lids_cap_raised - check if the capability is raised.
+ *		     Return 1 if success. Otherwise, return 0.
+ *
+ * @cap - capability to check
+ * @log - flag to indicate if a candidate capability rule should
+ *	  be generated when LIDS in ACL_DISCOVERY mode.
+ *
+ * This is the LIDS cap_raised() function. This function considers
+ * LIDS global capability set value (lids_cap_val) and the time
+ * restriction for the capability as well. In case CONFIG_LIDS_TDE is
+ * on and the current process is sandboxed, only capabilities that
+ * are explicitly granted to the process are checked.
+ *
+ */
+int
+lids_cap_raised(const int cap, int log)
+{
+	if (!(lids_load && lids_local_load))
+		return 1;
+
+	if (lids_sandboxed(current)) {
+		if (cap_raised(current->lids_cap, cap) &&
+		    !lids_cap_time_checker(cap))
+			return 1;
+	} else if ((cap_raised(current->lids_cap, cap) &&
+		    !lids_cap_time_checker(cap)) ||
+		   cap_raised(lids_cap_val, cap))
+			return 1;
+
+	if (lids_acl_discovery && log) {
+		lids_alert(LIDS_CAP, NULL, -1, cap, lids_caps_desc[cap],
+			   lids_caps_desc[cap]);
+		return 1;
+	}
+
+	return 0;
+}
+
+/**
+ * lids_do_search_acl - search the subject ACL for an inode.
+ *			Return the address/index if available.
+ *			Otherwise, return NULL.
+ * @ino - inode number of the inode
+ * @dev - device number of the inode
+ * @data - the main data table
+ */
+static __inline__ struct lids_sys_acl *
+lids_do_search_acl(unsigned long int ino, kdev_t dev, _lids_data_t * data)
+{
+	long i, j;
+
+	/*
+	 * ok, in case of e.g. 256 entries we would require 256 comparisons
+	 * for a linear search with no match, the following reduces this
+	 * to 8 comparisons (table is sorted!)
+	 */
+
+	for (j = i = data->search_s_acl;; j >>= 1) {
+		if (i >= data->last_s_acl)
+			i -= j;
+		else if (data->s_acl[i].dev < dev)
+			i += j;
+		else if (data->s_acl[i].dev > dev)
+			i -= j;
+		else if (data->s_acl[i].ino < ino)
+			i += j;
+		else if (data->s_acl[i].ino > ino)
+			i -= j;
+		else
+			return &(data->s_acl[i]);
+		if (!j || i < 0)
+			return NULL;
+	}
+}
+
+/**
+ * lids_search_acl - search the subject ACL for an inode based on the
+ *		     LIDS current position (lids_curr)??
+ *		     Return the address/index if available.
+ *		     Otherwise, return NULL. (See lids_do_search_acl()
+ *		     for details.)
+ *
+ * @ino - inode number of the inode
+ * @dev - device number of the inod
+ * @lids_curr - the LIDS current position
+ *
+ * This function is a wrapper for lids_do_search_acl().
+ */
+struct lids_sys_acl *
+lids_search_acl(unsigned long int ino, kdev_t dev, unsigned long lids_curr)
+{
+	return lids_do_search_acl(ino, dev, &lids_data[lids_curr & 1]);
+}
+
+/**
+ * lids_check_acl - check if the current process have permission to
+ *		    access the directory/file (base).
+ *		    Return 0 if true. Otherwise, return a negative value.
+ * @base - dentry of the directory/file
+ * @type - access mode
+ *
+ * This function is mainly called from lids_check_base().
+ * Make sure that current->lids_cap is not NULL when this function is called.
+ */
+static int
+lids_check_acl(struct dentry *base, int type)
+{
+	struct lids_acl *acl;
+	struct dentry *parent;
+	struct inode *inode;
+	time_t currenttime;
+
+	if (base == NULL || current->lids_sys_acl == NULL)
+		return -EPERM;
+
+	inode = base->d_inode;
+	parent = base->d_parent;
+
+	if (parent == NULL)
+		return -EPERM;
+
+	if (inode == NULL) {
+		inode = parent->d_inode;
+		parent = parent->d_parent;
+	}
+
+	currenttime = CURRENT_TIME;
+
+	do {
+		acl = current->lids_sys_acl->lids_acl;
+
+		while (acl != NULL) {
+			if (acl->ino == inode->i_ino
+			    && acl->dev == inode->i_dev) {
+				return (type & acl->type
+					&& !lids_time_checker(currenttime %
+							      (60 * 60 * 24),
+							      acl->time)) ? 0 :
+							      -EPERM;
+			}
+			acl = acl->next;
+		}
+		if (inode == parent->d_inode) {
+			LIDS_DBG("inode == parent->d_inode,return -1\n");
+			break;
+		}
+		inode = parent->d_inode;
+	} while (((parent = parent->d_parent) != NULL));
+
+	return -1;
+}
+
+/**
+ * lids_init_task_acl - initialize a given lids_task_acl.
+ *			Return 0 if success. Otherwise, return a negative
+ *			value (e.g., -ENOMEM).
+ * @acl - lids_task_acl to initialize
+ *
+ * A memory for a lids_sys_acl is created here. Don't forget to free
+ * the memory if it is not used. lids_free_lids_task_acl() do the job.
+ */
+int
+lids_init_task_acl(struct lids_task_acl *acl)
+{
+	int i;
+
+	acl->lids_cap = 0x0UL;
+	acl->lids_sys_acl = kmalloc(sizeof (struct lids_sys_acl), GFP_KERNEL);
+	if (!acl->lids_sys_acl) {
+		LIDS_DBG("kmalloc failed\n");
+		return -ENOMEM;
+	}
+	memset(acl->lids_sys_acl, 0, sizeof (struct lids_sys_acl));
+	acl->lids_sys_acl->port[0][0] = -1;
+	acl->lids_sys_acl->port[0][1] = -1;
+	acl->lids_sys_acl->cport[0][0] = -1;
+	acl->lids_sys_acl->cport[0][1] = -1;
+	for (i = 0; i < 32; i++) {
+		acl->lids_sys_acl->cap[i].time[0][0] = -1;
+		acl->lids_sys_acl->cap[i].time[0][1] = -1;
+	}
+	acl->lids_sys_acl->lids_acl = NULL;
+	return 0;
+}
+
+/**
+ * lids_compute_acls - given a lids_task_acl and lids_sys_acl, compute
+ *		       the result lids_task_acl.
+ *		       Return 0 if success. Otherwise, return a negative
+ *		       value (e.g., -ENOMEM).
+ * @current_acl - lids_task_acl to compute
+ * @new_sys_acl - lids_sys_acl to compute with current_acl
+ * @computed_acl - lids_task_acl into which the result lids_task_acl will
+ *		   be stored.
+ * @protect - flag to indicate if the binary (new_sys_acl) is
+ *	      protected or not
+ */
+int
+lids_compute_acls(struct lids_task_acl *current_acl,
+		  struct lids_sys_acl *new_sys_acl,
+		  struct lids_task_acl *computed_acl, int protect)
+{
+
+	struct lids_acl *src_acl, *dst_acl;
+	int i, j, k;
+
+	/*
+	 * current->p_pptr,get parent's inherit_flags.
+	 * get the inherit from it's direct parent
+	 * if the inherit is not NULL, inherit the capability
+	 * or clear the capability
+	 */
+
+	LIDS_DBG("compute ACLs for pid %i\n", current->pid);
+
+	if (lids_init_task_acl(computed_acl) < 0) {
+		LIDS_DBG("init_task_acl failed\n");
+		return -ENOMEM;
+	}
+
+	if (!current_acl || !current_acl->lids_sys_acl)
+		goto no_inheritance_from_current_acl;
+
+	/*
+ 	 * compute inheritance from current->lids_sys_acl
+	 */
+	computed_acl->lids_sys_acl->socket =
+		current_acl->lids_sys_acl->socket;
+	computed_acl->lids_sys_acl->mark =
+		current_acl->lids_sys_acl->mark;
+
+	LIDS_DBG(": + pid %i: inherit ACLs: socket=0x%x, mark=%d\n",
+		 current->pid, computed_acl->lids_sys_acl->socket,
+		 computed_acl->lids_sys_acl->mark);
+
+	/* first, compute capability inheritance */
+	if (current_acl->lids_sys_acl->flags != 0) {
+		computed_acl->lids_sys_acl->flags = 0x0UL;
+		for (i = 0; i < 32; i++) {
+			if (!test_bit(i, &current_acl->lids_sys_acl->flags))
+				continue;
+			if (current_acl->lids_sys_acl->cap[i].inherit == 0) {
+				LIDS_DBG("     + pid %i: cap %i not inherited:"
+					 " TTL elapsed.\n", current->pid, i);
+				continue;
+			}
+			set_bit(i, &computed_acl->lids_sys_acl->flags);
+			memcpy(&computed_acl->lids_sys_acl->cap[i],
+			       &current_acl->lids_sys_acl->cap[i],
+			       sizeof(struct lids_cap));
+			if (current_acl->lids_sys_acl->cap[i].inherit > 0)
+				computed_acl->lids_sys_acl->cap[i].inherit--;
+			LIDS_DBG("     + pid %i: cap %i inherited. "
+				 "remaining TTL : %i\n",
+				 current->pid, i,
+				 computed_acl->lids_sys_acl->cap[i].inherit);
+		}
+	}
+	LIDS_DBG("     = pid %i: inherit caps %#lx\n", current->pid,
+		 computed_acl->lids_sys_acl->flags);
+	if (test_bit(CAP_NET_BIND_SERVICE,
+		     &computed_acl->lids_sys_acl->flags)) {
+		memcpy(computed_acl->lids_sys_acl->port,
+		       current_acl->lids_sys_acl->port,
+		       sizeof(int) * 2 * LIDS_PORT_ITEM);
+		LIDS_DBG("     + pid %i: port bind acl trasmited\n",
+			 current->pid);
+	}
+
+	if (test_bit(CAP_NET_BROADCAST,
+		     &computed_acl->lids_sys_acl->flags)) {
+		memcpy(computed_acl->lids_sys_acl->cport,
+		       current_acl->lids_sys_acl->cport,
+		       sizeof(int) * 2 * LIDS_PORT_ITEM);
+		LIDS_DBG("     + pid %i: port connect acl trasmited\n",
+			 current->pid);
+	}
+
+	if (!protect) {
+		LIDS_DBG("     = pid %i: does not inherit acls\n",
+			 current->pid);
+		goto  no_cap_and_acl;
+	}
+
+	/* if the binary is protected compute ACL inheritance */
+	src_acl = current_acl->lids_sys_acl->lids_acl;
+	while (src_acl) {
+		if (src_acl->inherit != 0) {
+			dst_acl = kmalloc(sizeof(struct lids_acl),
+					  GFP_KERNEL);
+			if (!dst_acl) {
+				LIDS_DBG("kmalloc failed\n");
+				lids_free_lids_task_acl(computed_acl);
+				return -ENOMEM;
+			}
+			memcpy(dst_acl, src_acl,
+			       sizeof(struct lids_acl));
+			if (dst_acl->inherit > 0)
+				dst_acl->inherit--;
+			LIDS_DBG("     + pid %i: ACL inherited. "
+				 "remaining TTL : %i\n",
+				 current->pid, dst_acl->inherit);
+			dst_acl->next = computed_acl->lids_sys_acl->
+					lids_acl;
+			computed_acl->lids_sys_acl->lids_acl = dst_acl;
+		} else {
+			LIDS_DBG("     + pid %i: ACL not inherited: "
+					 "TTL elapsed.\n", current->pid);
+		}
+		src_acl = src_acl->next;
+	}
+
+no_inheritance_from_current_acl:
+	LIDS_DBG("     = pid %i: %s inherit acls\n", current->pid,
+		 computed_acl->lids_sys_acl->lids_acl ? "does" : "does not");
+
+	if (!new_sys_acl || !protect)
+		goto no_cap_and_acl;
+
+	/*
+	 * Now, compute its own ACL and capability set.
+	 */
+	LIDS_DBG(" + pid %i: getting new ACLs:\n", current->pid);
+
+	/*
+	 * FIXME: no merging is done here, neither for time nor for
+	 * ports.
+	 */
+
+	/* inherit SOCKET ??*/
+	computed_acl->lids_sys_acl->socket |= new_sys_acl->socket;
+	computed_acl->lids_sys_acl->mark = new_sys_acl->mark;
+
+	/* compute capability set */
+	computed_acl->lids_sys_acl->flags |= new_sys_acl->flags;
+	for (i = 0; i < 32; i++) {
+		if (test_bit(i, &new_sys_acl->flags)) {
+			/*
+			 * this may be wrong if both values are negative
+			 * but nevertheless this leaves at least 31 bits
+			 * to play with. inheritance should be unsigned.
+			 */
+
+			LIDS_DBG("     + pid %i: getting new cap : cap #%i\n",
+				 current->pid, i);
+
+			/*
+			 * Here we do an unsigned comparison for -1 to
+			 * be the biggest number
+			 */
+			if ((unsigned int) computed_acl->lids_sys_acl->
+					   cap[i].inherit <
+			    (unsigned int) new_sys_acl->cap[i].inherit) {
+				computed_acl->lids_sys_acl->cap[i].inherit =
+					new_sys_acl->cap[i].inherit;
+				LIDS_DBG("         + pid %i: adjusting cap %i "
+					 "TTL to %i\n", current->pid, i,
+				     	 computed_acl->lids_sys_acl->
+					 cap[i].inherit);
+			}
+
+			for (j = 0; j < LIDS_TIME_ITEM; j++) {
+				if (computed_acl->lids_sys_acl->
+				    cap[i].time[j][0] == -1)
+					break;
+			}
+			for (k = 0; j < LIDS_TIME_ITEM; j++, k++) {
+				if (new_sys_acl->cap[i].time[k][0] == -1)
+					break;
+				computed_acl->lids_sys_acl->cap[i].time[j][0] =
+					new_sys_acl->cap[i].time[k][0];
+				computed_acl->lids_sys_acl->cap[i].time[j][1] =
+					new_sys_acl->cap[i].time[k][1];
+				LIDS_DBG("         + pid %i: adding cap %i "
+					 "time  limit %li-%li\n",
+					 current->pid, i,
+					 new_sys_acl->cap[i].time[k][0],
+					 new_sys_acl->cap[i].time[k][1]);
+			}
+		}
+	}
+	if (test_bit(CAP_NET_BIND_SERVICE, &new_sys_acl->flags)) {
+		LIDS_DBG("     + pid %i: Got CAP_NET_BIND_SERVICE. "
+			 "Adjusting net bind ports\n", current->pid);
+		for (j = 0; j < LIDS_PORT_ITEM; j++) {
+			if (computed_acl->lids_sys_acl->port[j][0] == -1)
+				break;
+		}
+
+		for (k = 0; j < LIDS_PORT_ITEM; j++, k++) {
+			computed_acl->lids_sys_acl->port[j][0] =
+				new_sys_acl->port[k][0];
+			computed_acl->lids_sys_acl->port[j][1] =
+				new_sys_acl->port[k][1];
+			if (new_sys_acl->port[k][0] == -1)
+				break;
+		}
+	}
+
+	if (test_bit(CAP_NET_BROADCAST, &new_sys_acl->flags)) {
+		LIDS_DBG("     + pid %i: Got CAP_NET_BROADCAST. "
+			 "Adjusting net broadcast ports\n", current->pid);
+		for (j = 0; j < LIDS_PORT_ITEM; j++) {
+			if (computed_acl->lids_sys_acl->cport[j][0] == -1)
+				break;
+		}
+
+		for (k = 0; j < LIDS_PORT_ITEM; j++, k++) {
+			computed_acl->lids_sys_acl->cport[j][0] =
+				new_sys_acl->cport[k][0];
+			computed_acl->lids_sys_acl->cport[j][1] =
+				new_sys_acl->cport[k][1];
+			if (new_sys_acl->cport[k][0] == -1)
+				break;
+		}
+	}
+
+	/* compute ACLs */
+	src_acl = new_sys_acl->lids_acl;
+	while (src_acl) {
+		LIDS_DBG("     + pid %i: getting a new fs ACL\n",
+			 current->pid);
+		dst_acl = kmalloc(sizeof (struct lids_acl), GFP_KERNEL);
+		if (!dst_acl) {
+			LIDS_DBG("kmalloc failed\n");
+			lids_free_lids_task_acl(computed_acl);
+			return -ENOMEM;
+		}
+		memcpy(dst_acl, src_acl, sizeof (struct lids_acl));
+		dst_acl->next = computed_acl->lids_sys_acl->lids_acl;
+		computed_acl->lids_sys_acl->lids_acl = dst_acl;
+		src_acl = src_acl->next;
+	}
+
+no_cap_and_acl:
+	computed_acl->lids_cap = computed_acl->lids_sys_acl->flags;
+
+	LIDS_DBG(" = pid %i: final caps : %#lx\n", current->pid,
+		 computed_acl->lids_cap);
+
+	return 0;
+}
+
+/**
+ * lids_get_task_acl - get lids_task_acl from a task structure.
+ * @acl - lids_task_acl into which lids_task_acl from the task
+ *	  will be stored.
+ * @task - target task
+ *
+ * The task locking (task_lock(task)) is done here, so don't
+ * hold the task_lock when calling this function.
+ */
+void
+lids_get_task_acl(struct lids_task_acl *acl, struct task_struct *task)
+{
+	task_lock(task);
+	acl->lids_sys_acl = task->lids_sys_acl;
+	acl->lids_cap = task->lids_cap;
+	task_unlock(task);
+}
+
+/**
+ * lids_set_task_acl - set lids_task_acl into a task structure.
+ * @acl - lids_task_acl that will be set into the task.
+ * @task - target task
+ */
+void
+lids_set_task_acl(struct lids_task_acl *acl, struct task_struct *task)
+{
+	struct lids_sys_acl *tsk_sys_acl;
+
+	if (!task || !acl) {
+		printk("lids_set_task_acl:yee..bug!\n");
+		return;
+	}
+
+	tsk_sys_acl = acl->lids_sys_acl;
+
+	if (tsk_sys_acl) {
+		/* check this acl, to see if it really contain an ACL */
+		if (acl->lids_cap == 0 && tsk_sys_acl->lids_acl == NULL &&
+		    tsk_sys_acl->socket == 0) {
+			lids_free_lids_task_acl(acl);
+			task_lock(task);
+			task->lids_sys_acl = NULL;
+			task_unlock(task);
+		} else {
+			task_lock(task);
+			task->lids_sys_acl = tsk_sys_acl;
+			task->lids_cap = acl->lids_cap;
+			task_unlock(task);
+		}
+	}
+	return;
+}
+
+/**
+ * lids_task_acl_deep_copy - copy lids_task_acl from src to dst.
+ * @src - source lids_task_acl
+ * @dst - destination lids_task_acl
+ *
+ * Caller only passes addresses of the source and destination lids_task_acls.
+ * Memory areas for the destination lids_sys_acl and lids_acls are created
+ * here.
+ */
+int
+lids_task_acl_deep_copy(struct lids_task_acl *dst, struct lids_task_acl *src)
+{
+	struct lids_acl *s, *d;
+
+	dst->lids_cap = src->lids_cap;
+
+	if (!src->lids_sys_acl) {
+		dst->lids_sys_acl = NULL;
+		return 0;
+	}
+
+	dst->lids_sys_acl = (struct lids_sys_acl *)
+			    kmalloc(sizeof(struct lids_sys_acl), GFP_KERNEL);
+	if (!dst->lids_sys_acl) {
+		LIDS_DBG("kmalloc error\n");
+		return -ENOMEM;
+	}
+	memcpy(dst->lids_sys_acl, src->lids_sys_acl,
+	       sizeof(struct lids_sys_acl));
+
+	/* copy lids_acl */
+	dst->lids_sys_acl->lids_acl = NULL;
+	s = src->lids_sys_acl->lids_acl;
+	while (s) {
+		d = kmalloc(sizeof(struct lids_acl), GFP_KERNEL);
+		if (!d) {
+			LIDS_DBG("kmalloc error\n");
+			lids_free_lids_task_acl(dst);
+			return -ENOMEM;
+		}
+		memcpy(d, s, sizeof(struct lids_acl));
+		d->next = dst->lids_sys_acl->lids_acl;
+		dst->lids_sys_acl->lids_acl = d;
+		s = s->next;
+	}
+
+	return 0;
+}
+
+/**
+ * lids_free_lids_task_acl - free lids_task_acl
+ * @acl - target lids_task_acl to be freed
+ */
+void
+lids_free_lids_task_acl(struct lids_task_acl *acl)
+{
+	struct lids_sys_acl *this_sys_acl = acl->lids_sys_acl;
+	struct lids_acl *this_acl, *next_acl;
+
+	if (!this_sys_acl)
+		return;
+
+	this_acl = this_sys_acl->lids_acl;
+	while (this_acl) {
+		next_acl = this_acl->next;
+		kfree(this_acl);
+		this_acl = next_acl;
+	}
+	LIDS_DBG("pid=%d begin to free %p\n", current->pid,
+		 this_sys_acl);
+	kfree(this_sys_acl);
+	acl->lids_sys_acl = NULL;
+}
+/**
+ * lids_clear_lids_task_acl - clear a lids_task_acl without freeing
+ *			      lids_task_acl->lids_sys_acl.
+ * @acl - target lids_task_acl to be cleared
+ */
+void
+lids_clear_lids_task_acl(struct lids_task_acl *acl)
+{
+	int i;
+	struct lids_sys_acl *this_sys_acl = acl->lids_sys_acl;
+	struct lids_acl *this_acl, *next_acl;
+
+	acl->lids_cap = 0x0UL;
+	if (!this_sys_acl)
+		return;
+
+	this_acl = this_sys_acl->lids_acl;
+	while (this_acl) {
+		next_acl = this_acl->next;
+		kfree(this_acl);
+		this_acl = next_acl;
+	}
+
+	memset(this_sys_acl, 0, sizeof(struct lids_sys_acl));
+	this_sys_acl->port[0][0] = -1;
+	this_sys_acl->port[0][1] = -1;
+	this_sys_acl->cport[0][0] = -1;
+	this_sys_acl->cport[0][1] = -1;
+	for (i = 0; i < 32; i++) {
+		this_sys_acl->cap[i].time[0][0] = -1;
+		this_sys_acl->cap[i].time[0][1] = -1;
+	}
+	this_sys_acl->lids_acl = NULL;
+
+	return;
+}
+
+#ifdef CONFIG_PROC_FS
+struct pid_key_entry *__get_pk_ent(pid_t pid)
+{
+        struct list_head *p = 0;
+        struct pid_key_entry *pk_ent;
+        list_for_each(p,&lids_key_proc_list) {
+                pk_ent = list_entry(p, struct pid_key_entry, list);
+                if (pk_ent->pid == pid) {
+                        return pk_ent;
+                }
+        }
+        return 0;
+}
+
+/*
+ * Set the key for the executable bin when exec'ed by task
+ *
+ * The keys are one-for-one mapped to binaries on disk, so
+ * they are stored and searched for against the dev and inode
+ * of the binary - until the kernel is rebooted, each time the
+ * binary runs it will get the same key.
+ *
+ * The list lids_key_list keeps a list of the keys set for binaries
+ * and this list will grow every time a binary we haven't seen before
+ * is exec'ed.  The growth is capped at CONFIG_LIDS_MAX_INODE key_entry
+ * structures.
+ *
+ * If a process was running with key A, and then exec's some binary,
+ * it will get a new key B.  Several copies of the binary could be running
+ * each having a pid_key_entry pointing to the same key_entry
+ *
+ * This method is not fast, but is called during the exec, so should
+ * be very fast compared with the speed of loading the binary.
+ */
+void lids_init_key(struct linux_binprm *bin, struct task_struct *task)
+{
+        struct inode *l_inode;
+        struct list_head *p = 0;
+        struct key_entry *key_ent,*new_key_ent = 0;
+        struct pid_key_entry *new_pk_ent = 0;
+        int verbose = 0;
+        new_pk_ent = __get_pk_ent(task->pid);
+        if ( strstr( bin->filename, "proc_keys" ))
+                verbose = 1;
+        if ( new_pk_ent == 0 ) {
+                new_pk_ent = kmalloc(sizeof(struct pid_key_entry), GFP_KERNEL);
+                if ( new_pk_ent == 0 ) {
+                        LIDS_DBG("kmalloc error creating pid key ent\n");
+                        return;
+                }
+                INIT_LIST_HEAD(&new_pk_ent->list);
+                new_pk_ent->pid = task->pid;
+                new_pk_ent->key_ent = 0;
+                spin_lock(&lids_proc_lock);
+                list_add(&new_pk_ent->list,&lids_key_proc_list);
+                spin_lock(&lids_proc_lock);
+                if ( verbose )
+                        printk( "Created new pid key entry for %d\n", task->pid );
+        }
+        l_inode = bin->file->f_dentry->d_inode;
+        if ( l_inode && l_inode->i_ino && l_inode->i_dev ) {
+                list_for_each(p,&lids_key_list) {
+                        key_ent = list_entry(p,struct key_entry,list);
+                        if ( key_ent->ino == l_inode->i_ino
+                                        && key_ent->dev == l_inode->i_dev ) {
+                                new_key_ent = key_ent;
+                                break;
+                        }
+                }
+                if ( new_key_ent == 0 ) {
+                        if ( lids_key_list_count < CONFIG_LIDS_MAX_INODE ) {
+                                new_key_ent = kmalloc(sizeof(struct pid_key_entry),
+                                                GFP_KERNEL);
+                                if ( new_key_ent == 0 ) {
+                                        LIDS_DBG("kmalloc error creating pid key ent\n");
+                                        return;
+                                }
+                                lids_key_list_count++;
+                                INIT_LIST_HEAD(&new_key_ent->list);
+                                get_random_bytes( new_key_ent->key, 16 );
+                                new_key_ent->ino = l_inode->i_ino;
+                                new_key_ent->dev = l_inode->i_dev;
+                                spin_lock(&lids_proc_lock);
+                                list_add(&new_key_ent->list,&lids_key_list);
+                                spin_unlock(&lids_proc_lock);
+                                LIDS_DBG( "new key entry created for %d, dev %i, ino %lu\n",
+                                        task->pid, new_key_ent->dev, new_key_ent->ino );
+                        } else {
+                                lids_security_alert("Keys overflowed, pid %d",
+                                                task->pid);
+                        }
+                }
+                new_pk_ent->key_ent = new_key_ent;
+        } else {
+                LIDS_DBG("Set key called for unresolved dentry");
+        }
+}
+
+int lids_get_key(struct task_struct *task, char * buffer)
+{
+        int res = 0;
+        struct pid_key_entry *pk_ent = __get_pk_ent(task->pid);
+        if ( pk_ent ) {
+                memcpy( buffer, pk_ent->key_ent->key, 16 );
+                res = 16;
+        }
+        printk("lids_get_key - pid %d - found: %s\n", task->pid, res ? "yes":"no");
+        return res;
+}
+#else /* CONFIG_PROC_FS */
+void lids_init_key(struct dentry *bin, struct task_struct *task) { }
+int lids_get_key(struct task_struct *task, char * buffer) { return 1; }
+#endif /* CONFIG_PROC_FS */
+
+/**
+ * exit_lids - free allocated task->lids_sys_acl when do_exit().
+ * @tsk - target task
+ */
+void
+exit_lids(struct task_struct *tsk)
+{
+	struct lids_task_acl acl;
+
+#ifdef CONFIG_PROC_FS
+        struct pid_key_entry *pk_ent = 0;
+        spin_lock(&lids_proc_lock);
+        pk_ent = __get_pk_ent(tsk->pid);
+        if (pk_ent) {
+                list_del(&pk_ent->list);
+                spin_unlock(&lids_proc_lock);
+                kfree( pk_ent );
+        } else {
+                spin_unlock(&lids_proc_lock);
+        }
+#endif
+
+	LIDS_DBG("LIDS: exit pid %d\n", tsk->pid);
+	lids_get_task_acl(&acl, tsk);
+	task_lock(tsk);
+	tsk->lids_sys_acl = NULL;
+	task_unlock(tsk);
+	lids_free_lids_task_acl(&acl);
+}
+
+/**
+ * lids_add_acl - add a LIDS ACL into the main data table.
+ *
+ * @s_ino - inode number of the subject
+ * @s_dev - device number of the subject
+ * @s_file - subject filename
+ * @o_ino - inode number of the object
+ * @o_dev - device number of the object
+ * @type - access mode
+ * @inherit - inheritance level
+ * @data - the main data table
+ * @time - time restriction
+ * @port - restricted ports for CAP_NET_BIND_SERVICE
+ * @cport - restricted ports for CAP_NET_BROADCAST
+ */
+static void
+lids_add_acl(unsigned long int s_ino, kdev_t s_dev, char *s_file,
+	     unsigned long int o_ino, kdev_t o_dev, int type, int inherit,
+	     _lids_data_t *data, void *time, void *port, void *cport)
+{
+	struct lids_sys_acl *this_sys_acl;
+	struct lids_acl *lids_acl, *acl;
+	int i;
+
+	for (this_sys_acl = NULL, i = 0; i < data->last_s_acl && !this_sys_acl;
+	     i++)
+		if (data->s_acl[i].ino == s_ino && data->s_acl[i].dev == s_dev)
+			this_sys_acl = &(data->s_acl[i]);
+
+	if (!this_sys_acl) {
+		if (data->last_s_acl == CONFIG_LIDS_MAX_SACL) {
+			printk(KERN_WARNING "LIDS: Warning! The main data "
+			       "table for Subject ACLs is full\n");
+			return;
+		}
+		if ((int) (o_ino) != -1 &&
+		    data->last_o_acl == CONFIG_LIDS_MAX_OACL) {
+			printk(KERN_WARNING "LIDS: Warning! The main data "
+			       "table for Object ACLs is full\n");
+			return;
+		}
+
+		LIDS_DBG("lids_add_s_acl,%ld,%d\n", s_ino, s_dev);
+
+		this_sys_acl = &(data->s_acl[(data->last_s_acl)++]);
+		this_sys_acl->ino = s_ino;
+		this_sys_acl->dev = s_dev;
+		this_sys_acl->flags = 0;
+		memset(this_sys_acl->cap, '\0',
+		       32 * sizeof (struct lids_cap *));
+		this_sys_acl->lids_acl = NULL;
+		this_sys_acl->port[0][0] = this_sys_acl->port[0][1] = -1;
+		this_sys_acl->cport[0][0] = this_sys_acl->cport[0][1] = -1;
+	}
+
+	if (type == LIDS_CAP) {
+		set_bit(o_dev, &this_sys_acl->flags);
+		this_sys_acl->cap[o_dev].inherit = inherit;
+
+		memcpy(this_sys_acl->cap[o_dev].time, time,
+		       sizeof (this_sys_acl->cap[o_dev].time));
+
+		if (o_dev == CAP_NET_BIND_SERVICE)
+			memcpy(this_sys_acl->port, port,
+			       sizeof(this_sys_acl->port));
+
+		if (o_dev == CAP_NET_BROADCAST)
+			memcpy(this_sys_acl->cport, cport,
+			       sizeof(this_sys_acl->cport));
+		return;
+	}
+
+	if (type == LIDS_SOCKET) {
+		i = o_dev;
+		if ((i == LIDS_SANDBOX) && !lids_tde) {
+			printk(KERN_WARNING "LIDS: TDE feature disabled! "
+					  "%s (dev %d:%d inode %ld) "
+					  "LIDS_SANDBOX is ignored!\n", s_file,
+					  MAJOR(s_dev), MINOR(s_dev), s_ino);
+			return;
+		}
+		set_bit(o_dev, &this_sys_acl->socket);
+		if (i == LIDS_SOCKET_NF_MARK)
+			this_sys_acl->mark = o_ino;
+
+		return;
+	}
+
+	if (data->last_o_acl == CONFIG_LIDS_MAX_OACL) {
+		printk(KERN_WARNING "LIDS: Warning! The main data "
+		       "table for Object ACLs is full\n");
+		return;
+	}
+
+	LIDS_DBG("lids_add_o_acl,%ld,%d,%ld,%d,%d\n", this_sys_acl->ino,
+		 this_sys_acl->dev, o_ino, o_dev, type);
+
+	lids_acl = &(data->o_acl[(data->last_o_acl)++]);
+	lids_acl->ino = o_ino;
+	lids_acl->dev = o_dev;
+	lids_acl->inherit = inherit;
+	memcpy(lids_acl->time, time, LIDS_TIME_ITEM * 2 * sizeof (time_t *));
+	lids_acl->next = NULL;
+
+	/*
+	 * lids_domain is deprecated.
+	 * This is to make sure that "type" is
+	 * always positive in case lids_domain
+	 * is accidentally set by the old lidstools.
+	 */
+	if (type < 0)
+		type = -type;
+	lids_acl->type = type;
+
+	if ((acl = this_sys_acl->lids_acl) == NULL)
+		this_sys_acl->lids_acl = lids_acl;
+	else {
+		while (acl->next)
+			acl = acl->next;
+		acl->next = lids_acl;
+	}
+}
+
+/**
+ * lids_acl_dev_ino_cmp - compare lids_sys_acl s1 and s2.
+ *			  Return 1 if dev# or inode# of s1 is greater than
+ *			  those of s2.
+ *			  Return -1 if dev# or inode# of s1 is less than
+ *			  those of s2.
+ *			  Otherwise, return 0 (i.e., s1 is the same as s2).
+ * @s1 - lids_sys_acl s1
+ * @s2 - lids_sys_acl s2
+ */
+static __inline__ int
+lids_acl_dev_ino_cmp(struct lids_sys_acl *s1, struct lids_sys_acl *s2)
+{
+	if (s1->dev < s2->dev)
+		return -1;
+	if (s1->dev > s2->dev)
+		return 1;
+	if (s1->ino < s2->ino)
+		return -1;
+	if (s1->ino > s2->ino)
+		return 1;
+	return 0;		/* Aieeeh, duplicate entry */
+}
+
+/**
+ * lids_sort_acls - sort acl entries by device or inode#.
+ *
+ * @data - the main data table.
+ */
+static int
+lids_sort_acls(_lids_data_t * data)
+{
+	int i;
+	int working;
+	struct lids_sys_acl tmp;
+
+	do {
+		working = 0;
+		for (i = 0; i < data->last_s_acl - 1; i++)
+			switch (lids_acl_dev_ino_cmp(&(data->s_acl[i]),
+						     &(data->s_acl[i + 1]))) {
+			case 0:
+				return 0;
+			case 1:
+				tmp = data->s_acl[i];
+				data->s_acl[i] = data->s_acl[i + 1];
+				data->s_acl[i + 1] = tmp;
+				working = 1;
+			}
+		for (i = data->last_s_acl - 1; i > 0; i--)
+			switch (lids_acl_dev_ino_cmp(&(data->s_acl[i - 1]),
+						     &(data->s_acl[i]))) {
+			case 0:
+				return 0;
+			case 1:
+				tmp = data->s_acl[i - 1];
+				data->s_acl[i - 1] = data->s_acl[i];
+				data->s_acl[i] = tmp;
+				working = 1;
+			}
+	} while (working);
+
+	/* set up base index for fast search: no, we can't use >0x20000000
+	   here but anyway it'll take some years for computers to
+	   allow for the memory required for this size :-) */
+
+	data->search_s_acl = 0x20000000;
+	while (data->last_s_acl <= data->search_s_acl && data->search_s_acl)
+		data->search_s_acl >>= 1;
+
+	return 1;
+}
+
+/**
+ * lids_search_inode - search a given inode (based on inode#/device#) in
+ *		       the main data table (arr_ino array).
+ *		       If it's found, return 'type' of the inode (LIDS_DENY,
+ *		       LIDS_READONLY, LIDS_CAP, etc.).
+ *		       Otherwise, return a negative value (-1).
+ * @ino - inode# of the given inode
+ * @dev - device# of the given inode
+ * @data - the main data table
+ *
+ * xhg's original notes:
+ *
+ *	lids_search_inode()
+ *
+ *	check the inode in a arr_ino array.
+ *	may be use fast search in this array.
+ *	xhg, 1999/10/11.
+ */
+static __inline__ int
+lids_search_inode(unsigned long ino, kdev_t dev, _lids_data_t * data)
+{
+	long i = (ino ^ dev) & 0xffff;
+	long j;
+
+	/* when the 'hash' bit is not set we for sure don't have
+	   a matching entry, so just signal 'nothing found' */
+
+	if (!(data->fastguess[i >> 5] & lids_bittab[i & 31]))
+		return -1;
+
+	/* ok, in case of e.g. 256 entries we would require 256 comparisons
+	   for a linear search with no match, the following reduces this
+	   to 8 comparisons (table is sorted!) */
+
+	for (j = i = data->search_secure;; j >>= 1) {
+		if (i >= data->last_secure)
+			i -= j;
+		else if (data->secure[i].dev < dev)
+			i += j;
+		else if (data->secure[i].dev > dev)
+			i -= j;
+		else if (data->secure[i].ino < ino)
+			i += j;
+		else if (data->secure[i].ino > ino)
+			i -= j;
+		else {
+			return data->secure[i].type;
+		}
+		if (!j || i < 0)
+			return -1;
+	}
+}
+
+/**
+ * lids_check_hidden_inode - check if a given inode is hidden
+ *			     (i.e., type == LIDS_DENY).
+ *			     Return -1 if inode is hidden.
+ *			     Otherwise, return 0.
+ * @ino - inode# of the given inode
+ * @dev - device# of the given inode
+ *
+ * Return values should be modified for code clearity, readability,
+ * and maintainability.
+ */
+int
+lids_check_hidden_inode(unsigned long ino, kdev_t dev)
+{
+	if (lids_search_inode(ino, dev, &lids_data[lids_current & 1]) ==
+	    LIDS_DENY)
+		return -1;
+	return 0;
+}
+
+/**
+ * lids_check_base - a wrapper to check to see if the 'current' process can
+ *		     access 'base' with the LIDS 'flag' access mode.
+ *		     If so return 0. Otherwise, return a negative value.
+ * @base - target dentry
+ * @flag - LIDS access mode (LIDS_APPEND, LIDS_READONLY, etc.)
+ *
+ * Note that for a sandboxed process, this function will only return 0 if
+ * only if there is an explicit ACL entry indicating that the corresponding
+ * binary can access the 'base' dentry.
+ *
+ * For a normal process (non-sandboxed process), further checking won't be
+ * done as soon as it's found that the 'base' dentry is not protected
+ * (i.e., the dentry or its parents are not in the main data table). In this
+ * case, this function will return 0.
+ */
+int
+lids_check_base(struct dentry *base, int flag)
+{
+	struct inode *ino;
+	struct dentry *dentry = base;
+	int retval = 0;
+	unsigned long lids_curr = lids_current;
+
+	/* if current is sandboxed check directly current's ACLs */
+	if (lids_sandboxed(current)) {
+		LIDS_DBG("Process [pid %d ppid %d] is sandboxed, "
+			 "caps=0x%lx\n", current->pid, current->p_pptr->pid,
+			 current->lids_cap);
+		/* ignore if base is /dev/tty */
+		if (lids_dev_tty(base))
+			return 0;
+		if (lids_check_acl(base, flag) != 0)
+			return -EPERM;
+		return 0;
+	}
+
+	while (dentry) {
+		if ((ino = dentry->d_inode) != NULL)
+			if ((retval = lids_search_inode(ino->i_ino, ino->i_dev,
+							&lids_data[lids_curr &
+								   1])) >= 0) {
+				return (retval & flag) ? 0 :
+				    lids_check_acl(base, flag);
+			}
+		if (dentry == dentry->d_parent)
+			return 0;
+		dentry = dentry->d_parent;
+	}
+
+	return 0;
+}
+
+/**
+ * lids_protected - check if 'base' is protected stronger than 'prot'
+ *		    Return 1 if true. Otherwise, return 0.
+ * @base - dentry to check
+ * @prot - protection mode
+ *
+ * To check if base is protected with READONLY mode at the minimum,
+ * prot should be set to LIDS_APPEND.
+ */
+int
+lids_protected(struct dentry *base, int prot)
+{
+	int retval = 0;
+	struct dentry *dentry = base;
+	unsigned long lids_curr = lids_current;
+
+	while (dentry) {
+		if (dentry->d_inode) {
+			retval = lids_search_inode(dentry->d_inode->i_ino,
+						   dentry->d_inode->i_dev,
+						   &lids_data[lids_curr & 1]);
+			if (retval >= 0)
+				return (retval & prot) ? 0 : 1;
+		}
+		if (dentry == dentry->d_parent)
+			return 0;
+		dentry = dentry->d_parent;
+	}
+	return 0;
+}
+
+/**
+ * lids_add_inode - add a default rule for an inode, i.e., a protected
+ *		    inode, into the main data table.
+ * @inode - the given inode number
+ * @dev - dev number of the inode
+ * @type - protection type
+ * @data - the main data table
+ *
+ * This only gives warning messages in case the main data table is full
+ * or the same inode is found.
+ */
+static void
+lids_add_inode(unsigned long inode, kdev_t dev, int type, _lids_data_t * data)
+{
+	int i, last = 1;
+
+	if (data->last_secure == CONFIG_LIDS_MAX_INODE) {
+		printk(KERN_WARNING "LIDS: Warning! The main data table for "
+		       "protected inodes is full\n");
+		return;
+	}
+
+	LIDS_DBG("lids_add_inode, %ld, %d, %d\n", inode, dev, type);
+
+	for (i = 0; i < data->last_secure; i++)
+		if ((data->secure[i].ino == inode) &&
+		    (data->secure[i].dev == dev)) {
+			printk(KERN_WARNING "LIDS: Warning! Same inode is "
+			       "found! Overwrite the previous default rule\n");
+			last = 0;
+			break;
+		}
+
+	data->secure[data->last_secure].ino = inode;
+	data->secure[data->last_secure].dev = dev;
+	data->secure[data->last_secure].type = type;
+
+	if (last)
+		(data->last_secure)++;
+
+	i = (dev ^ inode) & 0xffff;
+	data->fastguess[i >> 5] |= lids_bittab[i & 31];
+}
+
+/**
+ * lids_inode_dev_ino_cmp - compare secure_ino s1 and s2.
+ *			  Return 1 if dev# or inode# of s1 is greater than
+ *			  those of s2.
+ *			  Return -1 if dev# or inode# of s1 is less than
+ *			  those of s2.
+ *			  Otherwise, return 0 (i.e., s1 is the same as s2).
+ * @s1 - secure_ino s1
+ * @s2 - secure_ino s2
+ */
+static __inline__ int
+lids_inode_dev_ino_cmp(struct secure_ino *s1, struct secure_ino *s2)
+{
+	if (s1->dev < s2->dev)
+		return -1;
+	if (s1->dev > s2->dev)
+		return 1;
+	if (s1->ino < s2->ino)
+		return -1;
+	if (s1->ino > s2->ino)
+		return 1;
+	return 0;		/* Aieeeh, duplicate entry */
+}
+
+/**
+ * lids_sort_inodes - sort inode entries by inode# or device#.
+ *
+ * @data - the main data table
+ */
+static int
+lids_sort_inodes(_lids_data_t * data)
+{
+	int i;
+	int working;
+	struct secure_ino tmp;
+
+	do {
+		working = 0;
+		for (i = 0; i < data->last_secure - 1; i++)
+			switch (lids_inode_dev_ino_cmp(&(data->secure[i]),
+						       &(data->
+							 secure[i + 1]))) {
+			case 0:
+				return 0;
+			case 1:
+				tmp = data->secure[i];
+				data->secure[i] = data->secure[i + 1];
+				data->secure[i + 1] = tmp;
+				working = 1;
+			}
+		for (i = data->last_secure - 1; i > 0; i--)
+			switch (lids_inode_dev_ino_cmp(&(data->secure[i - 1]),
+						       &(data->secure[i]))) {
+			case 0:
+				return 0;
+			case 1:
+				tmp = data->secure[i - 1];
+				data->secure[i - 1] = data->secure[i];
+				data->secure[i] = tmp;
+				working = 1;
+			}
+	} while (working);
+
+	/*
+	 * set up base index for fast search: no, we can't use >0x20000000
+	 * here but anyway it'll take some years for computers to
+	 * allow for the memory required for this size :-)
+	 */
+
+	data->search_secure = 0x20000000;
+	while (data->last_secure <= data->search_secure && data->search_secure)
+		data->search_secure >>= 1;
+
+	return 1;
+}
+/**
+ * lids_get_info - get info (strings) of inode/dev# from a 'buffer' and
+ *		   put the corresponding values into 'ino' and 'dev'.
+ *		   Return 0 on success and -1 on failure.
+ * @buffer - target buffer
+ * @ino - inode#
+ * @dev - device#
+ * @type - ACL type (LIDS_DENY, LIDS_READONLY, LIDS_CAP, etc.)
+ */
+static int
+lids_get_info(char *buffer, unsigned long int *ino, kdev_t * dev, int type)
+{
+	int error = -1;
+	char ino_str[64], dev_str[64];
+	char *q, *p;
+	struct dentry *d_file;
+	struct nameidata nd;
+
+	/* get the dentry of the file */
+	/* it is a special type, ino=-1 */
+
+	memset(ino_str, '\0', 64);
+	memset(dev_str, '\0', 64);
+
+	p = memscan(buffer, ':', strlen(buffer));
+	if (((unsigned long) (p - buffer)) == strlen(buffer))
+		goto exit;
+	if (((unsigned long) (p - buffer)) > 63)
+		goto exit;
+	memcpy(ino_str, buffer, p - buffer);
+
+	p++;
+	q = memscan(p, ':', strlen(p));
+	if (((unsigned long) (q - p)) == strlen(p))
+		goto exit;
+	if (((unsigned long) (q - p)) > 63)
+		goto exit;
+	memcpy(dev_str, p, q - p);
+
+	error = 0;
+	if (type == LIDS_CAP || type == LIDS_SOCKET) {
+		*dev = (kdev_t) simple_strtoul(dev_str, 0, 0);
+		*ino = simple_strtoul(ino_str, 0, 0);
+		goto exit;
+	}
+	q++;
+	error = user_path_walk(q, &nd);
+	d_file = nd.dentry;
+
+	if (error) {
+		*ino = simple_strtoul(ino_str, 0, 0);
+		*dev = (kdev_t) simple_strtoul(dev_str, 0, 0);
+	} else {
+		if (d_file && d_file->d_inode) {
+			if (d_mountpoint(d_file)) {
+				LIDS_DBG("OK,Mount point found!\n");
+				*ino = simple_strtoul(ino_str, 0, 0);
+				*dev = (kdev_t) simple_strtoul(dev_str, 0, 0);
+			} else {
+				*ino = simple_strtoul(ino_str, 0, 0);
+				*dev = (kdev_t) simple_strtoul(dev_str, 0, 0);
+				if ((*ino != d_file->d_inode->i_ino) ||
+				    (*dev != d_file->d_inode->i_dev))
+				LIDS_DBG("now=%p\n", d_file);
+			}
+		}
+		path_release(&nd);
+	}
+	error = 0;
+exit:
+	return error;
+}
+
+/**
+ * lids_str2data - convert a given string (ports, times info) into
+ *		   integer data.
+ *		   Return 0 on success, and -1 on failure.
+ * @string - the given string
+ * @data - int array to hold converted data
+ * @item - numbers of data items
+ *
+ * possible string formats:
+ *	":val1-val2"
+ *	":val1,val2"
+ *	":val1-val2,val3-val4"
+ */
+int
+lids_str2data(char *string, int data[][2], int item)
+{
+
+	char *p = NULL;
+	char *q = NULL;
+	char *r = NULL;
+	int i = 0;
+
+	r = string;
+	p = strchr(r, ':');
+	if (p != NULL)
+		*p = '\0';
+	do {
+		q = strchr(r, ',');
+		if (q != NULL)
+			*q = '\0';
+
+		p = strchr(r, '-');
+		if (p == NULL)
+			return -1;
+		*p = '\0';
+
+		data[i][0] = simple_strtoul(r, 0, 0);
+		data[i][1] = simple_strtoul(p + 1, 0, 0);
+		/*
+		 * big bad problem later if we do allow 0-0 values to
+		 * be stored here: merging of time/port data will fail
+		 */
+		if (data[i][0] || data[i][1])
+			i++;
+		if (q != NULL)
+			r = q + 1;
+	} while (q != NULL && i < item);
+	/* marked the lastest item */
+	if (i != item)
+		data[i][0] = data[i][1] = -1;
+	return 0;
+}
+
+/**
+ * lids_init_add_file - get an ACL entry info from a given buffer,
+ *			parse it, and add the resulted data into
+ *			the main data table.
+ *			Return 0 on success. Otherwise, return a negative
+ *			value.
+ *
+ * @buffer - buffer holding an ACL entry info
+ * @data - the main data table
+ *
+ * Possible ACL entry formats:
+ *	"s_ino:s_dev:s_file:type:inherit:o_ino:o_dev:o_file:time"
+ *	"s_ino:s_dev:s_file:type:inherit:port:o_ino:o_dev:o_file:time"
+ *
+ * This function in fact calls lids_add_inode() or lids_add_acl() to add
+ * the resulted data into the main data table.
+ */
+static int
+lids_init_add_file(char *buffer, _lids_data_t * data)
+{
+	char *p, *q, *s_file = NULL;
+	int error = -1;
+	int is_default_rule = 0;
+	int type, inherit;
+	unsigned long int s_ino, o_ino;
+	kdev_t s_dev, o_dev;
+	int time[LIDS_TIME_ITEM][2];
+	int port[LIDS_PORT_ITEM][2];
+	int cport[LIDS_PORT_ITEM][2];
+
+        printk("LIDS: Parsing acl %s\n", buffer);
+
+	p = memscan(buffer, ':', strlen(buffer));
+	if (((unsigned long) (p - buffer)) == strlen(buffer))
+		goto exit;
+
+	p++;
+	q = memscan(p, ':', strlen(p));
+	error = -2;
+	if (((unsigned long) (q - p)) == strlen(p))
+		goto exit;
+
+	error = -3;
+	q++;
+	if (*q == ':') {
+		is_default_rule = 1;
+		p = q;
+	} else {
+		s_file = q;
+		p = memscan(q, ':', strlen(q));
+		if (((unsigned long) (p - q)) == strlen(q))
+			goto exit;
+	}
+	*p = '\0';
+	p++;
+	q = memscan(p, ':', strlen(p));
+	*q = '\0';
+	q++;
+	type = simple_strtol(p, 0, 0);
+
+	p = memscan(q, ':', strlen(q));
+	*p = '\0';
+	inherit = simple_strtol(q, 0, 0);
+	p++;
+
+	q = strrchr(p, ':');
+	error = -3;
+	if (q == NULL)
+		goto exit;
+	*q = '\0';
+	q++;
+
+	/* p point to the object's ino,dev,filename */
+	error = -4;
+	if (is_default_rule) {
+		s_ino = s_dev = 0;
+	} else {
+		if (lids_get_info(buffer, &s_ino, &s_dev, 0) < 0)
+			goto exit;
+	}
+	error = -5;
+	/* get the object */
+	if (lids_get_info(p, &o_ino, &o_dev, type) < 0)
+		goto exit;
+
+	/* get the port scale for CAP_NET_BIND_SERVICE*/
+	error = -6;
+	if (type == LIDS_CAP && o_dev == CAP_NET_BIND_SERVICE)
+		/* FIXME: no guarantee that time_t and int are of
+		 * the same size, this needs to be refined to data
+		 * size independence
+		 */
+		if (lids_str2data(p, port, LIDS_PORT_ITEM) < 0)
+			goto exit;
+
+	/* get the port scale for CAP_NET_BROADCAST */
+	error = -7;
+	if (type == LIDS_CAP && o_dev == CAP_NET_BROADCAST)
+		if (lids_str2data(p, cport, LIDS_PORT_ITEM) < 0)
+			goto exit;
+
+	/* get the time here */
+	error = -8;
+	if (lids_str2data(q, time, LIDS_TIME_ITEM) < 0)
+		goto exit;
+	if (is_default_rule)
+		lids_add_inode(o_ino, o_dev, type, data);
+	else {
+		lids_add_acl(s_ino, s_dev, s_file, o_ino, o_dev,
+			     type, inherit, data, time, port, cport);
+	}
+	error = 0;
+exit:
+	return error;
+}
+
+/**
+ * lids_attach_task_acl - get the current task's ACL and attach it
+ *			  to the task. calculate the inheritable ACL
+ *			  from the parent as well.
+ *			  Return 0 if success. Otherwise, return -1.
+ * @task - the target task
+ *
+ * This is called through for_each_task() macro that is normally
+ * called with the tasklist spinlock held then closed with the
+ * spinlock released. Thus, to use any semaphore inside this function,
+ * we must first release the spinlock (read_unlock(&tasklist_lock) and
+ * then hold the spinlock (read_lock(&tasklist_lock) again as soon
+ * as we can get the semaphore. (Is it OK??)
+ */
+
+static int
+lids_attach_task_acl(struct task_struct *task)
+{
+	struct lids_task_acl current_acl, task_acl, computed_acl, *p = NULL;
+	struct lids_sys_acl *new_sys_acl = NULL;
+	struct dentry *dentry = NULL;
+	struct mm_struct *mm;
+	struct vm_area_struct *vma;
+
+	task_lock(task);
+	/* ignore init or other tasks with ppid == 0 */
+	if ((task->pid == 1) || (task->p_pptr->pid == 0)) {
+		task_unlock(task);
+		return 0;
+	}
+	mm = task->mm;
+	task_unlock(task);
+
+	if (!mm)
+		return 0;
+
+	read_unlock(&tasklist_lock);
+
+	/* Get dentry of the task, if any */
+	down_read(&mm->mmap_sem);
+	read_lock(&tasklist_lock);
+	vma = mm->mmap;
+	while (vma) {
+		if ((vma->vm_flags & VM_EXECUTABLE) && vma->vm_file) {
+			dentry = dget(vma->vm_file->f_dentry);
+			break;
+		}
+		vma = vma->vm_next;
+	}
+	up_read(&mm->mmap_sem);
+
+	if (!dentry)
+		return 0;
+
+	LIDS_DBG("%s:##### pid %i ppid %d  \n", __FUNCTION__, task->pid,
+		 task->p_pptr->pid);
+
+	/*
+	 * if parent is sandboxed, sandbox the task in
+	 * the same sandbox as well.
+	 */
+	task_lock(task->p_pptr);
+	if (lids_sandboxed(task->p_pptr)) {
+		struct lids_task_acl src, dst;
+
+		dput(dentry);
+		task_unlock(task->p_pptr);
+		lids_get_task_acl(&src, task->p_pptr);
+		lids_get_task_acl(&current_acl, task);
+		if (lids_task_acl_deep_copy(&dst, &src) < 0) {
+			LIDS_DBG("lids_task_acl_deep_copy error!\n");
+			return -1;
+		}
+		lids_set_task_acl(&dst, task);
+		lids_free_lids_task_acl(&current_acl);
+		return 0;
+	}
+	task_unlock(task->p_pptr);
+
+	/* check if this program is protected or not */
+	if (lids_protected(dentry, LIDS_APPEND)) {
+		lids_get_task_acl(&current_acl, task);
+		new_sys_acl = lids_search_acl(dentry->d_inode->i_ino,
+					      dentry->d_inode->i_dev,
+					      lids_current);
+#ifdef CONFIG_LIDS_TDE
+		if (new_sys_acl &&
+		    test_bit(LIDS_SANDBOX, &(new_sys_acl->socket))) {
+			new_sys_acl->sandbox = 1;
+			new_sys_acl->flags =
+				new_sys_acl->flags |
+				(lids_cap_val &  CAP_LIDS_SANDBOX_EFF_SET);
+		}
+#endif
+		/* task and its parent do not have acl */
+		task_lock(task->p_pptr);
+		if (!new_sys_acl && !task->p_pptr->lids_sys_acl) {
+			/* if it got acl, free the acl */
+			task_unlock(task->p_pptr);
+			task_lock(task);
+			if (task->lids_sys_acl) {
+				task->lids_cap = 0x0UL;
+				task->lids_sys_acl = NULL;
+				lids_free_lids_task_acl(&current_acl);
+			}
+			task_unlock(task);
+
+			dput(dentry);
+			return 0;
+		}
+
+		/* get its parent's acl */
+		if (task->p_pptr->lids_sys_acl) {
+			task_unlock(task->p_pptr);
+			lids_get_task_acl(&task_acl, task->p_pptr);
+			p = &task_acl;
+		} else
+			task_unlock(task->p_pptr);
+
+		if (lids_compute_acls(p, new_sys_acl, &computed_acl, 1) < 0) {
+			dput(dentry);
+			return -EPERM;
+		}
+
+		LIDS_DBG("LIDS: protected pid %d %d  get acl\n", task->pid,
+			 task->p_pptr->pid);
+
+		lids_set_task_acl(&computed_acl, task);
+		lids_free_lids_task_acl(&current_acl);
+	} else {
+		/*
+		 * if the dentry is not protected
+		 * reset all the privileges
+		 */
+		task_lock(task);
+		if (task->lids_sys_acl) {
+			task_unlock(task);
+			lids_get_task_acl(&current_acl, task);
+			lids_get_task_acl(&task_acl, task->p_pptr);
+			if (lids_compute_acls(&task_acl, NULL, &computed_acl,
+					      0) < 0) {
+				dput(dentry);
+				return -EPERM;
+			}
+
+			if (computed_acl.lids_sys_acl->flags) {
+				computed_acl.lids_sys_acl->flags = 0x0UL;
+				computed_acl.lids_cap = 0x0UL;
+			}
+
+			if (computed_acl.lids_sys_acl->socket != 0)
+				lids_set_task_acl(&computed_acl, task);
+			else {
+				/* clean the task */
+				task_lock(task);
+				task->lids_cap = 0x0UL;
+				task->lids_sys_acl = NULL;
+				task_unlock(task);
+				lids_free_lids_task_acl(&computed_acl);
+			}
+
+			lids_free_lids_task_acl(&current_acl);
+		} else
+			task_unlock(task);
+	}
+
+	dput(dentry);
+	return 0;
+}
+
+#ifdef CONFIG_LIDS_PROTECT_PWD
+/**
+ * lids_protect_file - protect 'filename' in 'prot' mode.
+ *		       Return 0 if success. Otherwise, return -1.
+ * @filename - file to be protected
+ * @prot - protection mode
+ * @data - LIDS secure list
+ *
+ * This was rewritten from 'init_add_file()'.
+ */
+static int
+lids_protect_file(char *filename, int prot, _lids_data_t *data)
+{
+	int error = 0;
+	struct dentry *dentry;
+	struct nameidata nd;
+
+        if (path_init(filename, LOOKUP_FOLLOW | LOOKUP_POSITIVE, &nd))
+            error = path_walk(filename, &nd);
+
+	if (error)
+		goto out;
+
+	dentry = nd.dentry;
+
+	if (IS_ERR(dentry)) {
+		error = PTR_ERR(dentry);
+		goto out1;
+	}
+
+	if (!dentry || !(dentry->d_inode)) {
+		error = -ENOENT;
+		goto out1;
+	}
+
+	lids_add_inode(dentry->d_inode->i_ino, dentry->d_inode->i_dev,
+		       prot, data);
+
+out1:
+	path_release(&nd);
+out:
+	return error;
+}
+#endif /* CONFIG_LIDS_PROTECT_PWD */
+
+/**
+ * lids_cap_init - read a capability value info from a given buffer,
+ *		   and set the corresponding value into lids_conf_cap.
+ *		   Return 0 on success. Otherwise, return a negative
+ *		   value on failure.
+ * @buffer - buffer holding a capability value info
+ *
+ * Possible capability value info formats:
+ *	"+number:cap_name"
+ *	"-number:cap_name"
+ */
+static int
+lids_cap_init(char *buffer)
+{
+	char *p;
+	int flag;
+	int error = 0;
+	error = -1;
+	p = memscan(buffer, ':', strlen(buffer));
+	if (((unsigned long) (p - buffer)) == strlen(buffer))
+		goto exit;
+
+	*p = '\0';
+	flag = simple_strtoul(buffer + 1, 0, 0);
+	error = 0;
+	if (buffer[0] == '+')
+		cap_raise(lids_conf_cap, flag);
+	else if (buffer[0] == '-')
+		cap_lower(lids_conf_cap, flag);
+	else
+		error = -2;
+exit:
+	return error;
+}
+
+/**
+ * lids_read_cap - read a LIDS capability file (lids.<LIDS_state>.cap) in
+ *		   accordance with the 'state'.
+ *		   Return 0 if success. Otherwise, return a negative value.
+ * @state - LIDS state indicating which lids.<LIDS_state>.cap should be
+ *	    read
+ */
+static int
+lids_read_cap(int state)
+{
+	struct file *filp = NULL;
+	char buffer[1024], *p, *q;
+	mm_segment_t oldfs;
+	int bytes;
+	int error = 0;
+	int start = 0, finished = 0;
+
+	filp = filp_open(lids_cap_file[state], O_RDONLY, 0);
+
+	if (IS_ERR(filp) || (filp == NULL)) {
+		error = PTR_ERR(filp);
+		printk("LIDS: Error opening capability "
+		       "file with state %d,  Does it exist?\n",
+		       state);
+		goto out1;
+	}
+
+	if (filp->f_op->read == NULL) {
+		error = -EINVAL;
+		printk("LIDS: The capabiltiy file can not be read [state %d]\n",
+		       state);
+		/*
+		   if (lids_load) goto err_panic ;
+		 */
+		goto out2;
+	}
+
+	while (!finished) {
+		filp->f_pos = start;
+		oldfs = get_fs();
+		set_fs(KERNEL_DS);
+		bytes = filp->f_op->read(filp, buffer, 1024, &filp->f_pos);
+		set_fs(oldfs);
+
+		q = buffer;
+
+		if (bytes < 1024) {
+			finished = 1;
+			q[bytes++] = '\n';
+		}
+
+		/* Now read 1024 bytes into buffer */
+		/* analyze the buffer */
+		while (bytes && (p = memscan(q, '\n', bytes)) != q + bytes) {
+			*p++ = '\0';
+			start += (int) (p - q);
+			bytes -= (int) (p - q);
+			while (*q == '\r')
+				q++;	/* hmmm... */
+			if (*q == '-' || *q == '+')
+				if (lids_cap_init(q) < 0) {
+					error = -EINVAL;
+					printk("LIDS: error in adding [%s] "
+					       "to the kernel\n", q);
+					goto out2;
+				}
+			q = p;
+		}
+
+		if (bytes == 1024) {
+			printk("LIDS: Line too long in cap file [state %d]\n",
+			       state);
+			error = -EINVAL; /* if the line contains no '\n' */
+			goto out2;
+		}
+	}
+
+	LIDS_DBG("lids_read_cap:lids_conf_cap = %x\n", lids_conf_cap);
+out2:
+	filp_close(filp, NULL);
+out1:
+	return error;
+}
+
+/**
+ * lids_read_pw - read the lids password generated by "lidsconf -P"
+ *		  into kernel.
+ *		  Return 0 if success. Otherwise, return a negative value.
+ */
+#ifdef CONFIG_LIDS_ALLOW_SWITCH
+static int
+lids_read_pw(void)
+{
+	struct file *filp = NULL;
+	char buffer[LIDS_PW_LEN];
+	mm_segment_t oldfs;
+	int bytes;
+	int error = 0;
+
+	filp = filp_open(LIDS_PW_FILE, O_RDONLY, 0);
+	if (IS_ERR(filp) || (filp == NULL)) {
+		error = PTR_ERR(filp);
+		printk("LIDS: Error opening passwd file " LIDS_PW_FILE
+		       ". Does it exist?\n");
+		goto out1;
+	}
+
+	if (filp->f_op->read == NULL) {
+		error = -EINVAL;
+		printk("LIDS: The file " LIDS_PW_FILE " can not be read\n");
+		goto out2;
+	}
+
+	/* Now read LIDS_PW_LEN bytes from postion "StartPos" */
+	filp->f_pos = 0;
+	oldfs = get_fs();
+	set_fs(KERNEL_DS);
+	bytes = filp->f_op->read(filp, buffer, LIDS_PW_LEN, &filp->f_pos);
+	set_fs(oldfs);
+
+	if (bytes < LIDS_PW_LEN) {
+		error = -EINVAL;
+		goto out2;
+	}
+
+	memcpy(lids_pw, buffer, LIDS_PW_LEN);
+out2:
+	filp_close(filp, NULL);
+out1:
+	return error;
+}
+#endif
+
+/**
+ * lids_read_acl - read a LIDS ACLs file (lids.<LIDS_state>.conf) in
+ *		   accordance with the 'state'.
+ *		   Return 0 if success. Otherwise, return a negative value.
+ * @state - LIDS state indicating which lids.<LIDS_state>.conf should be
+ *	    read
+ * @data - the main data table
+ */
+static int
+lids_read_acl(int state, _lids_data_t * data)
+{
+	struct file *filp = NULL;
+	char buffer[1024], *p, *q;
+	mm_segment_t oldfs;
+	int bytes;
+	int error = 0;
+	int start = 0;
+	int finished = 0;
+
+	filp = filp_open(lids_acl_file[state], O_RDONLY, 0);
+	if (IS_ERR(filp) || (filp == NULL)) {
+		error = PTR_ERR(filp);
+		printk(KERN_ALERT "LIDS: Error opening acl file [state %d], "
+		       "Does it exist?\n", state);
+		goto out1;
+	}
+
+	if (filp->f_op->read == NULL) {
+		error = -EINVAL;
+		printk(KERN_ALERT "LIDS: The acl file can not be read "
+		       "[state %d]\n", state);
+		goto out2;
+	}
+
+	/* Now read 1024 bytes from postion "StartPos" */
+	while (!finished) {
+		filp->f_pos = start;
+		oldfs = get_fs();
+		set_fs(KERNEL_DS);
+		bytes = filp->f_op->read(filp, buffer, 1024, &filp->f_pos);
+		set_fs(oldfs);
+
+		q = buffer;
+
+		if (bytes < 1024) {
+			finished = 1;
+			q[bytes++] = '\n';
+		}
+
+		while (bytes && (p = memscan(q, '\n', bytes)) != q + bytes) {
+			*p++ = '\0';
+			LIDS_DBG(" read_file : line=->%s<-\n", q);
+			start += (int) (p - q);
+			bytes -= (int) (p - q);
+			while (*q == '\r')
+				q++;	/* hmmm... */
+			if (*q && (*q != '#') &&
+			    ((error = lids_init_add_file(q, data)) < 0)) {
+				printk(KERN_ALERT "LIDS: error in adding [%s] "
+				       "to the kernel\n", q);
+				goto out3;
+			}
+			q = p;
+		}
+
+		/* if the line contains no '\n' */
+		if (bytes == 1024) {
+			printk(KERN_ALERT "LIDS: Line too long in acl file "
+			       "[state %d]\n", state);
+			error = -ENAMETOOLONG;
+			goto out3;
+		}
+	}
+out3:
+	memset(buffer, '\0', 1024);
+out2:
+	filp_close(filp, NULL);
+out1:
+	return error;
+}
+
+/**
+ * lids_read_lids_ini - read the LIDS init file (/etc/lids/lids.ini).
+ *			Return 0 on success. Otherwise, return a negative
+ *			value.
+ */
+static int
+lids_read_lids_ini(void)
+{
+	struct file *filp = NULL;
+	char buffer[1024], *p, *q;
+	mm_segment_t oldfs;
+	int bytes, error = 0;
+
+	filp = filp_open(LIDS_INI_FILE, O_RDONLY, 0);
+	if (IS_ERR(filp) || (filp == NULL)) {
+		error = PTR_ERR(filp);
+		printk("LIDS: Checking lids.ini file error, does it exist?\n");
+		goto out1;
+	}
+
+	if (filp->f_op->read == NULL) {
+		error = -EINVAL;
+		printk("LIDS: The file  can not be read\n");
+		goto out2;
+	}
+
+	/* Now read 1024 bytes into buffer */
+	filp->f_pos = 0;
+	oldfs = get_fs();
+	set_fs(KERNEL_DS);
+	bytes = filp->f_op->read(filp, buffer, 1024, &filp->f_pos);
+	set_fs(oldfs);
+
+	q = buffer;
+
+	/* analyze the buffer */
+	while (bytes && (p = memscan(q, '\n', bytes)) != q + bytes) {
+		*p++ = '\0';
+		/*
+		   printk("read_file : line=->%s<-\n", q);
+		 */
+		bytes -= (int) (p - q);
+		while (*q == '\r')
+			q++;	/* hmmm... */
+		if (*q == '\0' || *q == '#') {
+			q = p;
+			continue;
+		}
+		if (strncmp(q, "ACL_DISCOVERY=", 14)) {
+			q = p;
+			continue;
+		}
+		lids_acl_discovery = simple_strtoul(q + 14, NULL, 0);
+		if (lids_acl_discovery)
+			lids_flag_raise(lids_flags,
+					LIDS_FLAGS_ACL_DISCOVERY_ON);
+		printk(KERN_INFO "LIDS_INFO: Acl discovery mode %s\n",
+		       lids_acl_discovery ? "on" : "off");
+		break;
+	}
+
+out2:
+	filp_close(filp, NULL);
+out1:
+	return error;
+}
+
+/* write the data out to buffer for eventual transfer to user-space */
+inline void __write_record( struct key_entry *rec, char *buf, int off, int amt )
+{
+        struct usr_key_entry the_usr_key_entry;
+        memcpy( the_usr_key_entry.key, rec->key, 16 );
+        the_usr_key_entry.ino = rec->ino;
+        the_usr_key_entry.dev = kdev_t_to_nr(rec->dev);
+        memcpy( buf, (&the_usr_key_entry) + off, amt );
+}
+
+/***********************************************************************
+ *
+ *	lids_proc_read_keys
+ *
+ *      proc fs function to return the list of secret keys for binaries.
+ *      this proc file has to be protected by lids rules so that only the
+ *      privileged server can read it.
+ */
+
+ /* be stupid & get EIO */
+#define __check_tiny_max(part) \
+        if (unlikely((part) > max_to_read )) { \
+                len = -EIO; \
+                printk( "%i < %i record length not supported!", max_to_read, rec_len ); \
+                goto proc_read_out; \
+        }
+
+/* increment the "file" position */
+#define __move_key_file_pos \
+        do { \
+                pos += rec_len; \
+                k_ent_lh = k_ent_lh->next; \
+        } while(0)
+
+int lids_proc_read_key(char *buf, char **start, off_t offset,
+                int max_to_read, int *eof, void *data)
+{
+        int pos = 0;         /* virtual position in "file" */
+        int len = 0;         /* amount actually written int0 window */
+        struct list_head *k_ent_lh = 0;
+        struct key_entry *k_ent = 0;
+        int win_end = offset + max_to_read;  /* pos of byte after window */
+        int part = 0;        /* offset partial record beg/end of window */
+        int amt = 0;         /* length partial record beg/end of window */
+        int rec_len = sizeof(struct usr_key_entry);
+
+        if ( list_empty(&lids_key_list) ) {
+                printk("list empty - %i keys\n", lids_key_list_count );
+                goto proc_read_out;
+        }
+        /* printk("max to read %i\n", max_to_read); */
+        if ( max_to_read == 0 )
+                goto proc_read_out;
+        k_ent_lh = lids_key_list.next;
+
+        /* printk("offset %li\n", offset); */
+        if ( offset ) {     /* multipage read */
+                /* read and discard up to beginning of window */
+                while ( k_ent_lh != &lids_key_list && pos + rec_len <= offset )
+                        __move_key_file_pos;
+                part = offset - pos;
+                if ( part > 0 ) {  /* window starts partway thru record */
+                        amt = rec_len - part;
+                        __check_tiny_max( part );
+                        k_ent = list_entry( k_ent_lh, struct key_entry, list);
+                        __write_record( k_ent, buf, part, amt );
+                        len += amt;
+                        __move_key_file_pos;
+                }
+        }
+        /* write whole records in window */
+        while ( k_ent_lh != &lids_key_list && pos + rec_len <= win_end ) {
+                k_ent = list_entry( k_ent_lh, struct key_entry, list );
+                __write_record( k_ent, buf+len, 0, rec_len );
+                len += rec_len;
+                __move_key_file_pos;
+        }
+        if ( k_ent_lh == &lids_key_list ) {
+                *eof = 1;
+                goto proc_read_out;
+        }
+        amt = win_end - pos;
+        if ( amt > 0 ) {  /* window ends partway thru record */
+                __check_tiny_max(amt);
+                k_ent = list_entry( k_ent_lh, struct key_entry, list);
+                __write_record( k_ent, buf, 0, amt );
+                len += amt;
+        }
+        *start = buf + len;
+proc_read_out:
+        return len;
+}
+
+/***********************************************************************
+ *
+ *	lids_proc_key_create
+ *
+ *	initialize the proc entries for reading per-process keys
+ */
+int lids_proc_key_create(void)
+{
+        int rc = 0;
+
+        spin_lock( &lids_proc_lock );
+        if ( lids_proc_key == NULL ) {
+                lids_proc_key = (void*)1;  /* avoid re-entering on SMP */
+                spin_unlock( &lids_proc_lock );
+                lids_proc_dir = proc_mkdir( "lids", 0 );
+                if ( lids_proc_dir ) {
+                        lids_proc_key = create_proc_read_entry( "keys", S_IWUSR |S_IRUSR,
+                                        lids_proc_dir, lids_proc_read_key, 0 );
+                        if ( lids_proc_key ) {
+                                lids_proc_key->uid = 0;
+                                lids_proc_key->gid = 0;
+                        } else {
+                                rc = -ENOMEM;
+                                remove_proc_entry( "lids", 0 );
+                        }
+                } else {
+                        rc = -ENOMEM;
+                }
+        }
+        spin_unlock( &lids_proc_lock );
+        printk( "LIDS PROC KEY INITIALIZED\n" );
+        return rc;
+}
+
+/***********************************************************************
+ *
+ *	lids_proc_key_remove
+ *
+ *	remove the proc entries for reading per-process keys, which werer
+ *      created by lids_proc_key_create
+ *
+ */
+void lids_proc_key_remove(void)
+{
+        remove_proc_entry( "keys", lids_proc_dir );
+        remove_proc_entry( "lids", 0 );
+        lids_proc_dir = 0;
+        lids_proc_key = 0;
+}
+
+/**
+ * lids_init - initialize LIDS.
+ *	       Return 0 on success. Return a negative value on failure.
+ *	       In some cases, call panic() to halt the kernel.
+ *
+ * This function reads LIDS configurations (lids.conf, lids.cap,
+ * lids.postboot.conf, etc.) and adds the related info (inode,
+ * ACLs) to the main data table (lids_data).
+ *
+ * This function is called by do_lids_setup() in init/main.c when LIDS
+ * is first initialized, or by lids_load_conf() when LIDS configurations
+ * are reloaded or when LIDS moves to a different state (BOOT, POSTBOOT, or
+ * SHUTDOWN, etc.).
+ */
+int
+lids_init(void)
+{
+	int error = 0;
+	_lids_data_t *data = &lids_data[(lids_current & 1) ^ 1];
+#ifndef CONFIG_LIDS_ALLOW_ANY_PROG_SWITCH
+	struct dentry *dentry;
+	struct nameidata nd;
+#endif
+
+	LIDS_DBG("into lids_init_..\n");
+
+	/* read the lids.ini first when it is in LIDS_STATE_BOOT */
+	if (lids_state == LIDS_STATE_BOOT)
+		lids_read_lids_ini();
+
+	/* reset fast guess table */
+	memset(data->fastguess, 0, sizeof (data->fastguess));
+
+#ifndef CONFIG_LIDS_ALLOW_ANY_PROG_SWITCH
+	/* get the inode# and device# of lidsadm */
+	if (path_init(LIDS_ADM_PATH, LOOKUP_FOLLOW | LOOKUP_POSITIVE, &nd))
+            error = path_walk(LIDS_ADM_PATH, &nd);
+
+	if (error)
+		goto out;
+
+	dentry = nd.dentry;
+
+	if (IS_ERR(dentry) || (!dentry)) {
+		printk(KERN_ALERT "LIDS : " LIDS_ADM_PATH " not found \n");
+		lidsadm.ino = 0;
+		lidsadm.dev = 0;
+	} else {
+		if (!dentry->d_inode ||
+		    !dentry->d_inode->i_dev || !dentry->d_inode->i_ino) {
+			printk("LIDS: something wrong with "
+			       LIDS_ADM_PATH "\n");
+			lidsadm.ino = 0;
+			lidsadm.dev = 0;
+		} else {
+			lidsadm.ino = dentry->d_inode->i_ino;
+			lidsadm.dev = dentry->d_inode->i_dev;
+		}
+	}
+	path_release(&nd);
+#endif
+	/* read /dev/tty */
+	lids_read_dev_tty();
+
+	/* read global ACLs */
+	error = lids_read_acl(LIDS_STATE_GLOBAL, data);
+	if (error) {
+		printk(KERN_ALERT "LIDS: Read GLOBAL ACL file error\n");
+		if (lids_load)
+			goto lids_panic;	/* Or do something else */
+		goto out;
+	}
+
+	/* read ACLs based on state */
+	error = lids_read_acl(lids_state, data);
+	if (error) {
+		printk(KERN_ALERT "LIDS: Read %s state ACL file error\n",
+		       lids_state_name[lids_state - 1]);
+		if (lids_load)
+			goto lids_panic;	/* Or do something else */
+		goto out;
+	}
+
+#ifdef CONFIG_LIDS_ALLOW_SWITCH
+	/* read the password now */
+	if (lids_read_pw()) {
+		printk(KERN_ALERT "LIDS: Read password file error\n");
+		error = -8;
+		goto lids_panic;
+	}
+#ifdef CONFIG_LIDS_PROTECT_PWD
+	/* protect the passwd file */
+	if (lids_protect_file(LIDS_PW_FILE, LIDS_DENY, data) < 0)
+		printk(KERN_WARNING "LIDS: Implicit %s protection failed!\n",
+		       LIDS_PW_FILE);
+#endif
+#endif	/* CONFIG_LIDS_ALLOW_SWITCH */
+
+	if (!lids_sort_inodes(data)) {
+		printk(KERN_ALERT "LIDS: Aieeh, duplicate inode entry in %s"
+		       "state ACL file\n", lids_state_name[lids_state - 1]);
+		error = -6;
+		if (lids_load)
+			goto lids_panic;	/* Or do something else */
+		goto out;
+	}
+
+	if (!lids_sort_acls(data)) {
+		printk(KERN_ALERT "LIDS: Aieeh, duplicate source acl entry "
+		       "in %s state ACL file\n",
+		       lids_state_name[lids_state - 1]);
+		error = -7;
+		if (lids_load)
+			goto lids_panic;	/* Or do something else */
+		goto out;
+	}
+
+	/* read global capability first */
+	if (lids_read_cap(LIDS_STATE_GLOBAL)) {
+		printk(KERN_ALERT "LIDS: Read GLOBAL capability file error\n");
+		error = -9;
+		goto lids_panic;
+	}
+
+	/* read capability based on state */
+	if (lids_read_cap(lids_state)) {
+		printk(KERN_ALERT "LIDS: Read %s state capability file error\n",
+		       lids_state_name[lids_state - 1]);
+		error = -9;
+		goto lids_panic;
+	}
+#ifdef CONFIG_LIDS_SA_THROUGH_NET
+	/* read network parameter from lids.net */
+	if (lids_read_net()) {
+		printk(KERN_ALERT "LIDS: Read mail parameter error\n");
+		error = -10;
+		goto lids_panic;
+	}
+#endif
+
+	if (lids_state == LIDS_STATE_BOOT) {
+		lids_cap_val = lids_conf_cap;
+		printk(KERN_INFO "LIDS: GLOBAL and %s state Config. files "
+		       "loaded\n", lids_state_name[lids_state - 1]);
+		printk(KERN_INFO "LIDS: Enter %s state\n",
+		       lids_state_name[lids_state - 1]);
+	}
+
+	/* for LIDS data table debugging */
+#if 0
+	printk("read_file : finish=%d ret %d\n", finished, error);
+	for (start = 0; start < data->last_secure; start++) {
+		struct lids_sys_acl *this_sys_acl;
+		struct lids_acl *this_acl;
+		int i;
+
+		this_sys_acl = (struct lids_sys_acl *) &(data->s_acl[start]);
+
+		printk("-----------\ndefault: %ld--%d--%d-\n",
+		       data->secure[start].ino, data->secure[start].dev,
+		       data->secure[start].type);
+		for (i = 0; i < 32; i++)
+			LIDS_DBG("CAPABILITY [%d]:%d,TIME %ld-%ld\t", i,
+				 this_sys_acl->cap[i].inherit,
+				 this_sys_acl->cap[i].time[0][0],
+				 this_sys_acl->cap[i].time[0][1]);
+
+		this_acl = this_sys_acl->lids_acl;
+		while (this_acl != NULL) {
+			LIDS_DBG("----------\nobject:\tthis_acl=%ld, "
+				 "%d,type=%d,inherit=%d,from %ld to %ld\n",
+				 this_acl->ino, this_acl->dev, this_acl->type,
+				 this_acl->inherit, this_acl->from_time,
+				 this_acl->to_time);
+			this_acl = this_acl->next;
+		}
+	}
+#endif
+        if ( lids_proc_key_create() )
+        {
+            printk("LIDS KEY: create proc key files error\n");
+            error = -11;
+            goto lids_panic;
+        }
+
+	LIDS_DBG("written to index %ld\n", (lids_current & 1) ^ 1);
+	printk("LIDS: Statistics: %d objects, %d source ACLS, "
+	       "%d object ACLs, capability = %x\n", data->last_secure,
+	       data->last_s_acl, data->last_o_acl, lids_conf_cap);
+	lids_current++;
+	LIDS_DBG("lids_current=%ld index=%ld\n", lids_current,
+		 lids_current & 1);
+out:
+	return error;
+
+lids_panic:
+	panic("LIDS: Cannot initialize the lids system, return code %d", error);
+}
+
+/*
+ * LIDS system control related functions
+ */
+static int number_failed = 0;
+static int wait_after_fail = 0;
+#ifdef CONFIG_LIDS_ALLOW_SWITCH
+static struct timer_list fail_timer;
+
+/* called by timer */
+static void
+reenable_sysctl(unsigned long user_data)
+{
+	number_failed = 0;
+	wait_after_fail = 0;
+}
+#endif
+
+/**
+ * lids_load_conf - a wrapper to load LIDS configurations.
+ *		    Return 0 on success. Otherwise, return a negative value.
+ *
+ * This function calls lids_init() to load/reload LIDS configurations
+ * (lids.conf, lids.cap, lids.postboot.conf, etc.), and lids_attach_task_acl()
+ * to attach/reattach ACLs to the running processes.
+ */
+static int
+lids_load_conf(void)
+{
+	int old_lids_local_on;
+	int old_lids_local_pid;
+	int error;
+	_lids_data_t *data = &lids_data[(lids_current & 1) ^ 1];
+	struct task_struct *p;
+
+	old_lids_local_on = lids_local_on;
+	old_lids_local_pid = lids_local_pid;
+	if (lids_load && lids_local_load) {
+		LIDS_DBG("Let's give lidsadm (pid %i) the right to read "
+			 "the conf\n", current->pid);
+		lids_local_pid = current->pid;
+		lids_local_on = 0;
+	}
+	data->last_secure = 0;
+	data->last_s_acl = 0;
+	data->last_o_acl = 0;
+
+	error = lids_init();
+	if (error) {
+		return -1;
+	}
+
+	printk(KERN_INFO "LIDS: Attaching ACL to Processes\n");
+
+	read_lock(&tasklist_lock);
+	for_each_task(p) {
+		error = lids_attach_task_acl(p);
+		if (error) {
+			read_unlock(&tasklist_lock);
+			return -1;
+		}
+	}
+	read_unlock(&tasklist_lock);
+
+	printk(KERN_INFO "LIDS: GLOBAL and %s state Config. files %s\n",
+	       lids_state_name[lids_state - 1],
+	       lids_first_time ? "loaded" : "reloaded");
+
+	if (lids_state <= LIDS_STATE_SHUTDOWN) {
+		printk(KERN_INFO "LIDS: Switch to %s state\n",
+		       lids_state_name[lids_state - 1]);
+	} else {
+		printk(KERN_INFO "LIDS: Invalid State %d\n", lids_state);
+	}
+
+	lids_local_pid = old_lids_local_pid;
+	lids_local_on = old_lids_local_on;
+
+	return 0;
+}
+
+/**
+ * lids_process_flags - process LIDS flags.
+ *			Return 0 on success. Otherwise, return a negative
+ *			value.
+ * @flags - LIDS flags.
+ *
+ * This function is called by lids_proc_locks_sysctl(). It mainly processes
+ * LIDS flags (LIDS, LIDS_GLOBAL, TPE, -I, etc.) passed by 'lidsadm' from
+ * the user space.
+ */
+static int
+lids_process_flags(lids_flags_t flags)
+{
+	int error = 0;
+
+	LIDS_DBG("Process flags %#0x\n", flags);
+	LIDS_DBG("lids_flag_raised(flags,LIDS_FLAGS_LIDS_ON))=%i\n",
+		 lids_flag_raised(flags, LIDS_FLAGS_LIDS_ON));
+	LIDS_DBG("lids_flag_raised(flags,LIDS_FLAGS_LIDS_LOCAL_ON)=%i\n",
+		 lids_flag_raised(flags, LIDS_FLAGS_LIDS_LOCAL_ON));
+	LIDS_DBG("lids_flag_raised(flags,LIDS_FLAGS_RELOAD_CONF)=%i\n",
+		 lids_flag_raised(flags, LIDS_FLAGS_RELOAD_CONF));
+	LIDS_DBG("lids_flag_raised(flags,LIDS_FLAGS_INIT)=%i\n",
+		 lids_flag_raised(flags, LIDS_FLAGS_INIT));
+	LIDS_DBG("lids_flag_raised(flags,LIDS_FLAGS_POSTBOOT)=%i\n",
+		 lids_flag_raised(flags, LIDS_FLAGS_POSTBOOT));
+	LIDS_DBG("lids_flag_raised(flags,LIDS_FLAGS_SHUTDOWN)=%i\n",
+		 lids_flag_raised(flags, LIDS_FLAGS_SHUTDOWN));
+	LIDS_DBG("lids_flag_raised(flags,LIDS_FLAGS_ACL_DISCOVERY_ON)=%i\n",
+		 lids_flag_raised(flags, LIDS_FLAGS_ACL_DISCOVERY_ON));
+
+#ifdef CONFIG_LIDS_TPE
+	if (lids_tpe != (lids_flag_raised(flags, LIDS_FLAGS_TPE_ON) != 0)) {
+		/* if TPE mode change request */
+		lids_tpe = (lids_flag_raised(flags, LIDS_FLAGS_TPE_ON) != 0);
+		lids_security_alert("LIDS TPE mode %s",
+				    lids_tpe ? "on" : "off");
+		if (lids_tpe)
+			lids_flag_raise(lids_flags, LIDS_FLAGS_TPE_ON);
+		else
+			lids_flag_lower(lids_flags, LIDS_FLAGS_TPE_ON);
+	}
+#else
+	if (lids_flag_raised(flags, LIDS_FLAGS_TPE_ON)) {
+		lids_security_alert("Attempt to switch TPE mode on "
+				    "(feature disabled)");
+		return -1;
+	}
+#endif
+
+	/* if the kernel is sealed, enter "POSTBOOT" */
+	if (lids_first_time) {
+		lids_state = LIDS_STATE_POSTBOOT;
+		error = lids_load_conf();
+		if (!error) {
+			lids_flag_raise(lids_flags, LIDS_FLAGS_POSTBOOT);
+			lids_flag_lower(lids_flags, LIDS_FLAGS_INIT);
+		}
+
+                /* AJM: Reload ACLs for init
+                 * When switching from BOOT to POSTBOOT the init process loses
+                 * privileges. This happens because there are two seperate sets
+                 * of ACLs in LIDS:
+                 *
+                 *     1 Global ACLs (no subject), which are stored in a
+                 *       single table and used for all running processes
+                 *     2 Task ACLs, which are stored individually for
+                 *       each running task
+                 *
+                 * When switching LIDS states the global ACLs get reloaded. The
+                 * task ACLs for running processes do not change. This can
+                 * result in running tasks loosing privileges if the new global
+                 * ACLs are more restrictive.
+                 *
+                 * To work around this issue the ACLs for the running init
+                 * process are reloaded upon switching to the POSTBOOT state.
+                */
+                struct task_struct *task = find_task_by_pid(1);
+                if (task) {
+                    /* get the process binary */
+                    struct mm_struct *mm;
+                    struct vm_area_struct *vma;
+
+                    task_lock(task);
+                    mm = task->mm;
+                    if (mm)
+                        atomic_inc(&mm->mm_users);
+                    task_unlock(task);
+
+                    if (mm) {
+                        down_read(&mm->mmap_sem);
+                        vma = mm->mmap;
+                        while (vma) {
+                            if ((vma->vm_flags & VM_EXECUTABLE) && vma->vm_file) {
+                                struct dentry *dentry;
+                                struct lids_sys_acl *new_sys_acl;
+                                struct lids_task_acl current_acl;
+                                struct lids_task_acl computed_acl;
+
+                                dentry = dget(vma->vm_file->f_dentry);
+
+                                lids_get_task_acl(&current_acl, task);
+                                new_sys_acl = lids_search_acl(dentry->d_inode->i_ino,
+                                                              dentry->d_inode->i_dev,
+                                                              lids_current);
+                                if (lids_compute_acls(&current_acl, new_sys_acl,
+                                                      &computed_acl, 1) < 0) {
+                                    printk("LIDS: Couldn't compute new ACL for init\n");
+                                    break;
+                                }
+                                printk("LIDS: Loading new ACLs for init\n");
+                                lids_set_task_acl(&computed_acl, task);
+                                lids_free_lids_task_acl(&current_acl);
+                                break;
+                            }
+                            vma = vma->vm_next;
+                        }
+                        up_read(&mm->mmap_sem);
+                        mmput(mm);
+                    }
+                } else {
+                    printk("LIDS: No init to reload ACLs for\n");
+                }
+
+		goto out;
+	}
+
+	if (lids_acl_discovery !=
+	    (lids_flag_raised(flags, LIDS_FLAGS_ACL_DISCOVERY_ON) != 0)) {
+		/* if ACL_DISCOVERY mode change request */
+		error = 0;
+		lids_acl_discovery =
+		    (lids_flag_raised(flags, LIDS_FLAGS_ACL_DISCOVERY_ON) != 0);
+		lids_security_alert("LIDS acl discovery mode %s",
+				    lids_acl_discovery ? "on" : "off");
+		if (lids_acl_discovery)
+			lids_flag_raise(lids_flags,
+					LIDS_FLAGS_ACL_DISCOVERY_ON);
+		else
+			lids_flag_lower(lids_flags,
+					LIDS_FLAGS_ACL_DISCOVERY_ON);
+		goto out;
+	}
+#ifdef CONFIG_LIDS_ALLOW_LFS
+	/* Switching LIDS/LIDSS_GLOBAL off and on */
+	if (lids_load != (lids_flag_raised(flags, LIDS_FLAGS_LIDS_ON) != 0)) {
+		lids_load = (lids_flag_raised(flags, LIDS_FLAGS_LIDS_ON) != 0);
+		lids_log(0, "LIDS switched to %i", lids_load);
+		if (lids_load)
+			lids_flag_raise(lids_flags, LIDS_FLAGS_LIDS_ON);
+		else
+			lids_flag_lower(lids_flags, LIDS_FLAGS_LIDS_ON);
+	}
+	if (lids_local_on !=
+	    (lids_flag_raised(flags, LIDS_FLAGS_LIDS_LOCAL_ON) != 0)) {
+		 /* XXX: Race condition here. We must first assign the PID */
+		lids_local_on =
+			(lids_flag_raised(flags,
+					  LIDS_FLAGS_LIDS_LOCAL_ON) != 0);
+		lids_log(0, "LIDS locally switched to %i", lids_local_on);
+		if (lids_local_on) {
+			lids_flag_raise(lids_flags, LIDS_FLAGS_LIDS_LOCAL_ON);
+		} else {
+			lids_local_pid = current->p_pptr->pid;
+			if (lids_local_pid == 1) {
+				/* this doesn't apply to init */
+				printk("Can't give local lids deactivation "
+				       "to init!!\n");
+				lids_flag_raise(lids_flags,
+						LIDS_FLAGS_LIDS_LOCAL_ON);
+				lids_local_on = 1;
+			} else
+				lids_flag_lower(lids_flags,
+						LIDS_FLAGS_LIDS_LOCAL_ON);
+		}
+	}
+        if  (!lids_flag_raised(flags,LIDS_FLAGS_LIDS_ON)) {
+            printk( "LIDS DISABLED - removing proc entry" );
+            lids_proc_key_remove();
+        }
+#else
+	if (!lids_flag_raised(flags, LIDS_FLAGS_LIDS_ON) ||
+	    !lids_flag_raised(flags, LIDS_FLAGS_LIDS_LOCAL_ON)) {
+		lids_security_alert
+		    ("Attempt to switch LIDS off (feature disabled)");
+		error = -1;
+		goto out;
+	}
+#endif
+	if (lids_flag_raised(flags, LIDS_FLAGS_RELOAD_CONF)) {
+		/* Config file reload */
+#ifdef CONFIG_LIDS_RELOAD_CONF
+		if (lids_load && !lids_local_on && lids_local_load) {
+			printk(KERN_WARNING "Can't reload config files "
+			       "if an LFS is opened and we are not in\n");
+		} else {
+			error = lids_load_conf();
+		}
+#else
+		lids_security_alert
+		    ("Attempt to reload config. file (feature disabled)");
+		error = -1;
+#endif
+		goto out;
+	}
+
+	/* if the flags raised as shutdown, change the state */
+	if (lids_flag_raised(flags, LIDS_FLAGS_SHUTDOWN) &&
+	    (lids_state != LIDS_STATE_SHUTDOWN)) {
+		lids_state = LIDS_STATE_SHUTDOWN;
+		error = lids_load_conf();
+		if (!error) {
+			lids_flag_raise(lids_flags, LIDS_FLAGS_SHUTDOWN);
+	//              lids_flag_lower(lids_flags, LIDS_FLAGS_POSTBOOT);
+		}
+	}
+out:
+	return error;
+}
+
+/**
+ * lids_proc_locks_sysctl - process LIDS system control (LIDS locks).
+ *			    Return 0 on success. Otherwise, return a negative
+ *			    value.
+ * @table - LIDS system control table
+ * @write - %TRUE if this is a write to the sysctl file
+ * @filp - the file structure
+ * @buffer - the user buffer
+ * @lenp - size of the user buffer
+ *
+ * This function processes security features set by 'lidsadm' from
+ * the user space through /proc/sys/lids/locks.
+ *
+ * To increase code readability, lots of conditional compilation code
+ * are hidden under some macros (lids_check_tty(), etc.) defined in
+ * linux/include/lids.h.
+ */
+int
+lids_proc_locks_sysctl(ctl_table *table, int write, struct file *filp,
+		       void *buffer, size_t *lenp)
+{
+	lids_locks_t locks;
+	char rmd160sig[LIDS_PW_LEN + 10];
+	int error = 0;
+
+	/* first: check the terminal and the program which access the sysctl */
+
+	if ((error = lids_check_tty(write)))
+		goto exit;
+
+	if ((error = lids_check_lidsadm(lidsadm, write)))
+		goto exit;
+
+	/*
+	 * second: check wether it is not a timeout period after two many
+	 * failed attempts
+	 */
+	if (wait_after_fail) {
+		lids_security_alert("Attempt to %s locks sysctl during timeout",
+				    write ? "write" : "read");
+		error = -EPERM;
+		goto exit;
+	}
+
+	if (copy_from_user(&locks, buffer, sizeof(lids_locks_t))) {
+		error = -EFAULT;
+		goto exit;
+	}
+
+	if (!write) {
+		if (lids_flag_raised(locks.flags, LIDS_FLAGS_STATUS)) {
+			locks.cap_bset = lids_load;
+			locks.flags = lids_local_load;
+		} else {
+			locks.cap_bset = lids_cap_val;
+			locks.flags = lids_flags;
+		}
+		LIDS_DBG("Sending caps=%#0x flags=%#0x\n", locks.cap_bset,
+			 locks.flags);
+		if (*lenp < sizeof(lids_locks_t)) {
+			error = -EINVAL;
+			goto exit;
+		}
+		if (copy_to_user(buffer, &locks, sizeof(lids_locks_t))) {
+			error = -EFAULT;
+			goto exit;
+		}
+		goto exit;
+	}
+
+	/* third : check what is submitted (size, magics, passwd) */
+	if (*lenp != sizeof(lids_locks_t)) {
+		lids_security_alert
+		    ("Attempt to feed locks sysctl with garbage");
+		error = -EINVAL;
+		goto exit;
+	}
+	if ((locks.magic1 != LIDS_MAGIC_1) || (locks.magic2 != LIDS_MAGIC_2) ||
+	    (locks.magic3 != LIDS_MAGIC_3) || (locks.magic4 != LIDS_MAGIC_4)) {
+		memset((char *) locks.passwd, '\0', sizeof(passwd_t));
+		lids_security_alert("Attempt to feed locks sysctl "
+				    "bad magic numbers");
+		error = -EINVAL;
+		goto exit;
+	}
+	locks.passwd[sizeof(passwd_t) - 1] = 0;	/* We don't take the risk */
+	rmd160sig[0] = 0;
+
+	lids_set_locks_passwd();
+
+	if (lids_allow_switch()) {
+		/* access granted ! */
+		number_failed = 0;
+#ifdef CONFIG_LIDS_HANGUP
+		if (current->tty != NULL)
+			set_bit(TTY_LIDS_NO_HANGUP, &(current->tty->flags));
+#endif
+		if (lids_process_flags(locks.flags) == 0) {
+			if (lids_first_time ||
+			    lids_flag_raised(locks.flags,
+					     LIDS_FLAGS_RELOAD_CONF) ||
+			    lids_flag_raised(locks.flags, LIDS_FLAGS_SHUTDOWN))
+				lids_cap_val = lids_conf_cap;
+			else
+				lids_cap_val = locks.cap_bset;
+			lids_log(0, "Changed: lids_cap_val=0x%x "
+				 "lids_flags=0x%x", lids_cap_val, lids_flags);
+		}
+		lids_first_time = 0;
+#ifdef CONFIG_LIDS_HANGUP
+		if (current->tty != NULL)
+			clear_bit(TTY_LIDS_NO_HANGUP, &(current->tty->flags));
+#endif
+	} else
+		lids_not_allow_switch();
+exit:
+	return error;
+}
+
+/**
+ * lids_cap_log - log capability violation of the current process.
+ * @cap - capability to check
+ */
+void
+lids_cap_log(int cap)
+{
+	LIDS_DBG(":lids_cap =%lx, cap_effective=%x,"
+		 "cap=%d, lids_load=%d, lids_local_load=%d\n",
+		 current->lids_cap, current->cap_effective, cap, lids_load,
+		 lids_local_load);
+
+	if (!lids_cap_raised(cap, 0)) {
+		if (lids_sandboxed(current) &&
+		    !cap_raised(current->lids_cap, cap))
+			lids_security_alert("A sandboxed process violated %s",
+					    lids_caps_desc[cap]);
+		else if (!cap_raised(cap_combine(current->lids_cap,
+						 lids_cap_val), cap))
+			lids_security_alert(" violated %s",
+					    lids_caps_desc[cap]);
+		else
+			lids_security_alert(" timerule violated for %s",
+					    lids_caps_desc[cap]);
+	}
+}
diff -durN kernel.orig/kernel/lids_logs.c kernel/kernel/lids_logs.c
--- kernel.orig/kernel/lids_logs.c	1970-01-01 10:00:00.000000000 +1000
+++ kernel/kernel/lids_logs.c	2007-03-20 14:53:00.000000000 +1000
@@ -0,0 +1,231 @@
+/*
+ * linux/kernel/lids_logs.c
+ *
+ * Author : Philippe Biondi, (pbi@cartel-info.fr)
+ *
+ * Description : This file contains the LIDS logging functions
+ *
+ * Changes :
+ *
+ *  - Nov 06, 2001. Philippe Biondi : initial creation
+ *  - Jul 02, 2004. Yusuf Wilajati Purna: Added lids_find_fullpathname(),
+ *		    Used locks and dget()/dput() properly.
+ *  - Dec 04, 2004. Yusuf Wilajati Purna: Changed GFP_KERNEL in lids_log() to
+ *		    GFP_ATOMIC (since lids_log() could be possibly called
+ *		    within softirq.)
+ */
+
+#include <linux/sched.h>
+#include <linux/mm.h>
+#include <linux/slab.h>
+#include <linux/lids.h>
+
+#define STR2(x) #x
+#define STR(x) STR2(x)
+
+#ifdef CONFIG_LIDS_HANGUP
+void
+lids_hangup_console()
+{
+	if (current->tty != NULL && !lids_first_time) {
+		if (!test_bit(TTY_LIDS_NO_HANGUP, &current->tty->flags))
+			tty_vhangup(current->tty);
+	}
+}
+#endif
+
+#ifdef CONFIG_LIDS_SA_THROUGH_NET
+#define lids_print(message, args...)					\
+	do {								\
+		if (buf)						\
+			sprintf(buf, message , ## args);		\
+		else							\
+			printk(KERN_ALERT message , ## args);		\
+	} while (0)
+#else
+#define lids_print(message, args...) printk(KERN_ALERT message , ## args)
+#endif
+
+/* return current dentry */
+static struct dentry *
+lids_current_dentry(void)
+{
+	struct dentry *f_dentry = NULL;
+	struct vm_area_struct *vma;
+
+	if (current->mm) {
+		down_read(&current->mm->mmap_sem);
+		vma = current->mm->mmap;
+		while (vma) {
+			if ((vma->vm_flags & VM_EXECUTABLE) &&
+			    vma->vm_file) {
+				f_dentry = vma->vm_file->f_dentry;
+				break;
+			}
+			vma = vma->vm_next;
+		}
+		up_read(&current->mm->mmap_sem);
+	}
+
+	return f_dentry;
+}
+
+void
+lids_log(int flood, char *message, ...)
+{
+	va_list args;
+	char ttyname[64];
+	char progname[64];
+	char proginfo[64 + 10 + 10 + 20 + 24];	/* %s+%d+%d+%ld+le texte avec un peu de marge = 128 */
+	char msgstr[256];
+	struct dentry *f_dentry;
+
+#ifdef CONFIG_LIDS_SA_THROUGH_NET
+	char *buf;
+	buf = (char *) kmalloc(2048, GFP_ATOMIC);
+#endif
+
+	/* Get args on the stack */
+	va_start(args, message);
+
+	/* Get dentry of current process, if any */
+	if ((f_dentry = lids_current_dentry()))
+		dget(f_dentry);
+
+	/* Get the tty name, if any */
+	if (current->tty)
+		tty_name(current->tty, ttyname);
+	else
+		strncpy(ttyname, "null tty", 10);
+
+	/* Make the proginfo string */
+	if (f_dentry && f_dentry->d_inode) {
+		strncpy(progname, f_dentry->d_name.name, 63);
+		snprintf(proginfo, 127, "%s (dev %d:%d inode %ld)",
+			 progname,
+			 MAJOR(f_dentry->d_inode->i_dev),
+			 MINOR(f_dentry->d_inode->i_dev),
+			 f_dentry->d_inode->i_ino);
+		dput(f_dentry);
+	} else {
+		strncpy(proginfo, "(undetermined program)", 63);
+	}
+
+	/* Make the message string */
+	vsnprintf(msgstr, 255, message, args);
+
+	/* Make the log string */
+	lids_print("LIDS: %s %s pid %d ppid %d uid/gid (%d/%d) on (%s) : "
+		   "%s %s\n",
+		   lids_sandboxed(current) ?
+		   "sandboxed" : "",
+		   proginfo,
+		   current->pid,
+		   current->p_pptr->pid,
+		   current->uid,
+		   current->gid,
+		   ttyname,
+		   msgstr,
+		   flood ? " - logging disabled for "
+		   STR(CONFIG_LIDS_TIMEOUT_AFTER_FLOOD) "s" : "");
+
+#ifdef CONFIG_LIDS_SA_THROUGH_NET
+	if (buf) {
+		printk(KERN_ALERT "%s", buf);
+		lids_send_message(buf, strlen(buf));
+	}
+#endif
+
+	/* deal with args on the stack */
+	va_end(args);
+}
+
+/* sent out message */
+void
+lids_alert(int type, struct dentry *dentry, long dst, long dst2, char *name,
+	   char *action)
+{
+	char *o_name = name, *o_buf = NULL;
+
+	if (dentry) {
+		struct dentry *o_dentry = dget(dentry);
+
+		o_buf = (char *) __get_free_page(GFP_KERNEL);
+		if (o_buf != NULL)
+			o_name = lids_find_fullpathname(o_dentry, o_buf,
+							PAGE_SIZE);
+		dput(o_dentry);
+	}
+
+	switch (type) {
+	case LIDS_CAP:
+		lids_security_alert("violate %s", action);
+		break;
+	case LIDS_SOCKET:
+		lids_security_alert("attempt to %s", action);
+		break;
+	case LIDS_READONLY:
+		/* compatible to the acl */
+		type = 1;
+		lids_security_alert("attempt to %s %s for reading", action,
+				    o_name);
+		break;
+	case LIDS_APPEND:
+		type = 3;
+		lids_security_alert("attempt to %s %s for appending", action,
+				    o_name);
+		break;
+	case LIDS_WRITE:
+		type = 7;
+		lids_security_alert("attempt to %s %s for writing", action,
+				    o_name);
+		break;
+	default:
+		lids_security_alert("yeee, alert type mismatch");
+		break;
+	}
+
+	/* if in acl_discovery mode, print out the acl_discovery mode string */
+	if (lids_acl_discovery) {
+		struct dentry *f_dentry = NULL;
+
+		if ((f_dentry = lids_current_dentry())) {
+			dget(f_dentry);
+			if (f_dentry->d_inode && f_dentry->d_name.name) {
+				char *filebuf = NULL, *pathname;
+
+				filebuf = (char *) __get_free_page(GFP_KERNEL);
+				if (filebuf != NULL)
+					pathname =
+						lids_find_fullpathname
+							(f_dentry, filebuf,
+							 PAGE_SIZE);
+				else
+					pathname =
+						(char *) f_dentry->d_name.name;
+				if (dst > 0)
+					printk(KERN_INFO
+					       "LIDS_ACL_DISCOVERY:[state %d]"
+					       "%ld:%d:%s:%d:0:%ld-%ld:%ld:%s:"
+					       "0-0\n", lids_state,
+					       f_dentry->d_inode->i_ino,
+					       f_dentry->d_inode->i_dev,
+					       pathname, type, dst, dst,
+					       dst2, o_name);
+				else
+					printk(KERN_INFO
+					       "LIDS_ACL_DISCOVERY:[state %d]"
+					       "%ld:%d:%s:%d:0:%ld:%ld:%s:"
+					       "0-0\n", lids_state,
+					       f_dentry->d_inode->i_ino,
+					       f_dentry->d_inode->i_dev,
+					       pathname, type, dst, dst2,
+					       o_name);
+				free_page((unsigned long) filebuf);
+			}
+			dput(f_dentry);
+		}
+	}
+
+	free_page((unsigned long) o_buf);
+}
diff -durN kernel.orig/kernel/lids_mail_script.c kernel/kernel/lids_mail_script.c
--- kernel.orig/kernel/lids_mail_script.c	1970-01-01 10:00:00.000000000 +1000
+++ kernel/kernel/lids_mail_script.c	2007-03-20 14:53:00.000000000 +1000
@@ -0,0 +1,32 @@
+/*
+ * Mail LIDS security alerts
+ *
+ * Philippe Biondi (philippe.biondi@webmotion.com)
+ * March 29, 2000
+ *
+ *  Sep 1, 2000 Xie Huagang, used configuation file.
+ *  	  But It is not compatible to write the pseudo file.
+ *
+ */
+
+/*
+ * This is a pseudo scripting language
+ * It is in fact directly included in the C source of
+ * klids.c by the cpp.
+ *
+ */
+
+lids_expect("220");
+lids_send(lids_mail_source);
+lids_expect("250");
+lids_send(lids_mail_from);
+lids_expect("250");
+lids_send(lids_rcpt_to);
+lids_expect("250");
+lids_send("data\r\n");
+lids_expect("354");
+lids_send(lids_mail_subject);
+lids_send(LIDS_MESSAGE);
+lids_send("\r\n\r\n.\r\n");
+lids_expect("250");
+lids_send("quit\r\n");
diff -durN kernel.orig/kernel/lids_net.c kernel/kernel/lids_net.c
--- kernel.orig/kernel/lids_net.c	1970-01-01 10:00:00.000000000 +1000
+++ kernel/kernel/lids_net.c	2007-03-20 14:53:00.000000000 +1000
@@ -0,0 +1,186 @@
+/*
+   Sending Msg through Network
+
+   Copyright 1999-2001 by Xie Huagang ( xie@gnuchina.org).
+
+   This file is part of the Linux Intrusion Detection System.
+
+   This program is free software; you can redistribute it and/or modify it
+   under the terms of the GNU General Public License as published by the
+   Free Software Foundation; either version 2 of the License, or (at your
+   option) any later version.
+
+   This program is distributed in the hope that it will be useful, but
+   WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   General Public License for more details.
+
+   You should have received a copy of the GNU General Public License
+   along with this program; if not, write to the Free Software Foundation,
+   Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+
+  */
+
+#include <linux/slab.h>
+#include <linux/file.h>
+#include <linux/config.h>
+#include <linux/module.h>
+#include <linux/version.h>
+#include <linux/fs.h>
+
+#include <linux/kernel.h>
+#include <asm/unistd.h>
+#include <asm/uaccess.h>
+#include <asm/segment.h>
+#include <linux/mm.h>
+#include <linux/inet.h>
+
+#include <linux/utsname.h>
+
+struct lids_net_val {
+	char *name;
+	void (*setup_func) (char *);
+};
+char lids_mail_source[64], lids_mail_from[64],
+    lids_mail_to[64], lids_mail_subject[1024];
+char lids_rcpt_to[64], lids_s_from[64];
+
+int lids_mail_switch;
+unsigned long int lids_mail_relay;
+unsigned int lids_mail_port;
+
+static void
+lids_mail_switch_setup(char *str)
+{
+	while (*str == ' ' || *str == '\r')
+		str++;
+	lids_mail_switch = simple_strtoul(str, NULL, 0);
+	printk("LIDS: Sending Alert through network is %s\n",
+	       lids_mail_switch ? "on" : "off");
+}
+static void
+lids_mail_source_setup(char *str)
+{
+	sprintf(lids_mail_source, "ehlo %s\r\n", str);
+}
+
+static void
+lids_mail_from_setup(char *str)
+{
+	sprintf(lids_mail_from, "mail from:<%s>\r\n", str);
+	strcpy(lids_s_from, str);
+}
+static void
+lids_mail_to_setup(char *str)
+{
+	sprintf(lids_rcpt_to, "rcpt to:<%s>\r\n", str);
+	strcpy(lids_mail_to, str);
+}
+static void
+lids_mail_subject_setup(char *str)
+{
+	sprintf(lids_mail_subject, "From: %s\r\nTo: %s\r\nSubject: %s\r\n\r\n",
+		lids_s_from, lids_mail_to, str);
+}
+static void
+lids_mail_relay_setup(char *str)
+{
+	char *p;
+
+	p = strchr(str, ':');
+	if (p == NULL)
+		lids_mail_port = 25;
+	else {
+		(*p) = '\0';
+		lids_mail_port = simple_strtoul(p + 1, NULL, 0);
+	}
+
+	lids_mail_relay = in_aton(str);
+
+}
+
+static struct lids_net_val lids_net_val[] = {
+	{"MAIL_SWITCH=", lids_mail_switch_setup},
+	{"MAIL_SOURCE=", lids_mail_source_setup},
+	{"MAIL_FROM=", lids_mail_from_setup},
+	{"MAIL_TO=", lids_mail_to_setup},
+	{"MAIL_SUBJECT=", lids_mail_subject_setup},
+	{"MAIL_RELAY=", lids_mail_relay_setup},
+	{NULL, NULL}
+};
+
+/*
+ *	lids network initial working
+ */
+int
+lids_net_init(char *line)
+{
+	int i, n;
+
+	/* now split the name and value */
+	for (i = 0; lids_net_val[i].name; i++) {
+		n = strlen(lids_net_val[i].name);
+		if (!strncmp(line, lids_net_val[i].name, n)) {
+			lids_net_val[i].setup_func(line + n);
+		}
+	}
+	return 0;
+}
+
+int
+lids_read_net(void)
+{
+	struct file *filp;
+	char buffer[1024], *p, *q;
+	mm_segment_t oldfs;
+	int bytes;
+	int error = 0;
+
+	filp = filp_open("/etc/lids/lids.net", O_RDONLY, O_RDONLY);
+	if (IS_ERR(filp) || (filp == NULL)) {
+		error = -1;
+		printk("LIDS: Checking net file error, does it exist?\n");
+		/* FIXME: if (lids_load) goto err_panic;  */
+		return error;
+	}
+
+	if (filp->f_op->read == NULL) {
+		fput(filp);
+		error = -3;
+		printk("LIDS: The file  can not be read\n");
+		/*
+		   if (lids_load) goto err_panic ;
+		 */
+		return error;
+	}
+
+	/* Now read 1024 bytes into buffer */
+	filp->f_pos = 0;
+	oldfs = get_fs();
+	set_fs(KERNEL_DS);
+	bytes = filp->f_op->read(filp, buffer, 1024, &filp->f_pos);
+	set_fs(oldfs);
+
+	q = buffer;
+	/* analyze the buffer */
+	while (bytes && (p = memscan(q, '\n', bytes)) != q + bytes) {
+		*p++ = '\0';
+		/*
+		   printk("read_file : line=->%s<-\n",q);
+		 */
+		bytes -= (int) (p - q);
+		while (*q == '\r')
+			q++;	/* hmmm... */
+		if (*q && *q != '#')
+			if (lids_net_init(q) < 0) {
+				error = -5;
+				printk("LIDS: error in adding [%s] to the kernel\n", q);
+				break;
+			}
+		q = p;
+	}
+
+	/* Close the file */
+	fput(filp);
+	return error;
+}
diff -durN kernel.orig/kernel/lids_socket.c kernel/kernel/lids_socket.c
--- kernel.orig/kernel/lids_socket.c	1970-01-01 10:00:00.000000000 +1000
+++ kernel/kernel/lids_socket.c	2007-03-20 14:53:00.000000000 +1000
@@ -0,0 +1,281 @@
+#include <linux/config.h>
+#include <linux/module.h>
+#include <linux/kernel.h>
+#include <linux/init.h>
+#include <linux/skbuff.h>
+#include <linux/netlink.h>
+#include <linux/ip.h>
+#include <linux/lids.h>
+#include <linux/lidsext.h>
+#include <linux/lidsif.h>
+#include <net/sock.h>
+#include <linux/in.h>
+#include <linux/netfilter_ipv4/ipt_MARK.h>
+
+/*
+ *     socket permission checker
+ */
+int
+lids_socket_perm(struct task_struct *tsk, int type)
+{
+	struct lids_sys_acl *tsk_sys_acl = tsk->lids_sys_acl;
+
+	if (tsk_sys_acl && test_bit(type, &(tsk_sys_acl->socket))) {
+		return -EPERM;
+	}
+	return 0;
+}
+
+int
+lids_socket_create(int family, int type, int protocol)
+{
+	if (lids_load && lids_local_load && family == AF_INET) {
+		if (lids_socket_perm(current, LIDS_SOCKET_CREATE) < 0) {
+			lids_security_alert("Attempt to create socket");
+			return -EPERM;
+		}
+		if (type == SOCK_DGRAM) {
+			if (lids_sandboxed(current) &&
+			    !lids_cap_raised(CAP_NET_BROADCAST, 1)) {
+				lids_security_alert("Attempt to create udp "
+						    " socket");
+				return -EPERM;
+			}
+			if (lids_socket_perm(current,
+					     LIDS_SOCKET_CREATE_UDP) < 0) {
+				lids_security_alert("Attempt to create udp "
+						    "socket");
+				return -EPERM;
+			}
+		} else if ((type == SOCK_STREAM) &&
+			   lids_socket_perm(current,
+					    LIDS_SOCKET_CREATE_TCP) < 0) {
+				lids_security_alert("Attempt to create tcp "
+						    "socket");
+				return -EPERM;
+		}
+	}
+	return 0;
+}
+
+void
+lids_socket_post_create(struct socket *sock, int family, int type, int protocol)
+{
+#ifdef CONFIG_LIDS_NF_MARK
+	struct lids_sys_acl *tsk_sys_acl;
+	struct ipt_mark_target_info *markinfo;
+
+	if (lids_load && lids_local_load && family == AF_INET) {
+		if (lids_socket_perm(current, LIDS_SOCKET_NF_MARK) < 0) {
+			struct inode *inode = SOCK_INODE(sock);
+
+			if (inode) {
+				tsk_sys_acl = current->lids_sys_acl;
+				markinfo = kmalloc(sizeof(struct ipt_mark_target_info),
+						   GFP_KERNEL);
+				markinfo->mark = tsk_sys_acl->mark;
+				/* FIXME, need lock?? */
+				inode->i_security = markinfo;
+				LIDS_DBG("DEV: [%d %d] Mark socket as %lu \n",
+					 current->pid, current->p_pptr->pid,
+					 markinfo->mark);
+			}
+		}
+	}
+#endif
+	return;
+}
+
+int
+lids_socket_bind(struct socket *sock, struct sockaddr *address, int addrlen)
+{
+	struct sockaddr_in *addr = (struct sockaddr_in *) address;
+
+	if (lids_load && lids_local_load && address
+	    && address->sa_family == AF_INET) {
+		if (lids_sandboxed(current) &&
+		    (!lids_cap_raised(CAP_NET_BIND_SERVICE, 1) ||
+		     !lids_bind_checker(ntohs(addr->sin_port)))) {
+			lids_security_alert("Attempt to bind %u.%u.%u.%u:%d",
+					    NIPQUAD(addr->sin_addr),
+					    ntohs(addr->sin_port));
+			return -EPERM;
+		}
+		if (lids_socket_perm(current, LIDS_SOCKET_BIND) < 0) {
+			lids_security_alert("Attempt to bind %u.%u.%u.%u:%d",
+					    NIPQUAD(addr->sin_addr),
+					    ntohs(addr->sin_port));
+			return -EPERM;
+		}
+	}
+	return 0;
+}
+
+int
+lids_socket_connect(struct socket *sock, struct sockaddr *address, int addrlen)
+{
+	struct sockaddr_in *addr = (struct sockaddr_in *) address;
+
+	if (lids_load && lids_local_load
+	    && address && address->sa_family == AF_INET) {
+		if (lids_sandboxed(current) &&
+		    (!lids_cap_raised(CAP_NET_BROADCAST, 1) ||
+		     !lids_broadcast_port(ntohs(addr->sin_port)))) {
+			lids_security_alert("Attempt to connect %u.%u.%u.%u:%d",
+					    NIPQUAD(addr->sin_addr),
+					    ntohs(addr->sin_port));
+			return -EPERM;
+		}
+		if (lids_socket_perm(current, LIDS_SOCKET_CONNECT) < 0) {
+			lids_security_alert("Attempt to connect %u.%u.%u.%u:%d",
+					    NIPQUAD(addr->sin_addr),
+					    ntohs(addr->sin_port));
+			return -EPERM;
+		}
+	}
+	return 0;
+}
+
+int
+lids_socket_listen(struct socket *sock, int backlog)
+{
+	struct sock *sk = sock->sk;
+
+	if (lids_load && lids_local_load && sk->family == PF_INET) {
+		if (lids_socket_perm(current, LIDS_SOCKET_LISTEN) < 0) {
+			lids_security_alert("Attempt to listen");
+			return -EPERM;
+		}
+	}
+
+	return 0;
+}
+
+int
+lids_socket_accept(struct socket *sock, struct socket *newsock)
+{
+	struct sock *sk = sock->sk;
+
+	if (lids_load && lids_local_load && sk->family == PF_INET) {
+		if (lids_socket_perm(current, LIDS_SOCKET_ACCEPT) < 0) {
+			lids_security_alert("Attempt to accept");
+			return -EPERM;
+		}
+	}
+	return 0;
+}
+
+void
+lids_socket_post_accept(struct socket *sock, struct socket *newsock)
+{
+	return;
+}
+
+int
+lids_socket_sendmsg(struct socket *sock)
+{
+	struct sock *sk = sock->sk;
+
+	if (lids_load && lids_local_load && sk->family == PF_INET
+	    && sk->type == SOCK_DGRAM) {
+		if (lids_socket_perm(current, LIDS_SOCKET_SENDMSG) < 0) {
+			lids_security_alert("Attempt to sendmsg");
+			return -EPERM;
+		}
+	}
+
+	return 0;
+}
+
+int
+lids_socket_recvmsg(struct socket *sock)
+{
+	struct sock *sk = sock->sk;
+
+	if (lids_load && lids_local_load && sk->family == PF_INET
+	    && sk->type == SOCK_DGRAM) {
+		if (lids_socket_perm(current, LIDS_SOCKET_RECVMSG) < 0) {
+			lids_security_alert("Attempt to recvmsg");
+			return -EPERM;
+		}
+	}
+	return 0;
+}
+
+int
+lids_socket_getsockname(struct socket *sock)
+{
+	struct sock *sk = sock->sk;
+
+	if (lids_load && lids_local_load && sk->family == PF_INET) {
+		if (lids_socket_perm(current, LIDS_SOCKET_GETSOCKNAME) < 0) {
+			lids_security_alert("Attempt to getsocketname");
+			return -EPERM;
+		}
+	}
+	return 0;
+}
+
+int
+lids_socket_getpeername(struct socket *sock)
+{
+	struct sock *sk = sock->sk;
+
+	if (lids_load && lids_local_load && sk->family == PF_INET) {
+		if (lids_socket_perm(current, LIDS_SOCKET_GETPEERNAME) < 0) {
+			lids_security_alert("Attempt to getpeername");
+			return -EPERM;
+		}
+	}
+	return 0;
+}
+
+int
+lids_socket_setsockopt(struct socket *sock, int level, int optname)
+{
+	struct sock *sk = sock->sk;
+
+	if (lids_load && lids_local_load && sk->family == PF_INET) {
+		if (lids_socket_perm(current, LIDS_SOCKET_SETSOCKOPT) < 0) {
+			lids_security_alert("Attempt to setsockopt level %d "
+					    "optname %d", level, optname);
+			return -EPERM;
+		}
+	}
+	return 0;
+}
+
+int
+lids_socket_getsockopt(struct socket *sock, int level, int optname)
+{
+	struct sock *sk = sock->sk;
+
+	if (lids_load && lids_local_load && sk->family == PF_INET) {
+		if (lids_socket_perm(current, LIDS_SOCKET_GETSOCKOPT) < 0) {
+			lids_security_alert("Attempt to getsockopt level %d "
+					    "optname %d", level, optname);
+			return -EPERM;
+		}
+	}
+	return 0;
+}
+
+int
+lids_socket_shutdown(struct socket *sock, int how)
+{
+	struct sock *sk = sock->sk;
+
+	if (lids_load && lids_local_load && sk->family == PF_INET) {
+		if (lids_socket_perm(current, LIDS_SOCKET_SHUTDOWN) < 0) {
+			lids_security_alert("Attempt to shutdown (how: %d)", how);
+			return -EPERM;
+		}
+	}
+	return 0;
+}
+
+int
+lids_socket_sock_rcv_skb(struct sock *sk, struct sk_buff *skb)
+{
+	return 0;
+}
diff -durN kernel.orig/kernel/lids_syslog_script.c kernel/kernel/lids_syslog_script.c
--- kernel.orig/kernel/lids_syslog_script.c	1970-01-01 10:00:00.000000000 +1000
+++ kernel/kernel/lids_syslog_script.c	2007-03-20 14:53:00.000000000 +1000
@@ -0,0 +1,16 @@
+/*
+ * Log LIDS security alerts to a remote syslog
+ *
+ * Philippe Biondi (philippe.biondi@webmotion.com)
+ * March 29, 2000
+ *
+ */
+
+/*
+ * This is a pseudo scripting language
+ * It is in fact directly included in the C source of
+ * klids.c by the cpp.
+ *
+ */
+
+lids_send(LIDS_MESSAGE);
diff -durN kernel.orig/kernel/lids_tde.c kernel/kernel/lids_tde.c
--- kernel.orig/kernel/lids_tde.c	1970-01-01 10:00:00.000000000 +1000
+++ kernel/kernel/lids_tde.c	2007-03-20 14:53:00.000000000 +1000
@@ -0,0 +1,211 @@
+/*
+ *  LIDS - Trusted Domain Enforcement
+ *
+ *  Author: Yusuf Wilajati Purna <ywpurna@users.sourceforge.net>
+ *
+ *  Copyright 2004 Yusuf Wilajati Purna <ywpurna@users.sourceforge.net>
+ *
+ *  This program is free software; you can redistribute  it and/or modify it
+ *  under  the terms of  the GNU General  Public License as published by the
+ *  Free Software Foundation;  version 2 of the  License.
+ *
+ *  THIS  SOFTWARE  IS PROVIDED   ``AS  IS'' AND   ANY  EXPRESS OR IMPLIED
+ *  WARRANTIES,   INCLUDING, BUT NOT  LIMITED  TO, THE IMPLIED WARRANTIES OF
+ *  MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.  IN
+ *  NO  EVENT  SHALL   THE AUTHOR  BE    LIABLE FOR ANY   DIRECT, INDIRECT,
+ *  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ *  NOT LIMITED   TO, PROCUREMENT OF  SUBSTITUTE GOODS  OR SERVICES; LOSS OF
+ *  USE, DATA,  OR PROFITS; OR  BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
+ *  ANY THEORY OF LIABILITY, WHETHER IN  CONTRACT, STRICT LIABILITY, OR TORT
+ *  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+ *  THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ *  You should have received a copy of the  GNU General Public License along
+ *  with this program; if not, write  to the Free Software Foundation, Inc.,
+ *  675 Mass Ave, Cambridge, MA 02139, USA.
+ */
+
+#include <linux/fs.h>
+#include <linux/lids.h>
+#include <linux/module.h>
+#include <linux/namespace.h>
+#include <linux/proc_fs.h>
+#include <linux/sched.h>
+
+static struct allowed_ino lidsdevtty;
+
+int
+lids_trusted_domain(struct task_struct *task)
+{
+	int trusted = 0;
+
+	if (task->pid == 1) {
+		trusted = 1;
+		goto out;
+	}
+
+	if (task->lids_cap || task->lids_sys_acl)
+		trusted = 1;
+out:
+	return trusted;
+}
+
+void
+lids_tde_policy(struct dentry *dentry, struct task_struct *task)
+{
+
+//	LIDS_DBG("PID:%d Read %s (dev %d:%d inode %ld)\n",
+//		 current->pid,
+//		 dentry->d_iname,
+//		 MAJOR(dentry->d_inode->i_dev),
+//		 MINOR(dentry->d_inode->i_dev),
+//		 dentry->d_inode->i_ino);
+
+	if (!(lids_load && lids_local_load))
+		goto out;
+
+	/*
+	 * Ignore a process reading info from /proc/xxx.
+	 * Is it OK?
+	 */
+	if (dentry->d_inode &&
+	    (MAJOR(dentry->d_inode->i_dev) == 0))
+		goto out;
+
+	/*
+	 * A non-sandboxed process whose CAP_PROTECTED is a special process.
+	 * Ignore the process.
+	 */
+	if (!lids_sandboxed(task) && cap_raised(task->lids_cap, CAP_PROTECTED))
+		goto out;
+
+	/* For the time being, ignore init (pid: 1) */
+	if (task->pid == 1)
+		goto out;
+
+	if (!lids_protected(dentry, LIDS_APPEND) &&
+	    (task->lids_cap || task->lids_sys_acl)) {
+		char *filebuf, *pathname;
+		int socket;
+		struct lids_task_acl task_acl;
+
+		filebuf = (char *) __get_free_page(GFP_KERNEL);
+		if (filebuf != NULL)
+			pathname = lids_find_fullpathname(dentry,
+							  filebuf,
+							  PAGE_SIZE);
+		else
+			pathname = (char *) dentry->d_name.name;
+
+		lids_security_alert("Enforce TDE policy! "
+				    "Read unprotected input %s ",
+				    pathname);
+
+		if (lids_acl_discovery) {
+			printk(KERN_INFO
+			       "LIDS_ACL_DISCOVERY:[state %d]"
+			       "%d:%d::%d:0:%ld:%d:%s:0-0\n",
+			       lids_state, 0, 0, LIDS_READONLY,
+			       dentry->d_inode->i_ino,
+			       dentry->d_inode->i_dev,
+			       pathname);
+			goto out1;
+		}
+
+		/*
+		 * if the process is sandboxed just initialize the caps
+		 * with the safe LIDS sandbox caps value set.
+		 */
+		if (lids_sandboxed(task)) {
+			task_lock(task);
+			task->lids_sys_acl->flags =
+				task->lids_sys_acl->flags &
+				CAP_LIDS_SANDBOX_SAFE_SET;
+			task->lids_cap = task->lids_sys_acl->flags;
+			task_unlock(task);
+			goto out1;
+		}
+
+		lids_get_task_acl(&task_acl, task);
+		/* if socket value is available keep the value. */
+		if ((socket = task_acl.lids_sys_acl->socket)) {
+			lids_clear_lids_task_acl(&task_acl);
+			task_acl.lids_sys_acl->socket = socket;
+		} else {
+			task_lock(task);
+			task->lids_cap = 0x0UL;
+			task->lids_sys_acl = NULL;
+			task_unlock(task);
+			lids_free_lids_task_acl(&task_acl);
+		}
+out1:
+		free_page((unsigned long) filebuf);
+	}
+out:
+	return;
+}
+
+int
+lids_read_dev_tty(void)
+{
+	int error = 0;
+	struct dentry *dentry;
+	struct nameidata nd;
+
+	lidsdevtty.ino = 0;
+	lidsdevtty.dev = 0;
+
+	if (path_init(LIDS_DEV_TTY_PATH, LOOKUP_FOLLOW | LOOKUP_POSITIVE, &nd))
+            error = path_walk(LIDS_DEV_TTY_PATH, &nd);
+
+	if (error) {
+		LIDS_DBG("PID=%d: path_lookup for %s failed\n", current->pid,
+			 LIDS_DEV_TTY_PATH);
+		goto out;
+	}
+
+	dentry = nd.dentry;
+
+	if (IS_ERR(dentry) || !dentry) {
+		LIDS_DBG("PID=%d: %s not found\n", current->pid,
+			 LIDS_DEV_TTY_PATH);
+		error = PTR_ERR(dentry);
+		goto out1;
+	}
+
+	if (!dentry->d_inode || !dentry->d_inode->i_dev ||
+	    !dentry->d_inode->i_ino) {
+		LIDS_DBG("PID=%d: no entry for %s\n", current->pid,
+			 LIDS_DEV_TTY_PATH);
+		error = -ENOENT;
+		goto out1;
+	}
+
+	lidsdevtty.ino = dentry->d_inode->i_ino;
+	lidsdevtty.dev = dentry->d_inode->i_dev;
+
+	LIDS_DBG("PID=%d: %s (dev %d:%d inode %ld)\n",
+		 current->pid, LIDS_DEV_TTY_PATH,
+		 MAJOR(dentry->d_inode->i_dev),
+		 MINOR(dentry->d_inode->i_dev),
+		 dentry->d_inode->i_ino);
+out1:
+	path_release(&nd);
+out:
+	return error;
+}
+
+int
+lids_dev_tty(struct dentry *base)
+{
+	int retval = 0;
+
+	if (!base || !base->d_inode)
+		return retval;
+
+	if ((base->d_inode->i_ino == lidsdevtty.ino) &&
+	    (base->d_inode->i_dev == lidsdevtty.dev))
+		retval = 1;
+
+	return retval;
+}
diff -durN kernel.orig/kernel/lids_tpe.c kernel/kernel/lids_tpe.c
--- kernel.orig/kernel/lids_tpe.c	1970-01-01 10:00:00.000000000 +1000
+++ kernel/kernel/lids_tpe.c	2007-03-20 14:53:00.000000000 +1000
@@ -0,0 +1,263 @@
+/*
+ *  LIDS - Trusted Path Execution (TPE)
+ *
+ *  Author: Yusuf Wilajati Purna <ywpurna@users.sourceforge.net>
+ *
+ *  Copyright 2001-2004 Sony Corporation.
+ *
+ *  This program is free software; you can redistribute  it and/or modify it
+ *  under  the terms of  the GNU General  Public License as published by the
+ *  Free Software Foundation;  version 2 of the  License.
+ *
+ *  THIS  SOFTWARE  IS PROVIDED   ``AS  IS'' AND   ANY  EXPRESS OR IMPLIED
+ *  WARRANTIES,   INCLUDING, BUT NOT  LIMITED  TO, THE IMPLIED WARRANTIES OF
+ *  MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.  IN
+ *  NO  EVENT  SHALL   THE AUTHOR  BE    LIABLE FOR ANY   DIRECT, INDIRECT,
+ *  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ *  NOT LIMITED   TO, PROCUREMENT OF  SUBSTITUTE GOODS  OR SERVICES; LOSS OF
+ *  USE, DATA,  OR PROFITS; OR  BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
+ *  ANY THEORY OF LIABILITY, WHETHER IN  CONTRACT, STRICT LIABILITY, OR TORT
+ *  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+ *  THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ *  You should have received a copy of the  GNU General Public License along
+ *  with this program; if not, write  to the Free Software Foundation, Inc.,
+ *  675 Mass Ave, Cambridge, MA 02139, USA.
+ */
+
+#include <linux/module.h>
+#include <linux/lids.h>
+#include <linux/fs.h>
+
+#include <asm/mman.h>
+
+#define MODNAME_MAX	256
+
+/*
+ * Switch TPE mode off as the
+ * initial state.
+ */
+int lids_tpe = 0;
+
+int
+lids_exec_tpe_permission(struct linux_binprm *bprm)
+{
+	int error = 0;
+	struct dentry *dentry;
+
+	if (current->p_pptr->pid == 0)
+		return 0;
+
+	if (!bprm || !bprm->file)
+		return 0;
+
+	if (!(lids_load && lids_local_load))
+		return 0;
+
+	if (!lids_tpe)
+		return 0;
+
+	dentry = dget(bprm->file->f_dentry);
+
+	/* Check if binary is protected */
+
+	if (!lids_protected(dentry, LIDS_APPEND)) {
+		char *buffer = NULL, *pathname;
+
+		buffer = (char *) __get_free_page(GFP_KERNEL);
+		if (buffer != NULL)
+			pathname = lids_find_fullpathname(dentry,
+							  buffer,
+							  PAGE_SIZE);
+		else
+			pathname = (char *) dentry->d_name.name;
+
+		lids_security_alert("TPE violation! "
+				    "Attempt to exec unprotected program "
+				    "%s (dev %d:%d inode %ld)",
+				    pathname,
+				    MAJOR(dentry->d_inode->i_dev),
+				    MINOR(dentry->d_inode->i_dev),
+				    dentry->d_inode->i_ino);
+		if (lids_acl_discovery)
+			printk(KERN_INFO
+			       "LIDS_ACL_DISCOVERY:[state %d]"
+			       "%d:%d::%d:0:%ld:%d:%s:0-0\n",
+			       lids_state, 0, 0, LIDS_READONLY,
+			       dentry->d_inode->i_ino, dentry->d_inode->i_dev,
+			       pathname);
+		else
+			error = -EACCES;
+
+		free_page((unsigned long) buffer);
+	}
+	dput(dentry);
+	return error;
+}
+
+int
+lids_mmap_tpe_permission(struct file *file, unsigned long prot,
+			 unsigned long flags)
+{
+	int error = 0;
+	struct dentry *dentry;
+
+	if (!(lids_load && lids_local_load))
+		return 0;
+
+	if (!lids_tpe)
+		return 0;
+
+	if (!file)
+		return 0;
+
+	if (!(prot & PROT_EXEC))
+		return 0;
+
+	dentry = dget(file->f_dentry);
+
+	/* Check if the mmap'ed file is protected */
+
+	if (!lids_protected(dentry, LIDS_APPEND)) {
+		char *buffer = NULL, *pathname;
+
+		buffer = (char *) __get_free_page(GFP_KERNEL);
+		if (buffer != NULL)
+			pathname = lids_find_fullpathname(dentry,
+							  buffer,
+							  PAGE_SIZE);
+		else
+			pathname = (char *) dentry->d_name.name;
+
+		lids_security_alert("TPE violation! "
+				    "Attempt to mmap %s (dev %d:%d inode %ld)",
+				    pathname,
+				    MAJOR(dentry->d_inode->i_dev),
+				    MINOR(dentry->d_inode->i_dev),
+				    dentry->d_inode->i_ino);
+		if (lids_acl_discovery)
+			printk(KERN_INFO
+			       "LIDS_ACL_DISCOVERY:[state %d]"
+			       "%d:%d::%d:0:%ld:%d:%s:0-0\n",
+			       lids_state, 0, 0, LIDS_READONLY,
+			       dentry->d_inode->i_ino, dentry->d_inode->i_dev,
+			       pathname);
+		else
+			error = -EACCES;
+
+		free_page((unsigned long) buffer);
+	}
+	dput(dentry);
+	return error;
+}
+
+int
+lids_module_tpe_permission(struct module *mod)
+{
+	char *modpath, *mark, *p, *q;
+	int error = 0, n, namelen;
+	struct dentry *dentry;
+	struct module_symbol *sym;
+	struct nameidata nd;
+
+	if (!(lids_load && lids_local_load))
+		return 0;
+
+	if (!lids_tpe)
+		return 0;
+
+	namelen = strlen(mod->name);
+	if (unlikely(namelen > MODNAME_MAX)) {
+		error = -EINVAL;
+		goto out1;
+	}
+
+	mark = (char *) kmalloc(sizeof (char) * (MODNAME_MAX + 12), GFP_KERNEL);
+	if (mark == NULL) {
+		error = -ENOMEM;
+		goto out1;
+	}
+	sprintf(mark, "__insmod_%s_O", mod->name);
+
+	modpath = (char *) kmalloc(sizeof (char) * (PATH_MAX + 1), GFP_KERNEL);
+	if (modpath == NULL) {
+		error = -ENOMEM;
+		goto out2;
+	}
+
+	/* Get the module path */
+
+	sym = mod->syms;
+	for (n = 0; n < mod->nsyms; n++) {
+		if (strstr(sym->name, mark)) {
+			if (unlikely
+			    (strlen(sym->name + 11 + namelen) > PATH_MAX)) {
+				error = -EINVAL;
+				goto out3;
+			}
+			strcpy(modpath, sym->name + 11 + namelen);
+			p = modpath;
+			q = p;
+			while ((p = strstr(p, mod->name))) {
+				q = p;
+				p++;
+			}
+			*(q + namelen + 2) = '\0';
+			break;
+		}
+		sym++;
+	}
+
+	if (unlikely(strstr(modpath, mod->name) == NULL)) {
+		error = -ENOENT;
+		goto out3;
+	}
+
+        if (path_init(modpath, LOOKUP_FOLLOW | LOOKUP_POSITIVE, &nd)) {
+            if (path_walk(modpath, &nd)) {
+		error = -ENOENT;
+		goto out3;
+            }
+        }
+
+	dentry = nd.dentry;
+
+	if (IS_ERR(dentry) || !dentry) {
+		error = -ENOENT;
+		goto out4;
+	}
+
+	if (!dentry->d_inode ||
+	    !dentry->d_inode->i_dev || !dentry->d_inode->i_ino) {
+		error = -ENOENT;
+		goto out4;
+	}
+
+	/* Check if the module path is protected */
+
+	if (!lids_protected(dentry, LIDS_APPEND)) {
+		lids_security_alert("TPE violation! "
+				    "Attempt to load unprotected module %s "
+				    "(dev %d:%d inode %ld)",
+				    modpath,
+				    MAJOR(dentry->d_inode->i_dev),
+				    MINOR(dentry->d_inode->i_dev),
+				    dentry->d_inode->i_ino);
+		if (lids_acl_discovery)
+			printk(KERN_INFO "LIDS_ACL_DISCOVERY:[state %d]"
+			       "%d:%d::%d:0:%ld:%d:%s:0-0\n",
+			       lids_state, 0, 0, LIDS_READONLY,
+			       dentry->d_inode->i_ino,
+			       dentry->d_inode->i_dev, modpath);
+		else
+			error = -EPERM;
+	}
+      out4:
+	path_release(&nd);
+      out3:
+	kfree(modpath);
+      out2:
+	kfree(mark);
+      out1:
+	return error;
+}
diff -durN kernel.orig/kernel/lids_utils.c kernel/kernel/lids_utils.c
--- kernel.orig/kernel/lids_utils.c	1970-01-01 10:00:00.000000000 +1000
+++ kernel/kernel/lids_utils.c	2007-03-20 14:53:00.000000000 +1000
@@ -0,0 +1,65 @@
+/*
+ *  LIDS - Miscellaneous Utilities
+ *
+ *  Author: Yusuf Wilajati Purna <ywpurna@users.sourceforge.net>
+ *
+ *  Copyright 2004 Yusuf Wilajati Purna <ywpurna@users.sourceforge.net>
+ *
+ *  This program is free software; you can redistribute  it and/or modify it
+ *  under  the terms of  the GNU General  Public License as published by the
+ *  Free Software Foundation;  version 2 of the  License.
+ *
+ *  THIS  SOFTWARE  IS PROVIDED   ``AS  IS'' AND   ANY  EXPRESS OR IMPLIED
+ *  WARRANTIES,   INCLUDING, BUT NOT  LIMITED  TO, THE IMPLIED WARRANTIES OF
+ *  MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.  IN
+ *  NO  EVENT  SHALL   THE AUTHOR  BE    LIABLE FOR ANY   DIRECT, INDIRECT,
+ *  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ *  NOT LIMITED   TO, PROCUREMENT OF  SUBSTITUTE GOODS  OR SERVICES; LOSS OF
+ *  USE, DATA,  OR PROFITS; OR  BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
+ *  ANY THEORY OF LIABILITY, WHETHER IN  CONTRACT, STRICT LIABILITY, OR TORT
+ *  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+ *  THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ *  You should have received a copy of the  GNU General Public License along
+ *  with this program; if not, write  to the Free Software Foundation, Inc.,
+ *  675 Mass Ave, Cambridge, MA 02139, USA.
+ */
+
+#include <linux/fs.h>
+#include <linux/lids.h>
+#include <linux/namespace.h>
+#include <linux/sched.h>
+
+/**
+ * lids_find_fullpathname - return one of possible full pathnames of a dentry
+ * @dentry - dentry to report
+ * @buf - buffer into which the full pathname will be written
+ * @len - buffer length
+ *
+ * 'len' should be %PAGE_SIZE or more.
+ * Return ERR_PTR(-ENAMETOOLONG) if 'len' is less than the full pathname.
+ */
+char *lids_find_fullpathname(struct dentry *dentry, char *buf, int len)
+{
+	char *fullpathname;
+	struct dentry *sb_root = dget(dentry->d_sb->s_root);
+	struct namespace *n = current->namespace;
+	struct list_head *p;
+	struct vfsmount *mnt = NULL;
+
+	down_read(&n->sem);
+	list_for_each(p, &n->list) {
+		mnt = list_entry(p, struct vfsmount, mnt_list);
+		if (mnt->mnt_root == sb_root) {
+			mntget(mnt);
+			break;
+		}
+	}
+	up_read(&n->sem);
+	dput(sb_root);
+
+	fullpathname = d_path(dentry, mnt, buf, len);
+	mntput(mnt);
+
+	return fullpathname;
+}
diff -durN kernel.orig/kernel/Makefile kernel/kernel/Makefile
--- kernel.orig/kernel/Makefile	2007-03-20 14:09:05.000000000 +1000
+++ kernel/kernel/Makefile	2007-03-20 14:53:00.000000000 +1000
@@ -22,6 +22,10 @@
 obj-$(CONFIG_MODULES) += ksyms.o
 obj-$(CONFIG_PM) += pm.o
 obj-$(CONFIG_CPU_FREQ) += cpufreq.o
+obj-$(CONFIG_LIDS) += lids.o lids_utils.o lids_socket.o lids_logs.o rmd160.o
+obj-$(CONFIG_LIDS_TPE) += lids_tpe.o
+obj-$(CONFIG_LIDS_TDE) += lids_tde.o
+obj-$(CONFIG_LIDS_SA_THROUGH_NET) += klids.o lids_net.o
 
 ifneq ($(CONFIG_IA64),y)
 # According to Alan Modra <alan@linuxcare.com.au>, the -fno-omit-frame-pointer is
diff -durN kernel.orig/kernel/module.c kernel/kernel/module.c
--- kernel.orig/kernel/module.c	2007-03-20 14:09:05.000000000 +1000
+++ kernel/kernel/module.c	2007-03-20 14:53:00.000000000 +1000
@@ -11,6 +11,10 @@
 #include <linux/kmod.h>
 #include <linux/seq_file.h>
 
+#ifdef CONFIG_LIDS
+#include <linux/lids.h>
+#endif
+
 /*
  * Originally by Anonymous (as far as I know...)
  * Linux version by Bas Laarhoven <bas@vimec.nl>
@@ -498,6 +502,12 @@
 		goto err3;
 	}
 
+#ifdef CONFIG_LIDS_TPE
+	error = lids_module_tpe_permission(mod);
+	if (error < 0)
+		goto err3;
+#endif
+
 	if (module_arch_init(mod))
 		goto err3;
 
diff -durN kernel.orig/kernel/printk.c kernel/kernel/printk.c
--- kernel.orig/kernel/printk.c	2007-03-20 14:09:05.000000000 +1000
+++ kernel/kernel/printk.c	2007-03-20 14:53:00.000000000 +1000
@@ -308,7 +308,11 @@
 
 asmlinkage long sys_syslog(int type, char * buf, int len)
 {
+#ifdef CONFIG_LIDS
+	if ((type != 3) && !capable2(CAP_SYS_ADMIN))
+#else
 	if ((type != 3) && !capable(CAP_SYS_ADMIN))
+#endif
 		return -EPERM;
 	return do_syslog(type, buf, len);
 }
diff -durN kernel.orig/kernel/ptrace.c kernel/kernel/ptrace.c
--- kernel.orig/kernel/ptrace.c	2007-03-20 14:09:05.000000000 +1000
+++ kernel/kernel/ptrace.c	2007-03-20 14:53:00.000000000 +1000
@@ -71,6 +71,9 @@
  	    (current->gid != task->egid) ||
  	    (current->gid != task->sgid) ||
  	    (!cap_issubset(task->cap_permitted, current->cap_permitted)) ||
+#ifdef CONFIG_LIDS
+	    (!cap_issubset(task->lids_cap, current->lids_cap)) ||
+#endif
  	    (current->gid != task->gid)) && !capable(CAP_SYS_PTRACE))
 		goto bad;
 	rmb();
diff -durN kernel.orig/kernel/rmd160.c kernel/kernel/rmd160.c
--- kernel.orig/kernel/rmd160.c	1970-01-01 10:00:00.000000000 +1000
+++ kernel/kernel/rmd160.c	2007-03-20 14:53:00.000000000 +1000
@@ -0,0 +1,315 @@
+/********************************************************************\
+ *
+ *      FILE:     rmd160.c
+ *
+ *      CONTENTS: A sample C-implementation of the RIPEMD-160
+ *                hash-function.
+ *      TARGET:   any computer with an ANSI C compiler
+ *
+ *      AUTHOR:   Antoon Bosselaers, ESAT-COSIC
+ *      DATE:     1 March 1996
+ *      VERSION:  1.0
+ *
+ *      Copyright (c) Katholieke Universiteit Leuven
+ *      1996, All Rights Reserved
+ *
+\********************************************************************/
+
+/*  header files */
+#include "linux/string.h"
+#include "linux/rmd160.h"
+
+/********************************************************************/
+
+void MDinit(dword *MDbuf)
+{
+   MDbuf[0] = 0x67452301UL;
+   MDbuf[1] = 0xefcdab89UL;
+   MDbuf[2] = 0x98badcfeUL;
+   MDbuf[3] = 0x10325476UL;
+   MDbuf[4] = 0xc3d2e1f0UL;
+
+   return;
+}
+
+/********************************************************************/
+
+void compress(dword *MDbuf, dword *X)
+{
+   dword aa = MDbuf[0],  bb = MDbuf[1],  cc = MDbuf[2],
+         dd = MDbuf[3],  ee = MDbuf[4];
+   dword aaa = MDbuf[0], bbb = MDbuf[1], ccc = MDbuf[2],
+         ddd = MDbuf[3], eee = MDbuf[4];
+
+   /* round 1 */
+   FF(aa, bb, cc, dd, ee, X[ 0], 11);
+   FF(ee, aa, bb, cc, dd, X[ 1], 14);
+   FF(dd, ee, aa, bb, cc, X[ 2], 15);
+   FF(cc, dd, ee, aa, bb, X[ 3], 12);
+   FF(bb, cc, dd, ee, aa, X[ 4],  5);
+   FF(aa, bb, cc, dd, ee, X[ 5],  8);
+   FF(ee, aa, bb, cc, dd, X[ 6],  7);
+   FF(dd, ee, aa, bb, cc, X[ 7],  9);
+   FF(cc, dd, ee, aa, bb, X[ 8], 11);
+   FF(bb, cc, dd, ee, aa, X[ 9], 13);
+   FF(aa, bb, cc, dd, ee, X[10], 14);
+   FF(ee, aa, bb, cc, dd, X[11], 15);
+   FF(dd, ee, aa, bb, cc, X[12],  6);
+   FF(cc, dd, ee, aa, bb, X[13],  7);
+   FF(bb, cc, dd, ee, aa, X[14],  9);
+   FF(aa, bb, cc, dd, ee, X[15],  8);
+
+   /* round 2 */
+   GG(ee, aa, bb, cc, dd, X[ 7],  7);
+   GG(dd, ee, aa, bb, cc, X[ 4],  6);
+   GG(cc, dd, ee, aa, bb, X[13],  8);
+   GG(bb, cc, dd, ee, aa, X[ 1], 13);
+   GG(aa, bb, cc, dd, ee, X[10], 11);
+   GG(ee, aa, bb, cc, dd, X[ 6],  9);
+   GG(dd, ee, aa, bb, cc, X[15],  7);
+   GG(cc, dd, ee, aa, bb, X[ 3], 15);
+   GG(bb, cc, dd, ee, aa, X[12],  7);
+   GG(aa, bb, cc, dd, ee, X[ 0], 12);
+   GG(ee, aa, bb, cc, dd, X[ 9], 15);
+   GG(dd, ee, aa, bb, cc, X[ 5],  9);
+   GG(cc, dd, ee, aa, bb, X[ 2], 11);
+   GG(bb, cc, dd, ee, aa, X[14],  7);
+   GG(aa, bb, cc, dd, ee, X[11], 13);
+   GG(ee, aa, bb, cc, dd, X[ 8], 12);
+
+   /* round 3 */
+   HH(dd, ee, aa, bb, cc, X[ 3], 11);
+   HH(cc, dd, ee, aa, bb, X[10], 13);
+   HH(bb, cc, dd, ee, aa, X[14],  6);
+   HH(aa, bb, cc, dd, ee, X[ 4],  7);
+   HH(ee, aa, bb, cc, dd, X[ 9], 14);
+   HH(dd, ee, aa, bb, cc, X[15],  9);
+   HH(cc, dd, ee, aa, bb, X[ 8], 13);
+   HH(bb, cc, dd, ee, aa, X[ 1], 15);
+   HH(aa, bb, cc, dd, ee, X[ 2], 14);
+   HH(ee, aa, bb, cc, dd, X[ 7],  8);
+   HH(dd, ee, aa, bb, cc, X[ 0], 13);
+   HH(cc, dd, ee, aa, bb, X[ 6],  6);
+   HH(bb, cc, dd, ee, aa, X[13],  5);
+   HH(aa, bb, cc, dd, ee, X[11], 12);
+   HH(ee, aa, bb, cc, dd, X[ 5],  7);
+   HH(dd, ee, aa, bb, cc, X[12],  5);
+
+   /* round 4 */
+   II(cc, dd, ee, aa, bb, X[ 1], 11);
+   II(bb, cc, dd, ee, aa, X[ 9], 12);
+   II(aa, bb, cc, dd, ee, X[11], 14);
+   II(ee, aa, bb, cc, dd, X[10], 15);
+   II(dd, ee, aa, bb, cc, X[ 0], 14);
+   II(cc, dd, ee, aa, bb, X[ 8], 15);
+   II(bb, cc, dd, ee, aa, X[12],  9);
+   II(aa, bb, cc, dd, ee, X[ 4],  8);
+   II(ee, aa, bb, cc, dd, X[13],  9);
+   II(dd, ee, aa, bb, cc, X[ 3], 14);
+   II(cc, dd, ee, aa, bb, X[ 7],  5);
+   II(bb, cc, dd, ee, aa, X[15],  6);
+   II(aa, bb, cc, dd, ee, X[14],  8);
+   II(ee, aa, bb, cc, dd, X[ 5],  6);
+   II(dd, ee, aa, bb, cc, X[ 6],  5);
+   II(cc, dd, ee, aa, bb, X[ 2], 12);
+
+   /* round 5 */
+   JJ(bb, cc, dd, ee, aa, X[ 4],  9);
+   JJ(aa, bb, cc, dd, ee, X[ 0], 15);
+   JJ(ee, aa, bb, cc, dd, X[ 5],  5);
+   JJ(dd, ee, aa, bb, cc, X[ 9], 11);
+   JJ(cc, dd, ee, aa, bb, X[ 7],  6);
+   JJ(bb, cc, dd, ee, aa, X[12],  8);
+   JJ(aa, bb, cc, dd, ee, X[ 2], 13);
+   JJ(ee, aa, bb, cc, dd, X[10], 12);
+   JJ(dd, ee, aa, bb, cc, X[14],  5);
+   JJ(cc, dd, ee, aa, bb, X[ 1], 12);
+   JJ(bb, cc, dd, ee, aa, X[ 3], 13);
+   JJ(aa, bb, cc, dd, ee, X[ 8], 14);
+   JJ(ee, aa, bb, cc, dd, X[11], 11);
+   JJ(dd, ee, aa, bb, cc, X[ 6],  8);
+   JJ(cc, dd, ee, aa, bb, X[15],  5);
+   JJ(bb, cc, dd, ee, aa, X[13],  6);
+
+   /* parallel round 1 */
+   JJJ(aaa, bbb, ccc, ddd, eee, X[ 5],  8);
+   JJJ(eee, aaa, bbb, ccc, ddd, X[14],  9);
+   JJJ(ddd, eee, aaa, bbb, ccc, X[ 7],  9);
+   JJJ(ccc, ddd, eee, aaa, bbb, X[ 0], 11);
+   JJJ(bbb, ccc, ddd, eee, aaa, X[ 9], 13);
+   JJJ(aaa, bbb, ccc, ddd, eee, X[ 2], 15);
+   JJJ(eee, aaa, bbb, ccc, ddd, X[11], 15);
+   JJJ(ddd, eee, aaa, bbb, ccc, X[ 4],  5);
+   JJJ(ccc, ddd, eee, aaa, bbb, X[13],  7);
+   JJJ(bbb, ccc, ddd, eee, aaa, X[ 6],  7);
+   JJJ(aaa, bbb, ccc, ddd, eee, X[15],  8);
+   JJJ(eee, aaa, bbb, ccc, ddd, X[ 8], 11);
+   JJJ(ddd, eee, aaa, bbb, ccc, X[ 1], 14);
+   JJJ(ccc, ddd, eee, aaa, bbb, X[10], 14);
+   JJJ(bbb, ccc, ddd, eee, aaa, X[ 3], 12);
+   JJJ(aaa, bbb, ccc, ddd, eee, X[12],  6);
+
+   /* parallel round 2 */
+   III(eee, aaa, bbb, ccc, ddd, X[ 6],  9);
+   III(ddd, eee, aaa, bbb, ccc, X[11], 13);
+   III(ccc, ddd, eee, aaa, bbb, X[ 3], 15);
+   III(bbb, ccc, ddd, eee, aaa, X[ 7],  7);
+   III(aaa, bbb, ccc, ddd, eee, X[ 0], 12);
+   III(eee, aaa, bbb, ccc, ddd, X[13],  8);
+   III(ddd, eee, aaa, bbb, ccc, X[ 5],  9);
+   III(ccc, ddd, eee, aaa, bbb, X[10], 11);
+   III(bbb, ccc, ddd, eee, aaa, X[14],  7);
+   III(aaa, bbb, ccc, ddd, eee, X[15],  7);
+   III(eee, aaa, bbb, ccc, ddd, X[ 8], 12);
+   III(ddd, eee, aaa, bbb, ccc, X[12],  7);
+   III(ccc, ddd, eee, aaa, bbb, X[ 4],  6);
+   III(bbb, ccc, ddd, eee, aaa, X[ 9], 15);
+   III(aaa, bbb, ccc, ddd, eee, X[ 1], 13);
+   III(eee, aaa, bbb, ccc, ddd, X[ 2], 11);
+
+   /* parallel round 3 */
+   HHH(ddd, eee, aaa, bbb, ccc, X[15],  9);
+   HHH(ccc, ddd, eee, aaa, bbb, X[ 5],  7);
+   HHH(bbb, ccc, ddd, eee, aaa, X[ 1], 15);
+   HHH(aaa, bbb, ccc, ddd, eee, X[ 3], 11);
+   HHH(eee, aaa, bbb, ccc, ddd, X[ 7],  8);
+   HHH(ddd, eee, aaa, bbb, ccc, X[14],  6);
+   HHH(ccc, ddd, eee, aaa, bbb, X[ 6],  6);
+   HHH(bbb, ccc, ddd, eee, aaa, X[ 9], 14);
+   HHH(aaa, bbb, ccc, ddd, eee, X[11], 12);
+   HHH(eee, aaa, bbb, ccc, ddd, X[ 8], 13);
+   HHH(ddd, eee, aaa, bbb, ccc, X[12],  5);
+   HHH(ccc, ddd, eee, aaa, bbb, X[ 2], 14);
+   HHH(bbb, ccc, ddd, eee, aaa, X[10], 13);
+   HHH(aaa, bbb, ccc, ddd, eee, X[ 0], 13);
+   HHH(eee, aaa, bbb, ccc, ddd, X[ 4],  7);
+   HHH(ddd, eee, aaa, bbb, ccc, X[13],  5);
+
+   /* parallel round 4 */
+   GGG(ccc, ddd, eee, aaa, bbb, X[ 8], 15);
+   GGG(bbb, ccc, ddd, eee, aaa, X[ 6],  5);
+   GGG(aaa, bbb, ccc, ddd, eee, X[ 4],  8);
+   GGG(eee, aaa, bbb, ccc, ddd, X[ 1], 11);
+   GGG(ddd, eee, aaa, bbb, ccc, X[ 3], 14);
+   GGG(ccc, ddd, eee, aaa, bbb, X[11], 14);
+   GGG(bbb, ccc, ddd, eee, aaa, X[15],  6);
+   GGG(aaa, bbb, ccc, ddd, eee, X[ 0], 14);
+   GGG(eee, aaa, bbb, ccc, ddd, X[ 5],  6);
+   GGG(ddd, eee, aaa, bbb, ccc, X[12],  9);
+   GGG(ccc, ddd, eee, aaa, bbb, X[ 2], 12);
+   GGG(bbb, ccc, ddd, eee, aaa, X[13],  9);
+   GGG(aaa, bbb, ccc, ddd, eee, X[ 9], 12);
+   GGG(eee, aaa, bbb, ccc, ddd, X[ 7],  5);
+   GGG(ddd, eee, aaa, bbb, ccc, X[10], 15);
+   GGG(ccc, ddd, eee, aaa, bbb, X[14],  8);
+
+   /* parallel round 5 */
+   FFF(bbb, ccc, ddd, eee, aaa, X[12] ,  8);
+   FFF(aaa, bbb, ccc, ddd, eee, X[15] ,  5);
+   FFF(eee, aaa, bbb, ccc, ddd, X[10] , 12);
+   FFF(ddd, eee, aaa, bbb, ccc, X[ 4] ,  9);
+   FFF(ccc, ddd, eee, aaa, bbb, X[ 1] , 12);
+   FFF(bbb, ccc, ddd, eee, aaa, X[ 5] ,  5);
+   FFF(aaa, bbb, ccc, ddd, eee, X[ 8] , 14);
+   FFF(eee, aaa, bbb, ccc, ddd, X[ 7] ,  6);
+   FFF(ddd, eee, aaa, bbb, ccc, X[ 6] ,  8);
+   FFF(ccc, ddd, eee, aaa, bbb, X[ 2] , 13);
+   FFF(bbb, ccc, ddd, eee, aaa, X[13] ,  6);
+   FFF(aaa, bbb, ccc, ddd, eee, X[14] ,  5);
+   FFF(eee, aaa, bbb, ccc, ddd, X[ 0] , 15);
+   FFF(ddd, eee, aaa, bbb, ccc, X[ 3] , 13);
+   FFF(ccc, ddd, eee, aaa, bbb, X[ 9] , 11);
+   FFF(bbb, ccc, ddd, eee, aaa, X[11] , 11);
+
+   /* combine results */
+   ddd += cc + MDbuf[1];               /* final result for MDbuf[0] */
+   MDbuf[1] = MDbuf[2] + dd + eee;
+   MDbuf[2] = MDbuf[3] + ee + aaa;
+   MDbuf[3] = MDbuf[4] + aa + bbb;
+   MDbuf[4] = MDbuf[0] + bb + ccc;
+   MDbuf[0] = ddd;
+
+   return;
+}
+
+/********************************************************************/
+
+void MDfinish(dword *MDbuf, byte *strptr, dword lswlen, dword mswlen)
+{
+   unsigned int i;                                 /* counter       */
+   dword        X[16];                             /* message words */
+
+   memset(X, 0, 16*sizeof(dword));
+
+   /* put bytes from strptr into X */
+   for (i=0; i<(lswlen&63); i++) {
+      /* byte i goes into word X[i div 4] at pos.  8*(i mod 4)  */
+      X[i>>2] ^= (dword) *strptr++ << (8 * (i&3));
+   }
+
+   /* append the bit m_n == 1 */
+   X[(lswlen>>2)&15] ^= (dword)1 << (8*(lswlen&3) + 7);
+
+   if ((lswlen & 63) > 55) {
+      /* length goes to next block */
+      compress(MDbuf, X);
+      memset(X, 0, 16*sizeof(dword));
+   }
+
+   /* append length in bits*/
+   X[14] = lswlen << 3;
+   X[15] = (lswlen >> 29) | (mswlen << 3);
+   compress(MDbuf, X);
+
+   return;
+}
+
+/********************************************************************/
+
+void RMD(byte *message,byte *hashcode)
+/*
+ * Return hash in hascode variable.
+ * Need RMDSize/8 bytes.
+ */
+{
+   dword         MDbuf[RMDsize/32];   /* contains (A, B, C, D(, E))   */
+   dword         X[16];               /* current 16-word chunk        */
+   unsigned int  i;                   /* counter                      */
+   dword         length;              /* length in bytes of message   */
+   dword         nbytes;              /* # of bytes not yet processed */
+
+   /* initialize */
+   MDinit(MDbuf);
+   length = (dword)strlen((char *)message);
+
+   /* process message in 16-word chunks */
+   for (nbytes=length; nbytes > 63; nbytes-=64) {
+      for (i=0; i<16; i++) {
+         X[i] = BYTES_TO_DWORD(message);
+         message += 4;
+      }
+      compress(MDbuf, X);
+   }                                    /* length mod 64 bytes left */
+
+   /* finish: */
+   MDfinish(MDbuf, message, length, 0);
+
+   for (i=0; i<RMDsize/8; i+=4) {
+      hashcode[i]   =  MDbuf[i>>2];         /* implicit cast to byte  */
+      hashcode[i+1] = (MDbuf[i>>2] >>  8);  /*  extracts the 8 least  */
+      hashcode[i+2] = (MDbuf[i>>2] >> 16);  /*  significant bits.     */
+      hashcode[i+3] = (MDbuf[i>>2] >> 24);
+   }
+}
+
+
+
+
+/************************ end of file rmd160.c **********************/
+
+
+
+
+
+
+
diff -durN kernel.orig/kernel/signal.c kernel/kernel/signal.c
--- kernel.orig/kernel/signal.c	2007-03-20 14:09:05.000000000 +1000
+++ kernel/kernel/signal.c	2007-03-20 14:53:01.000000000 +1000
@@ -16,6 +16,12 @@
 
 #include <asm/uaccess.h>
 
+#ifdef CONFIG_LIDS
+#include <linux/lids.h>
+extern int lids_local_pid;
+extern pid_t lids_protected_pid[];
+extern int lids_last_pid;
+#endif
 /*
  * SLAB caches for signal bits.
  */
@@ -547,6 +553,40 @@
 	ret = -EPERM;
 	if (bad_signal(sig, info, t))
 		goto out_nolock;
+#ifdef CONFIG_LIDS
+	LIDS_DBG("pid %i want to kill pid %d with sig %i\n",
+		 current->pid, t->pid, sig);
+	if (cap_raised(t->lids_cap, CAP_PROTECTED) ) {
+		LIDS_DBG("  but pid %i is protected\n", t->pid);
+		if (current->pid && (current->pid != t->pid) &&
+		    ((sig != SIGCHLD) || (current->p_pptr->pid != t->pid)) &&
+		    (sig != 0)) {
+			if ((sig != SIGALRM) || ((unsigned long) info != 1)) {
+				if (!lids_cap_raised(CAP_KILL_PROTECTED, 1)) {
+					LIDS_DBG("  sadly, pid %i did not have "
+						 "CAP_KILL_PROTECTED\n",
+						 current->pid);
+					lids_security_alert("Attempt to kill "
+							    "pid=%d with "
+							    "sig=%d", t->pid,
+							    sig);
+					goto out_nolock;
+				}
+				LIDS_DBG("  happily, pid %i got "
+					 "CAP_KILL_PROTECTED. -> pid %i "
+					 "killed!\n", current->pid, t->pid);
+			} else {
+				LIDS_DBG("  happily, pid %i got SIGALRM. -> "
+					 "from kernel!\n", t->pid);
+			}
+		} else {
+				LIDS_DBG("  happily, it's coming from itself "
+					 "or the kernel, or it's SIGCHLD from "
+					 "a child.. so that's ok..\n");
+		}
+
+	}
+#endif
 
 	/* The null signal is a permissions and process existence probe.
 	   No signal is actually delivered.  Same goes for zombies. */
diff -durN kernel.orig/kernel/sys.c kernel/kernel/sys.c
--- kernel.orig/kernel/sys.c	2007-03-20 14:09:05.000000000 +1000
+++ kernel/kernel/sys.c	2007-03-20 14:53:01.000000000 +1000
@@ -380,6 +380,12 @@
 	int new_rgid = old_rgid;
 	int new_egid = old_egid;
 
+#ifdef CONFIG_LIDS
+	if (!lids_cap_raised(CAP_SETGID, 1)) {
+		lids_cap_log(CAP_SETGID);
+		return -EPERM;
+	}
+#endif
 	if (rgid != (gid_t) -1) {
 		if ((old_rgid == rgid) ||
 		    (current->egid==rgid) ||
@@ -421,6 +427,32 @@
 {
 	int old_egid = current->egid;
 
+#ifdef CONFIG_LIDS
+	if (!lids_cap_raised(CAP_SETGID, 1)) {
+		lids_cap_log(CAP_SETGID);
+		return -EPERM;
+	}
+	if ((gid == current->gid) || (gid == current->sgid))
+	{
+		if(old_egid != gid)
+		{
+			current->mm->dumpable=0;
+			wmb();
+		}
+		current->egid = current->fsgid = gid;
+		if (capable2(CAP_SETGID))
+			current->gid=current->sgid=gid;
+	}
+	else if (capable(CAP_SETGID))
+	{
+		if(old_egid != gid)
+		{
+			current->mm->dumpable=0;
+			wmb();
+		}
+		current->gid = current->egid = current->sgid = current->fsgid = gid;
+	}
+#else
 	if (capable(CAP_SETGID))
 	{
 		if(old_egid != gid)
@@ -439,6 +471,7 @@
 		}
 		current->egid = current->fsgid = gid;
 	}
+#endif
 	else
 		return -EPERM;
 	return 0;
@@ -540,6 +573,12 @@
 	new_euid = old_euid = current->euid;
 	old_suid = current->suid;
 
+#ifdef CONFIG_LIDS
+	if (!lids_cap_raised(CAP_SETUID, 1)) {
+		lids_cap_log(CAP_SETUID);
+		return -EPERM;
+	}
+#endif
 	if (ruid != (uid_t) -1) {
 		new_ruid = ruid;
 		if ((old_ruid != ruid) &&
@@ -600,12 +639,32 @@
 	old_suid = current->suid;
 	new_suid = old_suid;
 	
+#ifdef CONFIG_LIDS
+	if (!lids_cap_raised(CAP_SETUID, 1)) {
+		lids_cap_log(CAP_SETUID);
+		return -EPERM;
+	}
+	if ((uid != current->uid) && (uid != new_suid))
+		if (!capable(CAP_SETUID))
+			return -EPERM;
+		else {
+			if (uid != old_ruid && set_user(uid, old_euid != uid) < 0)
+				return -EAGAIN;
+			new_suid = uid;
+		}
+	else if (capable2(CAP_SETUID)) {
+		if (uid != old_ruid && set_user(uid, old_euid != uid) < 0)
+			return -EAGAIN;
+		new_suid = uid;
+	}
+#else
 	if (capable(CAP_SETUID)) {
 		if (uid != old_ruid && set_user(uid, old_euid != uid) < 0)
 			return -EAGAIN;
 		new_suid = uid;
 	} else if ((uid != current->uid) && (uid != new_suid))
 		return -EPERM;
+#endif
 
 	if (old_euid != uid)
 	{
@@ -633,6 +692,24 @@
 	int old_euid = current->euid;
 	int old_suid = current->suid;
 
+#ifdef CONFIG_LIDS
+	if (!lids_cap_raised(CAP_SETUID, 1)) {
+		lids_cap_log(CAP_SETUID);
+		return -EPERM;
+	}
+	if ((ruid != (uid_t) -1) && (ruid != current->uid) &&
+	    (ruid != current->euid) && (ruid != current->suid) &&
+	    (!capable(CAP_SETUID)))
+		return -EPERM;
+	if ((euid != (uid_t) -1) && (euid != current->uid) &&
+	    (euid != current->euid) && (euid != current->suid) &&
+	    (!capable(CAP_SETUID)))
+		return -EPERM;
+	if ((suid != (uid_t) -1) && (suid != current->uid) &&
+	    (suid != current->euid) && (suid != current->suid) &&
+	    (!capable(CAP_SETUID)))
+		return -EPERM;
+#else
 	if (!capable(CAP_SETUID)) {
 		if ((ruid != (uid_t) -1) && (ruid != current->uid) &&
 		    (ruid != current->euid) && (ruid != current->suid))
@@ -644,6 +721,7 @@
 		    (suid != current->euid) && (suid != current->suid))
 			return -EPERM;
 	}
+#endif
 	if (ruid != (uid_t) -1) {
 		if (ruid != current->uid && set_user(ruid, euid != current->euid) < 0)
 			return -EAGAIN;
@@ -683,6 +761,24 @@
  */
 asmlinkage long sys_setresgid(gid_t rgid, gid_t egid, gid_t sgid)
 {
+#ifdef CONFIG_LIDS
+	if (!lids_cap_raised(CAP_SETGID, 1)) {
+		lids_cap_log(CAP_SETGID);
+		return -EPERM;
+	}
+	if ((rgid != (gid_t) -1) && (rgid != current->gid) &&
+	    (rgid != current->egid) && (rgid != current->sgid) &&
+	    (!capable(CAP_SETGID)))
+		return -EPERM;
+	if ((egid != (gid_t) -1) && (egid != current->gid) &&
+	    (egid != current->egid) && (egid != current->sgid) &&
+	    (!capable(CAP_SETGID)))
+		return -EPERM;
+	if ((sgid != (gid_t) -1) && (sgid != current->gid) &&
+	    (sgid != current->egid) && (sgid != current->sgid) &&
+	    (!capable(CAP_SETGID)))
+		return -EPERM;
+#else
 	if (!capable(CAP_SETGID)) {
 		if ((rgid != (gid_t) -1) && (rgid != current->gid) &&
 		    (rgid != current->egid) && (rgid != current->sgid))
@@ -694,6 +790,7 @@
 		    (sgid != current->egid) && (sgid != current->sgid))
 			return -EPERM;
 	}
+#endif
 	if (egid != (gid_t) -1) {
 		if (egid != current->egid)
 		{
@@ -733,6 +830,11 @@
 	int old_fsuid;
 
 	old_fsuid = current->fsuid;
+#ifdef CONFIG_LIDS
+	if (!lids_cap_raised(CAP_SETUID, 1)) {
+		lids_cap_log(CAP_SETUID);
+	} else
+#endif
 	if (uid == current->uid || uid == current->euid ||
 	    uid == current->suid || uid == current->fsuid || 
 	    capable(CAP_SETUID))
@@ -775,6 +877,11 @@
 	int old_fsgid;
 
 	old_fsgid = current->fsgid;
+#ifdef CONFIG_LIDS
+	if (!lids_cap_raised(CAP_SETGID, 1)) {
+		lids_cap_log(CAP_SETGID);
+	} else
+#endif
 	if (gid == current->gid || gid == current->egid ||
 	    gid == current->sgid || gid == current->fsgid || 
 	    capable(CAP_SETGID))
diff -durN kernel.orig/kernel/sysctl.c kernel/kernel/sysctl.c
--- kernel.orig/kernel/sysctl.c	2007-03-20 14:09:05.000000000 +1000
+++ kernel/kernel/sysctl.c	2007-03-20 14:53:02.000000000 +1000
@@ -38,7 +38,9 @@
 #endif
 
 #if defined(CONFIG_SYSCTL)
-
+#ifdef CONFIG_LIDS
+#include <linux/lids.h>
+#endif
 /* External variables not in a header file. */
 extern int panic_timeout;
 extern int C_A_D;
@@ -117,6 +119,9 @@
 static ctl_table debug_table[];
 static ctl_table dev_table[];
 extern ctl_table random_table[];
+#ifdef CONFIG_LIDS
+extern ctl_table lids_table[];
+#endif
 
 /* /proc declarations: */
 
@@ -153,6 +158,9 @@
 	{CTL_FS, "fs", NULL, 0, 0555, fs_table},
 	{CTL_DEBUG, "debug", NULL, 0, 0555, debug_table},
         {CTL_DEV, "dev", NULL, 0, 0555, dev_table},
+#ifdef CONFIG_LIDS
+	{CTL_LIDS, "lids", NULL, 0, 0500, lids_table},
+#endif
 	{0}
 };
 
@@ -320,6 +328,14 @@
 	{0}
 };  
 
+#ifdef CONFIG_LIDS
+static ctl_table lids_table[] = {
+	{LIDS_LOCKS, "locks", NULL, sizeof(int),
+	 0600, NULL, &lids_proc_locks_sysctl},
+	{0}
+};
+#endif
+
 extern void init_irq_proc (void);
 
 void __init sysctl_init(void)
@@ -933,7 +949,18 @@
 int proc_dointvec(ctl_table *table, int write, struct file *filp,
 		     void *buffer, size_t *lenp)
 {
+#ifdef CONFIG_LIDS
+	if (!write || (capable(CAP_SYS_ADMIN)))
+		return do_proc_dointvec(table, write, filp,
+					buffer, lenp, 1, OP_SET);
+	else {
+		lids_security_alert("Attempt to write in sysctl %s",
+				    table->procname);
+		return  -EACCES;
+	}
+#else
     return do_proc_dointvec(table,write,filp,buffer,lenp,1,OP_SET);
+#endif
 }
 
 /*
@@ -943,6 +970,12 @@
 int proc_dointvec_bset(ctl_table *table, int write, struct file *filp,
 			void *buffer, size_t *lenp)
 {
+#ifdef CONFIG_LIDS
+	if(write && !capable(CAP_SYS_MODULE)) {
+		lids_security_alert("Attempt to modify capabilities boundig set");
+		return -EPERM;
+	}
+#endif
 	if (!capable(CAP_SYS_MODULE)) {
 		return -EPERM;
 	}
@@ -974,6 +1007,14 @@
 	#define TMPBUFLEN 20
 	char buf[TMPBUFLEN], *p;
 	
+#ifdef CONFIG_LIDS
+	if (write && !capable(CAP_SYS_ADMIN)) {
+		lids_security_alert("try to write in sysctl %s",
+				    table->procname);
+		return  -EACCES;
+	}
+#endif
+
 	if (!table->data || !table->maxlen || !*lenp ||
 	    (filp->f_pos && !write)) {
 		*lenp = 0;
@@ -1235,7 +1276,18 @@
 int proc_dointvec_jiffies(ctl_table *table, int write, struct file *filp,
 			  void *buffer, size_t *lenp)
 {
+#ifdef CONFIG_LIDS
+	if (!write || capable(CAP_SYS_ADMIN))
+		return do_proc_dointvec(table, write, filp,
+					buffer, lenp, HZ, OP_SET);
+	else {
+		lids_security_alert("try to write in sysctl %s",
+				    table->procname);
+		return  -EACCES;
+	}
+#else
     return do_proc_dointvec(table,write,filp,buffer,lenp,HZ,OP_SET);
+#endif
 }
 
 #else /* CONFIG_PROC_FS */
diff -durN kernel.orig/Makefile kernel/Makefile
--- kernel.orig/Makefile	2007-03-20 14:08:05.000000000 +1000
+++ kernel/Makefile	2007-03-20 14:53:03.000000000 +1000
@@ -1,7 +1,7 @@
 VERSION = 2
 PATCHLEVEL = 4
 SUBLEVEL = 19
-EXTRAVERSION = -rmk7-pxa2-greenphone
+EXTRAVERSION = -rmk7-pxa2-lids-greenphone
 
 KERNELRELEASE=$(VERSION).$(PATCHLEVEL).$(SUBLEVEL)$(EXTRAVERSION)
 
diff -durN kernel.orig/mm/mmap.c kernel/mm/mmap.c
--- kernel.orig/mm/mmap.c	2007-03-20 14:09:05.000000000 +1000
+++ kernel/mm/mmap.c	2007-03-20 14:53:03.000000000 +1000
@@ -15,6 +15,10 @@
 #include <linux/fs.h>
 #include <linux/personality.h>
 
+#ifdef CONFIG_LIDS
+#include <linux/lids.h>
+#endif
+
 #include <asm/uaccess.h>
 #include <asm/pgalloc.h>
 #include <asm/tlb.h>
@@ -481,6 +485,12 @@
 		}
 	}
 
+#ifdef CONFIG_LIDS_TPE
+	error = lids_mmap_tpe_permission(file, prot, flags);
+	if (error < 0)
+		return error;
+#endif
+
 	/* Clear old maps */
 munmap_back:
 	vma = find_vma_prepare(mm, addr, &prev, &rb_link, &rb_parent);
diff -durN kernel.orig/net/core/rtnetlink.c kernel/net/core/rtnetlink.c
--- kernel.orig/net/core/rtnetlink.c	2007-03-20 14:09:06.000000000 +1000
+++ kernel/net/core/rtnetlink.c	2007-03-20 14:53:03.000000000 +1000
@@ -49,6 +49,9 @@
 #include <net/sock.h>
 #include <net/pkt_sched.h>
 
+#ifdef CONFIG_LIDS
+#include <linux/lids.h>
+#endif
 DECLARE_MUTEX(rtnl_sem);
 
 void rtnl_lock(void)
@@ -316,11 +319,23 @@
 	sz_idx = type>>2;
 	kind = type&3;
 
+#ifdef CONFIG_LIDS
+	if (kind != 2 && !cap_raised(NETLINK_CB(skb).eff_cap, CAP_NET_ADMIN) &&
+	    !cap_raised(current->lids_cap, CAP_NET_ADMIN) && lids_load &&
+	    lids_local_load) {
+		if (lids_acl_discovery) {
+			lids_alert(LIDS_CAP, NULL, -1, CAP_NET_ADMIN, "CAP_NET_ADMIN",
+				   "CAP_NET_ADMIN");
+			goto out;
+		}
+		lids_security_alert("NETLINK violate CAP_NET_ADMIN");
+#else
 	if (kind != 2 && !cap_raised(NETLINK_CB(skb).eff_cap, CAP_NET_ADMIN)) {
+#endif
 		*errp = -EPERM;
 		return -1;
 	}
-
+out:
 	if (kind == 2 && nlh->nlmsg_flags&NLM_F_DUMP) {
 		u32 rlen;
 
diff -durN kernel.orig/net/ipv4/af_inet.c kernel/net/ipv4/af_inet.c
--- kernel.orig/net/ipv4/af_inet.c	2007-03-20 14:09:06.000000000 +1000
+++ kernel/net/ipv4/af_inet.c	2007-03-20 14:53:03.000000000 +1000
@@ -116,6 +116,9 @@
 #if defined(CONFIG_NET_RADIO) || defined(CONFIG_NET_PCMCIA_RADIO)
 #include <linux/wireless.h>		/* Note : will define WIRELESS_EXT */
 #endif	/* CONFIG_NET_RADIO || CONFIG_NET_PCMCIA_RADIO */
+#ifdef CONFIG_LIDS
+#include <linux/lids.h>
+#endif
 
 struct linux_mib net_statistics[NR_CPUS*2];
 
@@ -503,8 +506,18 @@
 		return -EADDRNOTAVAIL;
 
 	snum = ntohs(addr->sin_port);
-	if (snum && snum < PROT_SOCK && !capable(CAP_NET_BIND_SERVICE))
+
+#ifdef CONFIG_LIDS
+	if (snum && snum < PROT_SOCK &&
+	    !(capable(CAP_NET_BIND_SERVICE) &&
+	      lids_bind_checker(snum))) {
+		lids_security_alert("try to bind to port %d", snum);
+#else
+
+	if (snum && snum < PROT_SOCK && !capable(CAP_NET_BIND_SERVICE)) {
+#endif
 		return -EACCES;
+	}
 
 	/*      We keep a pair of addresses. rcv_saddr is the one
 	 *      used by hash lookups, and saddr is used for transmit.
diff -durN kernel.orig/net/ipv4/lids_check_scan.c kernel/net/ipv4/lids_check_scan.c
--- kernel.orig/net/ipv4/lids_check_scan.c	1970-01-01 10:00:00.000000000 +1000
+++ kernel/net/ipv4/lids_check_scan.c	2007-03-20 14:53:03.000000000 +1000
@@ -0,0 +1,182 @@
+/*
+	linux/net/ipv4/lids_check_scan.c
+
+	Copy right by Huagang Xie(xie@gnuchina.org) for LIDS Project
+
+	200.5.17	add some pointer checkers.
+	2000.5.6 	fixed some condition contest.
+	2000.4.3	initially released
+*/
+
+#include <linux/lids.h>
+#include <linux/kernel.h>
+#include <linux/spinlock.h>
+#include <linux/config.h>
+#include <linux/types.h>
+#include <linux/fcntl.h>
+#include <linux/random.h>
+#include <linux/init.h>
+#include <linux/ipsec.h>
+
+#include <net/icmp.h>
+#include <net/tcp.h>
+#include <net/ipv6.h>
+
+#include <asm/segment.h>
+
+#include <linux/inet.h>
+#include <linux/stddef.h>
+#include <linux/timex.h>
+
+#define LIDS_WARNING		10
+#define LIDS_SCAN_TIMEOUT	3 * HZ
+#define LIDS_SCAN_TIME		10 * HZ
+
+struct lids_scan {
+	struct lids_scan *next, *pre;
+	__u32 addr;
+	unsigned long counter;
+	unsigned long lower_counter;
+	unsigned long create_time;
+	spinlock_t lock;
+	struct timer_list timer;
+} lids_scan_head;
+
+void
+free_scan(struct lids_scan *p)
+{
+	LIDS_DBG("free %d.%d.%d.%d\n", NIPQUAD(p->addr));
+	del_timer(&(p->timer));
+
+	spin_lock(&(p->lock));
+	spin_lock(&(p->pre->lock));
+	p->pre->next = p->next;
+	spin_unlock(&(p->pre->lock));
+	if (p->next) {
+		spin_lock(&(p->next->lock));
+		p->next->pre = p->pre;
+		spin_unlock(&(p->next->lock));
+	}
+	spin_unlock(&(p->lock));
+
+	kfree(p);
+	LIDS_DBG("out\n");
+}
+
+/*
+ *
+ */
+static void
+lids_proceed_scan(unsigned long __data)
+{
+	struct lids_scan *p = (struct lids_scan *) __data;
+	unsigned long current_time = jiffies;
+	unsigned long counter;
+	unsigned long lower_counter;
+	__u32 addr;
+
+	if (p) {
+		if (p->counter > LIDS_WARNING) {
+			addr = p->addr;
+			counter = p->counter;
+			lower_counter = p->lower_counter;
+
+			lids_security_alert("Port scan detected: %d.%d.%d.%d "
+					    "scanned %ld closed ports including "
+					    "%ld ports < 1024)",
+					    NIPQUAD(addr), counter, lower_counter);
+			free_scan(p);
+		} else {
+			if (current_time - p->create_time > LIDS_SCAN_TIME)
+				free_scan(p);
+			else
+				mod_timer(&(p->timer),
+					  LIDS_SCAN_TIMEOUT + current_time);
+		}
+	}
+	LIDS_DBG("exit\n");
+}
+
+/*
+ *
+ */
+struct lids_scan *
+lids_find_scan(__u32 addr)
+{
+	struct lids_scan *p;
+
+	LIDS_DBG("checking %d.%d.%d.%d\n", NIPQUAD(addr));
+
+	for (p = lids_scan_head.next; p != NULL; p = p->next) {
+		LIDS_DBG("searching exist: %d.%d.%d.%d\n", NIPQUAD(p->addr));
+		if (p->addr == addr) {
+			LIDS_DBG("exit from return not NULL\n");
+			return p;
+		}
+	}
+
+	LIDS_DBG("exit from return NULL\n");
+	return NULL;
+}
+
+/*
+ *	lids_check_scan ...
+ */
+int
+lids_check_scan(__u32 addr, __u16 port)
+{
+	struct lids_scan *p, *p1;
+	unsigned long current_time = jiffies;
+
+	LIDS_DBG("%d.%d.%d.%d : %d\n", NIPQUAD(addr), port);
+	if ((p = lids_find_scan(addr)) == NULL) {
+
+		p1 = &lids_scan_head;
+		p = (struct lids_scan *) kmalloc(sizeof (struct lids_scan),
+						 GFP_ATOMIC);
+		if (p == NULL) {
+			LIDS_DBG("kmalloc error, return -1\n");
+			return -1;
+		}
+		spin_lock_init(&(p->lock));
+
+		while ((p1->next) != NULL)
+			p1 = p1->next;
+
+		spin_lock(&(p1->lock));
+		p1->next = p;
+		spin_unlock(&(p1->lock));
+
+		spin_lock(&(p->lock));
+		p->pre = p1;
+		spin_unlock(&(p->lock));
+
+		p->next = NULL;
+		p->addr = addr;
+		p->counter = 0;
+		p->lower_counter = 0;
+		p->create_time = current_time;
+
+		init_timer(&(p->timer));
+		p->timer.expires = LIDS_SCAN_TIMEOUT + current_time;
+		p->timer.data = (unsigned long) p;
+		p->timer.function = &lids_proceed_scan;
+		add_timer(&(p->timer));
+	}
+	spin_lock(&(p->lock));
+	(p->counter)++;
+	if (port < 1024)
+		(p->lower_counter)++;
+	spin_unlock(&(p->lock));
+	LIDS_DBG("exit return 0\n");
+	return 0;
+}
+
+void
+lids_port_scanner_detector_init(void)
+{
+	static int initialized = 0;
+	if (!initialized)
+		spin_lock_init(&(lids_scan_head.lock));
+	initialized = 1;
+}
diff -durN kernel.orig/net/ipv4/Makefile kernel/net/ipv4/Makefile
--- kernel.orig/net/ipv4/Makefile	2007-03-20 14:09:06.000000000 +1000
+++ kernel/net/ipv4/Makefile	2007-03-20 14:53:03.000000000 +1000
@@ -25,5 +25,6 @@
 obj-$(CONFIG_NET_IPGRE) += ip_gre.o
 obj-$(CONFIG_SYN_COOKIES) += syncookies.o
 obj-$(CONFIG_IP_PNP) += ipconfig.o
+obj-$(CONFIG_LIDS_PORT_SCAN_DETECTOR) += lids_check_scan.o
 
 include $(TOPDIR)/Rules.make
diff -durN kernel.orig/net/ipv4/netfilter/ip_queue.c kernel/net/ipv4/netfilter/ip_queue.c
--- kernel.orig/net/ipv4/netfilter/ip_queue.c	2007-03-20 14:09:06.000000000 +1000
+++ kernel/net/ipv4/netfilter/ip_queue.c	2007-03-20 14:53:03.000000000 +1000
@@ -29,6 +29,10 @@
 #include <linux/netfilter_ipv4/ip_queue.h>
 #include <linux/netfilter_ipv4/ip_tables.h>
 
+#ifdef CONFIG_LIDS
+#include <linux/lids.h>
+#endif
+
 #define IPQ_QMAX_DEFAULT 1024
 #define IPQ_PROC_FS_NAME "ip_queue"
 #define NET_IPQ_QMAX 2088
@@ -490,8 +494,23 @@
 		RCV_SKB_FAIL(-EINVAL);
 	if (type <= IPQM_BASE)
 		return;
+#ifdef CONFIG_LIDS
+ 	if (!cap_raised(NETLINK_CB(skb).eff_cap, CAP_NET_ADMIN) ||
+	    (!cap_raised(current->lids_cap,CAP_NET_ADMIN) &&
+	     lids_load && lids_local_load)) {
+		if (!lids_acl_discovery) {
+ 			lids_security_alert("NetLink receiver "
+					    "violate CAP_NET_ADMIN");
+ 			RCV_SKB_FAIL(-EPERM);
+		}
+		lids_alert(LIDS_CAP, NULL, -1, CAP_NET_ADMIN,
+			   lids_caps_desc[CAP_NET_ADMIN],
+			   lids_caps_desc[CAP_NET_ADMIN]);
+ 	}
+#else
 	if(!cap_raised(NETLINK_CB(skb).eff_cap, CAP_NET_ADMIN))
 		RCV_SKB_FAIL(-EPERM);
+#endif
 	if (nlq->peer.pid && !nlq->peer.died
 	    && (nlq->peer.pid != nlh->nlmsg_pid)) {
 	    	printk(KERN_WARNING "ip_queue: peer pid changed from %d to "
diff -durN kernel.orig/net/ipv4/netfilter/ipt_MARK.c kernel/net/ipv4/netfilter/ipt_MARK.c
--- kernel.orig/net/ipv4/netfilter/ipt_MARK.c	2007-03-20 14:09:06.000000000 +1000
+++ kernel/net/ipv4/netfilter/ipt_MARK.c	2007-03-20 14:53:03.000000000 +1000
@@ -21,7 +21,28 @@
 		(*pskb)->nfmark = markinfo->mark;
 		(*pskb)->nfcache |= NFC_ALTERED;
 	}
-	return IPT_CONTINUE;
+
+#ifdef CONFIG_LIDS_NF_MARK
+	if(hooknum == NF_IP_LOCAL_OUT) {
+		struct iphdr *iph = (*pskb)->nh.iph;
+		struct inode *inode;
+
+		if (!(*pskb)->sk || !(*pskb)->sk->socket) {
+			return IPT_CONTINUE;
+		}
+		inode = SOCK_INODE((*pskb)->sk->socket);
+		if (!inode || !inode->i_security)
+			return IPT_CONTINUE;
+
+		markinfo = (struct ipt_mark_target_info *)(inode->i_security);
+		if ((*pskb)->nfmark != markinfo->mark) {
+			(*pskb)->nfmark = markinfo->mark;
+			(*pskb)->nfcache |= NFC_ALTERED;
+		}
+	}
+#endif
+
+        return IPT_CONTINUE;
 }
 
 static int
diff -durN kernel.orig/net/ipv4/tcp_ipv4.c kernel/net/ipv4/tcp_ipv4.c
--- kernel.orig/net/ipv4/tcp_ipv4.c	2007-03-20 14:09:06.000000000 +1000
+++ kernel/net/ipv4/tcp_ipv4.c	2007-03-20 14:53:03.000000000 +1000
@@ -63,6 +63,10 @@
 #include <linux/stddef.h>
 #include <linux/ipsec.h>
 
+#ifdef CONFIG_LIDS
+#include <linux/lids.h>
+#endif
+
 extern int sysctl_ip_dynaddr;
 extern int sysctl_ip_default_ttl;
 int sysctl_tcp_tw_reuse = 0;
@@ -1777,6 +1781,11 @@
 	return ret;
 
 no_tcp_socket:
+#ifdef CONFIG_LIDS_PORT_SCAN_DETECTOR
+	if (lids_load)
+		lids_check_scan(skb->nh.iph->saddr,
+				ntohs(th->dest));
+#endif
 	if (skb->len < (th->doff<<2) || tcp_checksum_complete(skb)) {
 bad_packet:
 		TCP_INC_STATS_BH(TcpInErrs);
diff -durN kernel.orig/net/ipv4/udp.c kernel/net/ipv4/udp.c
--- kernel.orig/net/ipv4/udp.c	2007-03-20 14:09:06.000000000 +1000
+++ kernel/net/ipv4/udp.c	2007-03-20 14:53:03.000000000 +1000
@@ -94,6 +94,9 @@
 #include <net/inet_common.h>
 #include <net/checksum.h>
 
+#ifdef CONFIG_LIDS_PORT_SCAN_DETECTOR
+#include <linux/lids.h>
+#endif
 /*
  *	Snmp MIB for the UDP layer
  */
@@ -927,6 +930,11 @@
 	if (udp_checksum_complete(skb))
 		goto csum_error;
 
+#ifdef CONFIG_LIDS_PORT_SCAN_DETECTOR
+	if (lids_load)
+		lids_check_scan(saddr, ntohs(uh->dest));
+#endif
+
 	UDP_INC_STATS_BH(UdpNoPorts);
 	icmp_send(skb, ICMP_DEST_UNREACH, ICMP_PORT_UNREACH, 0);
 
diff -durN kernel.orig/net/ipv6/af_inet6.c kernel/net/ipv6/af_inet6.c
--- kernel.orig/net/ipv6/af_inet6.c	2007-03-20 14:09:06.000000000 +1000
+++ kernel/net/ipv6/af_inet6.c	2007-03-20 14:53:04.000000000 +1000
@@ -61,6 +61,9 @@
 
 #include <asm/uaccess.h>
 #include <asm/system.h>
+#ifdef CONFIG_LIDS
+#include <linux/lids.h>
+#endif
 
 #ifdef MODULE
 static int unloadable = 0; /* XX: Turn to one when all is ok within the
@@ -265,8 +268,17 @@
 	}
 
 	snum = ntohs(addr->sin6_port);
-	if (snum && snum < PROT_SOCK && !capable(CAP_NET_BIND_SERVICE))
+#ifdef CONFIG_LIDS
+	if (snum && snum < PROT_SOCK &&
+	    !(capable(CAP_NET_BIND_SERVICE) &&
+	    lids_bind_checker(snum))) {
+		lids_security_alert("try to bind to port %d",snum);
+#else
+	if (snum && snum < PROT_SOCK &&
+	    !capable(CAP_NET_BIND_SERVICE)) {
+#endif
 		return -EACCES;
+	}
 
 	lock_sock(sk);
 
diff -durN kernel.orig/net/ipv6/netfilter/ip6_queue.c kernel/net/ipv6/netfilter/ip6_queue.c
--- kernel.orig/net/ipv6/netfilter/ip6_queue.c	2007-03-20 14:09:06.000000000 +1000
+++ kernel/net/ipv6/netfilter/ip6_queue.c	2007-03-20 14:53:04.000000000 +1000
@@ -42,6 +42,10 @@
 #include <linux/netfilter_ipv4/ip_tables.h>
 #include <linux/netfilter_ipv6/ip6_tables.h>
 
+#ifdef CONFIG_LIDS
+#include <linux/lids.h>
+#endif
+
 #define IPQ_QMAX_DEFAULT 1024
 #define IPQ_PROC_FS_NAME "ip6_queue"
 #define NET_IPQ_QMAX 2088
@@ -544,8 +548,23 @@
 		RCV_SKB_FAIL(-EINVAL);
 	if (type <= IPQM_BASE)
 		return;
+#ifdef CONFIG_LIDS
+ 	if(!cap_raised(NETLINK_CB(skb).eff_cap, CAP_NET_ADMIN) ||
+		       (!cap_raised(current->lids_cap, CAP_NET_ADMIN) &&
+		       lids_load && lids_local_load)) {
+		if (!lids_acl_discovery) {
+ 			lids_security_alert("NetLink receiver violate "
+					    "CAP_NET_ADMIN");
+ 			RCV_SKB_FAIL(-EPERM);
+		}
+		lids_alert(LIDS_CAP, NULL, -1, CAP_NET_ADMIN,
+			   lids_caps_desc[CAP_NET_ADMIN],
+			   lids_caps_desc[CAP_NET_ADMIN]);
+ 	}
+#else
 	if(!cap_raised(NETLINK_CB(skb).eff_cap, CAP_NET_ADMIN))
 		RCV_SKB_FAIL(-EPERM);
+#endif
 	if (nlq6->peer.pid && !nlq6->peer.died
 	    && (nlq6->peer.pid != nlh->nlmsg_pid)) {
 	    	printk(KERN_WARNING "ip6_queue: peer pid changed from %d to "
diff -durN kernel.orig/net/netlink/af_netlink.c kernel/net/netlink/af_netlink.c
--- kernel.orig/net/netlink/af_netlink.c	2007-03-20 14:09:07.000000000 +1000
+++ kernel/net/netlink/af_netlink.c	2007-03-20 14:53:04.000000000 +1000
@@ -599,6 +599,11 @@
 	 */
 	NETLINK_CB(skb).eff_cap = current->cap_effective;
 
+#ifdef CONFIG_LIDS
+	if (!capable(CAP_NET_ADMIN))
+		cap_lower(NETLINK_CB(skb).eff_cap, CAP_NET_ADMIN);
+#endif
+
 	err = -EFAULT;
 	if (memcpy_fromiovec(skb_put(skb,len), msg->msg_iov, len)) {
 		kfree_skb(skb);
diff -durN kernel.orig/net/socket.c kernel/net/socket.c
--- kernel.orig/net/socket.c	2007-03-20 14:09:07.000000000 +1000
+++ kernel/net/socket.c	2007-03-20 14:53:04.000000000 +1000
@@ -84,6 +84,9 @@
 #include <net/sock.h>
 #include <net/scm.h>
 #include <linux/netfilter.h>
+#ifdef CONFIG_LIDS_NETWORK
+#include <linux/lids.h>
+#endif
 
 static int sock_no_open(struct inode *irrelevant, struct file *dontcare);
 static ssize_t sock_read(struct file *file, char *buf,
@@ -503,6 +506,12 @@
 	int err;
 	struct scm_cookie scm;
 
+#ifdef CONFIG_LIDS_NETWORK
+	err = lids_socket_sendmsg(sock);
+	if (err)
+		return err;
+#endif
+
 	err = scm_send(sock, msg, &scm);
 	if (err >= 0) {
 		err = sock->ops->sendmsg(sock, msg, size, &scm);
@@ -515,6 +524,13 @@
 {
 	struct scm_cookie scm;
 
+#ifdef CONFIG_LIDS_NETWORK
+	int err;
+	err = lids_socket_recvmsg(sock);
+	if (err)
+		return err;
+#endif
+
 	memset(&scm, 0, sizeof(scm));
 
 	size = sock->ops->recvmsg(sock, msg, size, flags, &scm);
@@ -833,6 +849,11 @@
 	if (type < 0 || type >= SOCK_MAX)
 		return -EINVAL;
 
+#ifdef CONFIG_LIDS_NETWORK
+	i = lids_socket_create(family, type, protocol);
+	if (i)
+		return i;
+#endif
 	/* Compatibility.
 
 	   This uglymoron is moved from INET layer to here to avoid
@@ -892,6 +913,10 @@
 
 	*res = sock;
 
+#ifdef CONFIG_LIDS_NETWORK
+	lids_socket_post_create(sock, family, type, protocol);
+#endif
+
 out:
 	net_family_read_unlock();
 	return i;
@@ -1001,8 +1026,16 @@
 
 	if((sock = sockfd_lookup(fd,&err))!=NULL)
 	{
-		if((err=move_addr_to_kernel(umyaddr,addrlen,address))>=0)
+		if((err=move_addr_to_kernel(umyaddr,addrlen,address))>=0) {
+#ifdef CONFIG_LIDS_NETWORK
+			err = lids_socket_bind(sock, (struct sockaddr *)address, addrlen);
+			if (err) {
+				sockfd_put(sock);
+				return err;
+			}
+#endif
 			err = sock->ops->bind(sock, (struct sockaddr *)address, addrlen);
+		}
 		sockfd_put(sock);
 	}			
 	return err;
@@ -1023,6 +1056,13 @@
 	if ((sock = sockfd_lookup(fd, &err)) != NULL) {
 		if ((unsigned) backlog > SOMAXCONN)
 			backlog = SOMAXCONN;
+#ifdef CONFIG_LIDS_NETWORK
+		err = lids_socket_listen(sock, backlog);
+		if (err) {
+			sockfd_put(sock);
+			return err;
+		}
+#endif
 		err=sock->ops->listen(sock, backlog);
 		sockfd_put(sock);
 	}
@@ -1059,6 +1099,12 @@
 	newsock->type = sock->type;
 	newsock->ops = sock->ops;
 
+#ifdef CONFIG_LIDS_NETWORK
+	err = lids_socket_accept(sock, newsock);
+	if (err)
+		goto out_release;
+#endif
+
 	err = sock->ops->accept(sock, newsock, sock->file->f_flags);
 	if (err < 0)
 		goto out_release;
@@ -1113,6 +1159,13 @@
 	err = move_addr_to_kernel(uservaddr, addrlen, address);
 	if (err < 0)
 		goto out_put;
+
+#ifdef CONFIG_LIDS_NETWORK
+	err = lids_socket_connect(sock, (struct sockaddr *)address, addrlen);
+	if (err)
+		goto out_put;
+#endif
+
 	err = sock->ops->connect(sock, (struct sockaddr *) address, addrlen,
 				 sock->file->f_flags);
 out_put:
@@ -1135,6 +1188,11 @@
 	sock = sockfd_lookup(fd, &err);
 	if (!sock)
 		goto out;
+#ifdef CONFIG_LIDS_NETWORK
+	err = lids_socket_getsockname(sock);
+	if (err)
+		goto out_put;
+#endif
 	err = sock->ops->getname(sock, (struct sockaddr *)address, &len, 0);
 	if (err)
 		goto out_put;
@@ -1159,6 +1217,13 @@
 
 	if ((sock = sockfd_lookup(fd, &err))!=NULL)
 	{
+#ifdef CONFIG_LIDS_NETWORK
+		err = lids_socket_getpeername(sock);
+		if (err) {
+			sockfd_put(sock);
+			return err;
+		}
+#endif
 		err = sock->ops->getname(sock, (struct sockaddr *)address, &len, 1);
 		if (!err)
 			err=move_addr_to_user(address,len, usockaddr, usockaddr_len);
@@ -1287,6 +1352,13 @@
 			
 	if ((sock = sockfd_lookup(fd, &err))!=NULL)
 	{
+#ifdef CONFIG_LIDS_NETWORK
+		err = lids_socket_setsockopt(sock,level,optname);
+		if (err) {
+			sockfd_put(sock);
+			return err;
+		}
+#endif
 		if (level == SOL_SOCKET)
 			err=sock_setsockopt(sock,level,optname,optval,optlen);
 		else
@@ -1308,6 +1380,14 @@
 
 	if ((sock = sockfd_lookup(fd, &err))!=NULL)
 	{
+#ifdef CONFIG_LIDS_NETWORK
+		err = lids_socket_getsockopt(sock, level, optname);
+		if (err) {
+			sockfd_put(sock);
+			return err;
+		}
+#endif
+
 		if (level == SOL_SOCKET)
 			err=sock_getsockopt(sock,level,optname,optval,optlen);
 		else
@@ -1329,6 +1409,13 @@
 
 	if ((sock = sockfd_lookup(fd, &err))!=NULL)
 	{
+#ifdef CONFIG_LIDS_NETWORK
+		err = lids_socket_shutdown(sock, how);
+		if (err) {
+			sockfd_put(sock);
+			return err;
+		}
+#endif
 		err=sock->ops->shutdown(sock, how);
 		sockfd_put(sock);
 	}
