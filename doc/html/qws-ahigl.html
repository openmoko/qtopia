<?xml version="1.0" encoding="iso-8859-1"?>
<!DOCTYPE html
    PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
  <title>Qt 4.4: OpenGL for Embedded Systems Example</title>
  <link href="classic.css" rel="stylesheet" type="text/css" />
</head>
<body>
<table border="0" cellpadding="0" cellspacing="0" width="100%">
<tr>
<td align="left" valign="top" width="32"><a href="http://www.trolltech.com/products/qt"><img src="images/qt-logo.png" align="left" border="0" /></a></td>
<td width="1">&nbsp;&nbsp;</td><td class="postheader" valign="center"><a href="index.html"><font color="#004faf">Home</font></a>&nbsp;&middot; <a href="namespaces.html"><font color="#004faf">All&nbsp;Namespaces</font></a>&nbsp;&middot; <a href="classes.html"><font color="#004faf">All&nbsp;Classes</font></a>&nbsp;&middot; <a href="mainclasses.html"><font color="#004faf">Main&nbsp;Classes</font></a>&nbsp;&middot; <a href="groups.html"><font color="#004faf">Grouped&nbsp;Classes</font></a>&nbsp;&middot; <a href="modules.html"><font color="#004faf">Modules</font></a>&nbsp;&middot; <a href="functions.html"><font color="#004faf">Functions</font></a></td>
<td align="right" valign="top" width="230"></td></tr></table><h1 class="title">OpenGL for Embedded Systems Example<br /><span class="subtitle"></span>
</h1>
<p>Files:</p>
<ul>
<li><a href="qws-ahigl-qscreenahigl-qws-cpp.html">qws/ahigl/qscreenahigl_qws.cpp</a></li>
<li><a href="qws-ahigl-qscreenahigl-qws-h.html">qws/ahigl/qscreenahigl_qws.h</a></li>
<li><a href="qws-ahigl-qscreenahiglplugin-cpp.html">qws/ahigl/qscreenahiglplugin.cpp</a></li>
<li><a href="qws-ahigl-qwindowsurface-ahigl-cpp.html">qws/ahigl/qwindowsurface_ahigl.cpp</a></li>
<li><a href="qws-ahigl-qwindowsurface-ahigl-p-h.html">qws/ahigl/qwindowsurface_ahigl_p.h</a></li>
<li><a href="qws-ahigl-ahigl-pro.html">qws/ahigl/ahigl.pro</a></li>
</ul>
<a name="introduction"></a>
<h2>Introduction</h2>
<p>This example demonstrates how you can use OpenGL for Embedded Systems (ES) in your own screen driver and <a href="qt-embedded-accel.html#add-your-graphics-driver-to-qt-for-embedded-linux">add your graphics driver to Qt for Embedded Linux</a>. In <a href="qt-embedded.html">Qt for Embedded Linux</a>, painting is done in software, normally performed in two steps: First, each client renders its windows onto its window surface in memory using a paint engine. Then the server uses the screen driver to compose the window surface images and copy the composition to the screen. (See the <a href="qt-embedded-architecture.html">Qt for Embedded Linux Architecture</a> documentation for details.)</p>
<p>This example is not for the novice. It assumes the reader is familiar with both OpenGL and the screen driver framework demonstrated in the <a href="qws-svgalib.html">Accelerated Graphics Driver Example</a>.</p>
<p>An OpenGL screen driver for Qt for Embedded Linux can use OpenGL ES in three ways. First, the <a href="qwsserver.html">Qt for Embedded Linux server</a> can use the driver to compose multiple window images and then show the composition on the screen. Second, clients can use the driver to accelerate OpenGL painting operations using the QOpenGLPaintEngine class. Finally, clients can use the driver to do OpenGL operations with instances of the <a href="qglwidget.html">QGLWidget</a> class. This example implements all three cases.</p>
<p>The example uses an implementation of OpenGL ES from <a href="http://ati.amd.com">ATI</a> for the <a href="http://ati.amd.com/products/imageon238x/">Imageon 2380</a>. The OpenGL include files gl.h and egl.h must be installed to compile the example, and the OpenGL and EGL libraries must be installed for linking. If your target device is different, you must install the include files and libraries for that device, and you also might need to modify the example source code, if any API signatures in your EGL library differ from the ones used here.</p>
<p>After compiling and linking the example source, install the screen driver plugin with the command <tt>make install</tt>. To start an application that uses the plugin, you can either set the environment variable <a href="qt-embedded-envvars.html#qws-display">QWS_DISPLAY</a> and then start the application, or just start the application with the <tt>-display</tt> switch, as follows:</p>
<pre> myApplication -qws -display ahigl</pre>
<p>The example driver also implements an animated transition effect for use when showing new windows or reshowing windows that have been minimized. To enable this transition effect, run the application with <tt>-display ahigl:effects</tt>.</p>
<a name="the-class-definitions"></a>
<h2>The Class Definitions</h2>
<p>The example comprises three main classes plus some helper classes. The three main classes are the plugin (QAhiGLScreenPlugin), which is defined in qscreenahiglplugin.cpp, the screen driver (QAhiGLScreen), which is defined in qscreenahigl_qws.h, and the window surface (QAhiGLWindowSurface), which is defined in qwindowsurface_ahigl_p.h. The &quot;Ahi&quot; prefix in these class names stands for <i>ATI Handheld Interface</i>. The example was written for the ATI Imageon 2380, but it can also be used as a template for other ATI handheld devices.</p>
<a name="the-plugin-class-definition"></a>
<h3>The Plugin Class Definition</h3>
<p>The screen driver plugin is class QAhiGLScreenPlugin.</p>
<pre> class QAhiGLScreenPlugin : public QScreenDriverPlugin
 {
 public:
     QAhiGLScreenPlugin();

     QStringList keys() const;
     QScreen *create(const QString&amp;, int displayId);
 };</pre>
<p>QAhiGLScreenPlugin is derived from class <a href="qscreendriverplugin.html">QScreenDriverPlugin</a>, which in turn is derived from <a href="qobject.html">QObject</a>.</p>
<a name="the-screen-driver-class-definitions"></a>
<h3>The Screen Driver Class Definitions</h3>
<p>The screen driver classes are the public class QAhiGLScreen and its private implementation class QAhiGLScreenPrivate. QAhiGLScreen is derived from QGLScreen, which is derived from <a href="qscreen.html">QScreen</a>. If your screen driver will only do window compositions and display them, then you can derive your screen driver class directly from <a href="qscreen.html">QScreen</a>. But if your screen driver will do accelerated graphics rendering operations with the QOpenGLPaintEngine, or if it will handle instances of class <a href="qglwidget.html">QGLWidget</a>, then you must derive your screen driver class from QGLScreen.</p>
<pre> class QAhiGLScreen : public QGLScreen
 {
 public:
     QAhiGLScreen(int displayId);
     virtual ~QAhiGLScreen();

     bool initDevice();
     bool connect(const QString &amp;displaySpec);
     void disconnect();
     void shutdownDevice();

     void setMode(int width, int height, int depth);
     void blank(bool on);

     void exposeRegion(QRegion r, int changing);

     QWSWindowSurface* createSurface(QWidget *widget) const;
     QWSWindowSurface* createSurface(const QString &amp;key) const;

     bool hasOpenGL();

 private:
     void invalidateTexture(int windowIndex);
     void redrawScreen();
     void drawWindow(QWSWindow *win, qreal progress);
     void drawQuad(const QRect &amp;textureGeometry,
                   const QRect &amp;subGeometry,
                   const QRect &amp;screenGeometry);
     void drawQuadWavyFlag(const QRect &amp;textureGeometry,
                           const QRect &amp;subTexGeometry,
                           const QRect &amp;screenGeometry,
                           float progress);

     QAhiGLScreenPrivate *d_ptr;
     friend class QAhiGLScreenPrivate;
 };</pre>
<p>All functions in the public API of class QAhiGLScreen are virtual functions declared in its base classes. hasOpenGL() is declared in QGLScreen. It simply returns true indicating our example screen driver does support OpenGL operations. The other functions in the public API are declared in <a href="qscreen.html">QScreen</a>. They are called by the <a href="qwsserver.html">Qt for Embedded Linux server</a> at the appropriate times.</p>
<p>Note that class <a href="qscreen.html">QScreen</a> is a documented class but class QGLScreen is not. This is because the design of class QGLScreen is not yet final.</p>
<p>The only data member in class QAhiGLScreen is a standard d_ptr, which points to an instance of the driver's private implementation class QAhiGLScreenPrivate. The driver's internal state is stored in the private class. Using the so-called d-pointer pattern allows you to make changes to the driver's internal design without breaking binary compatibility.</p>
<pre> class QAhiGLScreenPrivate : public QObject
 {
     Q_OBJECT

 public:
     QAhiGLScreenPrivate(QAhiGLScreen *s);

 public slots:
     void windowEvent(QWSWindow *w, QWSServer::WindowEvent e);
     void redrawScreen();

 public:
     QAhiGLScreen *screen;
     QAhiGLCursor *cursor;

     EGLContext eglContext;
     EGLDisplay eglDisplay;
     EGLSurface eglSurface;

     QTimer updateTimer;
     bool doEffects;
 };</pre>
<p>Class QAhiGLScreenPrivate is derived from <a href="qobject.html">QObject</a> so that it can use the Qt signal/slot mechanism. QAhiGLScreen is not a <a href="qobject.html">QObject</a>, so it can't use the signal/slot mechanism. Signals meant for our screen driver are received by slots in the private implementation class, in this case, windowEvent() and redrawScreen().</p>
<a name="the-window-surface-class-definitions"></a>
<h3>The Window Surface Class Definitions</h3>
<p>The window surface classes are QAhiGLWindowSurface and its private implementation class QAhiGLWindowSurfacePrivate. We create class QAhiGLWindowSurface so the screen driver can use the OpenGL paint engine and the OpenGL widget, classes QOpenGLPaintEngine and <a href="qglwidget.html">QGLWidget</a>. QAhiGLWindowSurface is derived from the more general OpenGL window surface class, <a href="qwsglwindowsurface.html">QWSGLWindowSurface</a>, which is derived from QWSWindowSurface.</p>
<pre> class QAhiGLWindowSurface : public QWSGLWindowSurface
 {
 public:
     QAhiGLWindowSurface(QWidget *widget, EGLDisplay eglDisplay,
                         EGLSurface eglSurface, EGLContext eglContext);
     QAhiGLWindowSurface(EGLDisplay eglDisplay, EGLSurface eglSurface,
                         EGLContext eglContext);
     ~QAhiGLWindowSurface();

     QString key() const { return QLatin1String(&quot;ahigl&quot;); }
     void setGeometry(const QRect &amp;rect);
     QPaintDevice *paintDevice();
     void beginPaint(const QRegion &amp;region);
     bool isValid() const;

     QByteArray permanentState() const;
     void setPermanentState(const QByteArray &amp;);

     QImage image() const { return QImage(); }

     GLuint textureId() const;

 private:
     QAhiGLWindowSurfacePrivate *d_ptr;
 };</pre>
<p>In addition to implementing the standard functionality required by any new subclass of QWSWindowSurface, QAhiGLWindowSurface also contains the textureId() function used by QAhiGLScreen.</p>
<p>The same d-pointer pattern is used in this window surface class. The private implementation class is QAhiGLWindowSurfacePrivate. It allows making changes to the state variables of the window surface without breaking binary compatibility.</p>
<pre> class QAhiGLWindowSurfacePrivate
 {
 public:
     QAhiGLWindowSurfacePrivate(EGLDisplay eglDisplay,
                                EGLSurface eglSurface,
                                EGLContext eglContext);

     QPaintDevice *device;

     int textureWidth;
     int textureHeight;

     GLuint texture;
     GLuint frameBufferObject;
     GLuint depthbuf;

     EGLDisplay display;
     EGLSurface surface;
     EGLContext context;
 };</pre>
<p>In this case, our private implementation class has no member functions except for its constructor. It contains only public data members which hold state information for the window surface.</p>
<a name="the-helper-classes"></a>
<h3>The Helper Classes</h3>
<p>The example screen driver maintains a static <a href="qmap.html">map</a> of all the <a href="qwswindow.html">windows</a> it is showing on the screen. Each window is mapped to an instance of struct WindowInfo.</p>
<pre> struct WindowInfo
 {
     WindowInfo() : texture(0), animation(0) {}

     GLuint texture;
     QPointer&lt;ShowAnimation&gt; animation;
 };

 static QMap&lt;QWSWindow*, WindowInfo*&gt; windowMap;</pre>
<p>As each new window is created, an instance of struct WindowInfo is allocated and inserted into the window map. WindowInfo uses a GLuint to identify the OpenGL texture it creates for the window. Note that the example driver, in addition to drawing windows using OpenGL, also supports drawing windows in the normal way without OpenGL, but it uses an OpenGL texture for the rendering operations in either case. Top-level windows that are drawn without OpenGL are first rendered in the normal way into a shared memory segment, which is then converted to a OpenGL texture and drawn to the screen.</p>
<p>To animate the window transition effect, WindowInfo uses an instance of the helper class ShowAnimation. The animation is created by the windowEvent() slot in QAhiGLScreenPrivate, whenever a <a href="qwsserver.html#WindowEvent-enum">Show</a> window event is emitted by the <a href="qwsserver.html">window server</a>. The server emits this signal when a window is shown the first time and again later, when the window is reshown after having been minimized.</p>
<pre> class ShowAnimation : public QTimeLine
 {
 public:
     ShowAnimation(QAhiGLScreenPrivate *screen);
     qreal valueForTime(int msec);
 };</pre>
<p>Class ShowAnimation is derived from the <a href="qtimeline.html">QTimeLine</a> class, which is used for controlling animations. <a href="qtimeline.html">QTimeLine</a> is a <a href="qobject.html">QObject</a>, so ShowAnimation can use the Qt signal/slot mechanism. We will see how the timeline's <a href="qtimeline.html#valueChanged">valueChanged()</a> and <a href="qtimeline.html#finished">finished()</a> signals are used to control the animation and then destroy the instance of ShowAnimation, when the animation ends. The ShowAnimation constructor needs the pointer to the screen driver's private implementation class so it can set up these signal/slot connections.</p>
<a name="the-class-implementations"></a>
<h2>The Class Implementations</h2>
<a name="the-plugin-class-implementation"></a>
<h3>The Plugin Class Implementation</h3>
<p>QAhiGLScreenPlugin is a straightforward derivation of <a href="qscreendriverplugin.html">QScreenDriverPlugin</a>. It reimplements <a href="qscreendriverplugin.html#keys">keys()</a> and <a href="qscreendriverplugin.html#create">create()</a>. They are called as needed by the <a href="qwsserver.html">Qt for Embedded Linux server.</a> Recall that the server detects that the ahigl screen driver has been requested, either by including &quot;ahigl&quot; in the value for the environment variable <a href="qt-embedded-envvars.html#qws-display">QWS_DISPLAY</a>, or by running your application with a command line like the following.</p>
<pre> myApplication -qws -display ahigl</pre>
<p>The server calls <a href="qscreendriverplugin.html#keys">keys()</a>, which returns a <a href="qstringlist.html">QStringList</a> containing the singleton &quot;ahigl&quot; matching the requested screen driver and telling the server that it can use our example screen driver. The server then calls <a href="qscreendriverplugin.html#create">create()</a>, which creates the instance of QAhiGLScreen.</p>
<pre> Q_EXPORT_PLUGIN2(qahiglscreen, QAhiGLScreenPlugin)</pre>
<p>In the code snippet above, the macro <a href="qtplugin.html#Q_EXPORT_PLUGIN2#q-export-plugin2">Q_EXPORT_PLUGIN2</a> is used to export the plugin class, QAhiGLScreen, for the qahiglscreen plugin. Further information regarding plugins and how to create them can be found at <a href="plugins-howto.html">How to Create Qt Plugins</a>.</p>
<a name="the-screen-driver-class-implementations"></a>
<h3>The Screen Driver Class Implementations</h3>
<p>The plugin creates the singleton instance of QAhiGLScreen. The constructor is passed a <tt>displayId</tt>, which is used in the base class QGLScreen to identify the server that the screen driver is connected to. The constructor also creates its instance of QAhiGLScreenPrivate, which instantiates a <a href="qtimer.html">QTimer</a>. The timeout() signal of this timer is connected to the redrawScreen() slot so the timer can be used to limit the frequency of actual drawing operations in the hardware.</p>
<p>The public API of class QAhiGLScreen consists of implementations of virtual functions declared in its base classes. The function hasOpenGL() is declared in base class QGLScreen. The others are declared in base class <a href="qscreen.html">QScreen</a>.</p>
<p>The <a href="qscreen.html#connect">connect()</a> function is the first one called by the server after the screen driver is constructed. It initializes the <a href="qscreen.html">QScreen</a> data members to hardcoded values that describe the ATI screen. A better implementation would query the hardware for the corresponding values in its current state and use those. It asks whether the screen driver was started with the <tt>effects</tt> option and sets the <tt>doEffects</tt> flag accordingly.</p>
<pre> bool QAhiGLScreen::connect(const QString &amp;displaySpec)
 {
     <span class="comment">// Hardcoded values for this device</span>
     w = 480;
     h = 640;
     dw = w;
     dh = h;
     d = 16;

     const int dpi = 120;
     physWidth = qRound(dw * 25.4 / dpi);
     physHeight = qRound(dh * 25.4 / dpi);

     if (displaySpec.section(':', 1, 1).contains(&quot;effects&quot;))
         d_ptr-&gt;doEffects = true;

     return true;
 }</pre>
<p>The <a href="qscreen.html#initDevice">initDevice()</a> function is called by the server after <a href="qscreen.html#connect">connect()</a>. It uses EGL library functions to initialize the ATI hardware. Note that some data structures used in this example are specific to the EGL implementation used, e.g&#x2e;, the DummyScreen structure.</p>
<pre> bool QAhiGLScreen::initDevice()
 {
     EGLint version, subversion;
     EGLint attrs[] = { EGL_SURFACE_TYPE, EGL_WINDOW_BIT,
                        EGL_STENCIL_SIZE, 8, EGL_DEPTH_SIZE, 16,
                        EGL_NONE };
     EGLint numConfig;
     EGLConfig eglConfig;

     d_ptr-&gt;eglDisplay = eglGetDisplay(0);
     if (d_ptr-&gt;eglDisplay == EGL_NO_DISPLAY) {
         qCritical(&quot;QAhiGLScreen::initDevice(): eglGetDisplay failed: 0x%x&quot;,
                   eglGetError());
         return false;
     }

     if (!eglInitialize(d_ptr-&gt;eglDisplay, &amp;version, &amp;subversion)) {
         qCritical(&quot;QAhiGLScreen::initDevice(): eglInitialize failed: 0x%x&quot;,
                   eglGetError());
         return false;
     }

     if (!eglChooseConfig(d_ptr-&gt;eglDisplay, attrs, &amp;eglConfig, 1, &amp;numConfig)) {
         qCritical(&quot;QAhiGLScreen::initDevice(): eglChooseConfig failed: 0x%x&quot;,
                   eglGetError());
         return false;
     }

     static DummyScreen win = { w, h };
     d_ptr-&gt;eglSurface = eglCreateWindowSurface(d_ptr-&gt;eglDisplay, eglConfig,
                                                &amp;win, 0);
     if (d_ptr-&gt;eglSurface == EGL_NO_SURFACE) {
         qCritical(&quot;QAhiGLScreen::initDevice(): eglCreateWindowSurface failed: 0x%x&quot;,
                   eglGetError());
         return false;
     }

     d_ptr-&gt;eglContext = eglCreateContext(d_ptr-&gt;eglDisplay, eglConfig,
                                          EGL_NO_CONTEXT, 0);
     if (d_ptr-&gt;eglContext == EGL_NO_CONTEXT) {
         qCritical(&quot;QAhiGLScreen::initDevice(): eglCreateContext failed: 0x%x&quot;,
                   eglGetError());
         return false;
     }

     if (!eglMakeCurrent(d_ptr-&gt;eglDisplay, d_ptr-&gt;eglSurface, d_ptr-&gt;eglSurface, d_ptr-&gt;eglContext)) {
         qCritical(&quot;QAhiGLScreen::initDevice(): eglMakeCurrent failed: 0x%x&quot;,
                   eglGetError());
         return false;
     }

     d_ptr-&gt;connect(QWSServer::instance(),
                    SIGNAL(windowEvent(QWSWindow*, QWSServer::WindowEvent)),
                    SLOT(windowEvent(QWSWindow*, QWSServer::WindowEvent)));

     d_ptr-&gt;cursor = new QAhiGLCursor;
     qt_screencursor = d_ptr-&gt;cursor;

     return true;
 }</pre>
<p>Note the signal/slot connection at the bottom of initDevice(). We connect the server's <a href="qwsserver.html#windowEvent">QWSServer::windowEvent</a>() signal to the windowEvent() slot in the screen driver's private implementation class. The windowEvent() slot handles three window events, <a href="qwsserver.html#WindowEvent-enum">QWSServer::Create</a>, <a href="qwsserver.html#WindowEvent-enum">QWSServer::Destroy</a>, and <a href="qwsserver.html#WindowEvent-enum">QWSServer::Show</a>.</p>
<pre> void QAhiGLScreenPrivate::windowEvent(QWSWindow *window,
                                       QWSServer::WindowEvent event)
 {
     switch (event) {
     case QWSServer::Create:
         windowMap[window] = new WindowInfo;
         break;
     case QWSServer::Show:
         if (doEffects)
             windowMap[window]-&gt;animation = new ShowAnimation(this);
         break;
     case QWSServer::Destroy:
         delete windowMap[window];
         windowMap.remove(window);
         break;
     default:
         break;
     }
 }</pre>
<p>The function manages instances of the helper classes associated with each window. When a <a href="qwsserver.html#WindowEvent-enum">QWSServer::Create</a> event occurs, it means a new top-level <a href="qwswindow.html">window</a> has been created. In this case, an instance of helper class WindowInfo is created and inserted into the window map with the pointer to the new <a href="qwswindow.html">window</a> as its key. When a <a href="qwsserver.html#WindowEvent-enum">QWSServer::Destroy</a> event occurs, a window is being destroyed, and its mapping is removed from the window map. These two events are straightforward. The tricky bits happen when a <a href="qwsserver.html#WindowEvent-enum">QWSServer::Show</a> event occurs. This case occurs when a window is shown for the first time and when it is reshown after having been minimized. If the window transition effect has been enabled, a new instance of the helper class ShowAnimation is created and stored in a <a href="qpointer.html">QPointer</a> in the window's instance of WindowInfo. The constructor of ShowAnimation automatically <a href="qtimeline.html#start">starts</a> the animation of the transition effect.</p>
<pre> ShowAnimation::ShowAnimation(QAhiGLScreenPrivate *screen)
     : QTimeLine(animationLength)
 {
     setUpdateInterval(frameSpan);
     connect(this, SIGNAL(valueChanged(qreal)), screen, SLOT(redrawScreen()));
     connect(this, SIGNAL(finished()), this, SLOT(deleteLater()));
     start();
 }</pre>
<p>To ensure that a ShowAnimation is not deleted until its animation ends, the <a href="qtimeline.html#finished">finished()</a> signal is connected to the <a href="qobject.html#deleteLater">deleteLater()</a> slot. When the animation ends, the finished() signal is emitted and the deleteLater() slot deletes the ShowAnimation. The key here is that the pointer to the ShowAnimation is stored in a <a href="qpointer.html">QPointer</a> in the WindowInfo class. This <a href="qpointer.html">QPointer</a> will also be notified when the ShowAnimation is deleted, so the <a href="qpointer.html">QPointer</a> in WindowInfo can null itself out, if and only if it is still pointing to the instance of ShowAnimation being deleted.</p>
<p>The <a href="qtimeline.html#valueForTime">valueForTime()</a> function in <a href="qtimeline.html">QTimeLine</a> is reimplemented in ShowAnimation to return time values that represent a curved path for the window transition effect.</p>
<pre> qreal ShowAnimation::valueForTime(int msec)
 {
     const qreal t = msec / qreal(duration());
     return 3*t*t - 2*t*t*t;
 }</pre>
<p>valueForTime() is called internally, when the time interval it computed during the previous call has elapsed. If it computes a next time value that is different from the one computed previously, the <a href="qtimeline.html#valueChanged">valueChanged()</a> signal is emitted. The ShowAnimation constructor shown above connects this signal to the redrawScreen() slot in the screen driver's private implementation class. This is how the animation actually happens.</p>
<p>The screen driver's implementation of <a href="qscreen.html#exposeRegion">exposeRegion()</a> is where the main work of the screen driver is meant to be done, i.e&#x2e;, updating the screen. It is called by the <a href="qwsserver.html">window system</a> to update a particular window's region of the screen. But note that it doesn't actually update the screen, i.e&#x2e;, it doesn't actually call redrawScreen() directly, but starts the updateTimer, which causes redrawScreen() to be called once for each updateTimer interval. This means that all calls to exposeRegion() during an updateTimer interval are handled by a single call to redrawScreen(). Thus updateTimer can be used to limit the frequency of screen updates.</p>
<pre> void QAhiGLScreen::exposeRegion(QRegion r, int windowIndex)
 {
     if ((r &amp; region()).isEmpty())
         return;

     invalidateTexture(windowIndex);

     if (!d_ptr-&gt;updateTimer.isActive())
         d_ptr-&gt;updateTimer.start(frameSpan);
 }</pre>
<p>The call to the private function invalidateTexture() destroys the window's existing texture (image). This ensures that a new texture will be created for the window, when redrawScreen() is eventually called.</p>
<p>But there is a caveat to using updateTimer to limit the frequency of screen updates. When the driver's animated transition effect for new windows is enabled and a new window is being shown for the first time or reshown after having been minimized, an instance of ShowAnimation is created to run the animation. The valueChanged() signal of this ShowAnimation is also connected to the redrawScreen() slot, and <a href="qtimeline.html">QTimeLine</a>, the base class of our ShowAnimation, uses its own, internal timer to limit the speed of the animation. This means that in the driver as currently written, if the window transition effect is enabled (i.e&#x2e; if the plugin is started, with <tt>-display ahigl:effects</tt>), then redrawScreen() can be called both when the update timer times out and when the ShowAnimation timer times out, so the screen might get updated more often than the frequency established by the update timer. This may or may not be a bug, depending on your own hardware, if you use this example as a template for your own OpenGL driver.</p>
<p>The screen driver's private function redrawScreen() constructs the window compositions. It is called only by the function of the same name in the screen driver's private implementation class.</p>
<pre> void QAhiGLScreenPrivate::redrawScreen()
 {
     updateTimer.stop();
     screen-&gt;redrawScreen();
 }</pre>
<p>Recall that this redrawScreen() in the private implementation class is a slot function connected to two signals, the <tt>timeout()</tt> signal of the updateTimer in the private implementation class, and the valueChanged() signal of the helper class ShowAnimation. Thus, the screen is only ever updated when a timeout of one of the two timers occurs. This is important for two reasons. First, the screen is meant to be updated no more than once per updateTimer interval. Second, however, if the animated window transition effect is requested, the screen might be updated more often than that, and this might be a bug if the hardware can't handle more frequent updates.</p>
<p>The redrawScreen() in QAhiGLScreen begins by using standard OpenGL to fill the screen with the background color.</p>
<pre> void QAhiGLScreen::redrawScreen()
 {
     glBindFramebufferOES(GL_FRAMEBUFFER_EXT, 0);
     glMatrixMode(GL_PROJECTION);
     glPushMatrix();
     glMatrixMode(GL_MODELVIEW);
     glPushMatrix();

     glMatrixMode(GL_PROJECTION);
     glLoadIdentity();
     glOrthof(0, w, h, 0, -999999, 999999);
     glViewport(0, 0, w, h);
     glMatrixMode(GL_MODELVIEW);
     glLoadIdentity();

     <span class="comment">// Fill background color</span>

     QColor bgColor = QWSServer::instance()-&gt;backgroundBrush().color();
     glClearColor(bgColor.redF(), bgColor.greenF(),
                  bgColor.blueF(), bgColor.alphaF());
     glClear(GL_COLOR_BUFFER_BIT);</pre>
<p>Next it iterates over the list of all <a href="qwswindow.html">client windows</a> obtained from the <a href="qwsserver.html">server</a>, extracting from each window its instance of QWSWIndowSurface, then using that window surface to create an OpenGL texture, and finally calling the helper function drawWindow() to draw the texture on the screen.</p>
<pre>     QList&lt;QWSWindow*&gt; windows = QWSServer::instance()-&gt;clientWindows();
     for (int i = windows.size() - 1; i &gt;= 0; --i) {
         QWSWindow *win = windows.at(i);
         QWSWindowSurface *surface = win-&gt;windowSurface();
         if (!surface)
             continue;

         WindowInfo *info = windowMap[win];

         if (!info-&gt;texture) {
             if (surface-&gt;key() == QLatin1String(&quot;ahigl&quot;))
                 info-&gt;texture = static_cast&lt;QAhiGLWindowSurface*&gt;(surface)-&gt;textureId();
             else
                 info-&gt;texture = createTexture(surface-&gt;image());
         }
         qreal progress;
         if (info-&gt;animation)
             progress = info-&gt;animation-&gt;currentValue();
         else
             progress = 1.0;

         glBindTexture(GL_TEXTURE_2D, info-&gt;texture);
         drawWindow(win, progress);
     } <span class="comment">// for i</span></pre>
<p>Note the call to glBindTexture() immediately before the call to drawWindow(). This call binds the identifer <tt>GL_TEXTURE_2D</tt> to the texture we have just created. This makes our texture accessible to functions in the OpenGL libraries. If you miss that point, digging into the internals of drawWindow() won't make much sense.</p>
<p>Finally, the cursor is added to the window composition, and in the last statement, the whole thing is displayed on the screen.</p>
<pre>     <span class="comment">// Draw cursor</span>

     const QAhiGLCursor *cursor = d_ptr-&gt;cursor;
     if (cursor-&gt;texture) {
         glBlendFunc(GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA);
         glBindTexture(GL_TEXTURE_2D, d_ptr-&gt;cursor-&gt;texture);
         drawQuad(cursor-&gt;boundingRect(), cursor-&gt;boundingRect(),
                  cursor-&gt;boundingRect());
     }

     glPopMatrix();
     glMatrixMode(GL_PROJECTION);
     glPopMatrix();
     glMatrixMode(GL_MODELVIEW);

     eglSwapBuffers(d_ptr-&gt;eglDisplay, d_ptr-&gt;eglSurface);
 }</pre>
<p>The call to <tt>drawWindow(win,progress)</tt>, in addition to passing a pointer to the window to be redrawn, also passes the <tt>progress</tt> parameter obtained by calling <a href="qtimeline.html#currentValue">QTimeLine::currentValue</a>() on the window's instance of ShowAnimation. Recall that the current value of the timeline is updated internally by a timer local to the timeline, and the redrawScreen() slot is called whenever the current value changes. The progress value will only be used if the animated transition effect has been enabled. These extra calls of redrawScreen() may cause the screen to be updated more often than the rate determined by updateTimer. This must be taken into account, if you set your updateTimer to timeout at the maximum screen update frequency your hardware can handle.</p>
<p>The drawWindow() function is not shown here and not explained further, but the call to drawWindow() is the entry point to a hierarchy of private helper functions that execute sequences of OpenGL and EGL library calls. The reader is assumed to be familiar enough with the OpenGL and EGL APIs to understand the code in these helper functions on his own. Besides drawWindow(), the list of these helper functions includes drawQuad(), drawQuadWavyFlag(), the two overloadings of drawQuad_helper() (used by drawQuad() and drawQuadWacyFlag()), and setRectCoords().</p>
<p>Note the two different ways the window's texture can be created in redrawScreen(). If the window surface is an OpenGL window surface (QAhiGLWindowSurface described below), the texture is obtained from the window surface directly by calling its textureId() function. But when the window surface is not an OpenGL one, the static function createTexture() is called with the window surface's <a href="qimage.html">image</a> to copy that image into an OpenGL texture. This is done with the EGL functions glTexImage2D() and glTexSubImage2D(). createTexture() is another function that should be understandable for exsperienced OpenGL users, so it is not shown or explained further here.</p>
<p>The two implementations of <a href="qscreen.html#createSurface">createSurface()</a> are for instantiating new window surfaces. The overloading with the widget parameter is called in the client.</p>
<pre> QWSWindowSurface* QAhiGLScreen::createSurface(QWidget *widget) const
 {
     if (QApplication::type() == QApplication::GuiServer) {
         if (qobject_cast&lt;QGLWidget*&gt;(widget)) {
             return new QAhiGLWindowSurface(widget,
                                            d_ptr-&gt;eglDisplay,
                                            d_ptr-&gt;eglSurface,
                                            d_ptr-&gt;eglContext);
         }

         const QRect rect = widget-&gt;frameGeometry();
         if (rect.width() &lt;= 256 &amp;&amp; rect.height() &lt;= 256) {
             return new QAhiGLWindowSurface(widget,
                                            d_ptr-&gt;eglDisplay,
                                            d_ptr-&gt;eglSurface,
                                            d_ptr-&gt;eglContext);
         }
     }

     return QScreen::createSurface(widget);
 }</pre>
<p>If the parameter is an <a href="qglwidget.html">OpenGL widget</a>, or, when it isn't an OpenGL widget but its size is no bigger than 256 x 256, we instantiate our subclass QAhiGLWindowSurface. Otherwise, we instantiate a QWSWindowSurface. The size contraint is a limitation of the OpenGL ES libraries we are using for our ATI device.</p>
<p>Note the test at the top of the function asking if our application process is the <a href="qapplication.html#Type-enum">server</a>. We only create instances of QAhiGLWindowSurface if our client is in the server process. This is because of an implementation restriction required by the OpenGL library used in the example. They only support use of OpenGL in the server process. Hence a client can use the QAhiGLWindowSurface if the client is in the server process.</p>
<p>The other overloading of createSurface() is called by the server to create a window surface that will hold a copy of a client side window surface.</p>
<pre> QWSWindowSurface* QAhiGLScreen::createSurface(const QString &amp;key) const
 {
     if (key == QLatin1String(&quot;ahigl&quot;)) {
         return new QAhiGLWindowSurface(d_ptr-&gt;eglDisplay,
                                        d_ptr-&gt;eglSurface,
                                        d_ptr-&gt;eglContext);
     }

     return QScreen::createSurface(key);
 }</pre>
<p>This overloading accepts a <a href="qstring.html">QString</a> parameter identifying the type of window surface to instantiate. QAhiGLWindowSurface is instantiated if the parameter is <tt>ahigl</tt>. Otherwise, a normal QWSWindowSurface is instantiated. The client's window surface communicates its image data to the server's window surface through shared memory.</p>
<p>The implementation of <a href="qscreen.html#setMode">setMode()</a>, is a stub in this example. It would normally reset the frame buffer's resolution. Its parameters are the <i>width</i>, <i>height</i>, and the bit <i>depth</i> for the frame buffer's new resolution. If you implement setMode() in your screen driver, remember that it must emit a signal to warn other applications to redraw their frame buffers with the new resolution. There is no significance to setMode() not being implemented in this example. It simply wasn't implemented. However, the stub had to be included because <a href="qscreen.html">QScreen</a> declares setMode() to be pure virtual.</p>
<p>Before the application exits, the server will call <a href="qscreen.html#shutdownDevice">shutdownDevice()</a> to release the hardware resources. This is also done using EGL library functions.</p>
<pre> void QAhiGLScreen::shutdownDevice()
 {
     delete d_ptr-&gt;cursor;
     d_ptr-&gt;cursor = 0;
     qt_screencursor = 0;

     eglMakeCurrent(EGL_NO_DISPLAY, EGL_NO_SURFACE,
                    EGL_NO_SURFACE, EGL_NO_CONTEXT);
     eglDestroyContext(d_ptr-&gt;eglDisplay, d_ptr-&gt;eglContext);
     eglDestroySurface(d_ptr-&gt;eglDisplay, d_ptr-&gt;eglSurface);
     eglTerminate(d_ptr-&gt;eglDisplay);
 }</pre>
<p>The server will also call <a href="qscreen.html#disconnect">disconnect()</a>, but this function is only a stub in this example.</p>
<a name="the-window-surface-class-implementations"></a>
<h3>The window Surface Class Implementations</h3>
<p>QAhiGLScreen creates instances of QAhiGLWindowSurface in its two createSurface() functions, and there are two constructors for QAhiGLWindowSurface that correspond to these two versions of createSurface(). The constructor accepting a <a href="qwidget.html">widget</a> parameter is called by the client side version of createSurface(), and the constructor without the <a href="qwidget.html">widget</a> parameter is called by the server side version. There will be a window surface constructed on the server side for each one constructed on the client side.</p>
<pre> QAhiGLWindowSurface::QAhiGLWindowSurface(QWidget *widget,
                                          EGLDisplay eglDisplay,
                                          EGLSurface eglSurface,
                                          EGLContext eglContext)
     : QWSGLWindowSurface(widget)
 {
     d_ptr = new QAhiGLWindowSurfacePrivate(eglDisplay, eglSurface, eglContext);
     d_ptr-&gt;device = new QWSGLPaintDevice(widget);

     setSurfaceFlags(QWSWindowSurface::Buffered);
 }

 QAhiGLWindowSurface::QAhiGLWindowSurface(EGLDisplay eglDisplay,
                                          EGLSurface eglSurface,
                                          EGLContext eglContext)
 {
     d_ptr = new QAhiGLWindowSurfacePrivate(eglDisplay, eglSurface, eglContext);
     setSurfaceFlags(QWSWindowSurface::Buffered);
 }</pre>
<p>The constructors create an instance of QAhiGLWindowSurfacePrivate, the private implementation class, which contains all the state variables for QAhiGLWindowSurface. The client side constructor also creates an instance of QWSGLPaintDevice, the OpenGL paint device, for return by <a href="qwswindowsurface.html#paintDevice">paintDevice()</a>. This ensures that all <a href="qpainter.html">QPainter</a>s used on this surface will use an OpenGL enabled <a href="qpaintengine.html">QPaintEngine</a>. It is a bit of jiggery pokery, which is required because <a href="qwswindowsurface.html#paintDevice">paintDevice()</a> is declared pure virtual. Normally, the client side constructor will be called with an <a href="qglwidget.html">OpenGL widget</a>, which has its own <a href="qwidget.html#paintEngine">paintEngine()</a> function that returns the global static OpenGL paint engine, but because the constructor also accepts a normal <a href="qwidget.html">widget</a>, it must be able to find the OpenGL paint engine in that case as well, so since <a href="qwswindowsurface.html#paintDevice">paintDevice()</a> must be implemented anyway, the constructor creates an instance of QWSGLPaintDevice, which can always return the global static pointer to QOpenGLPaintEngine.</p>
<p>The OpenGL library implementation used for this example only supports one OpenGL context. This context is therefore shared among the single instance of QAhiGLScreen and all instances of QAhiGLWindowSurface. It is passed to both constructors.</p>
<p>This example uses the OpenGL frame buffer object extension, which allows for accelerating OpenGL painting operations. Using this OpenGL extension, painting operations are performed in a frame buffer object, which QAhiGLScreen later uses to construct window compositions on the screen. Allocation of the frame buffer object is performed in <a href="qwindowsurface.html#setGeometry">setGeometry()</a>. A safer way to use this extension would be to first test to see if the extension is supported by your OpenGL library, and use a different approach if it is not.</p>
<pre> void QAhiGLWindowSurface::setGeometry(const QRect &amp;rect)
 {
     QSize size = rect.size();

     const QWidget *w = window();
     if (w &amp;&amp; !w-&gt;mask().isEmpty()) {
         const QRegion region = w-&gt;mask()
                                &amp; rect.translated(-w-&gt;geometry().topLeft());
         size = region.boundingRect().size();
     }

     if (geometry().size() != size) {

         <span class="comment">// Driver specific limitations:</span>
         <span class="comment">//   FBO maximimum size of 256x256</span>
         <span class="comment">//   Depth buffer required</span>

         d_ptr-&gt;textureWidth = qMin(256, nextPowerOfTwo(size.width()));
         d_ptr-&gt;textureHeight = qMin(256, nextPowerOfTwo(size.height()));

         glGenTextures(1, &amp;d_ptr-&gt;texture);
         glBindTexture(GL_TEXTURE_2D, d_ptr-&gt;texture);

         glTexParameterx(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR);
         glTexParameterx(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR);
         glTexParameterx(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_CLAMP_TO_EDGE);
         glTexParameterx(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_CLAMP_TO_EDGE);

         const int bufSize = d_ptr-&gt;textureWidth * d_ptr-&gt;textureHeight * 2;
         GLshort buf[bufSize];
         memset(buf, 0, sizeof(GLshort) * bufSize);

         glTexImage2D(GL_TEXTURE_2D, 0, GL_RGBA, d_ptr-&gt;textureWidth,
                      d_ptr-&gt;textureHeight, 0,
                      GL_RGBA, GL_UNSIGNED_BYTE, buf);

         glGenRenderbuffersOES(1, &amp;d_ptr-&gt;depthbuf);
         glBindRenderbufferOES(GL_RENDERBUFFER_EXT, d_ptr-&gt;depthbuf);
         glRenderbufferStorageOES(GL_RENDERBUFFER_EXT, GL_DEPTH_COMPONENT16,
                                  d_ptr-&gt;textureWidth, d_ptr-&gt;textureHeight);

         glGenFramebuffersOES(1, &amp;d_ptr-&gt;frameBufferObject);
         glBindFramebufferOES(GL_FRAMEBUFFER_EXT, d_ptr-&gt;frameBufferObject);

         glFramebufferTexture2DOES(GL_FRAMEBUFFER_EXT, GL_COLOR_ATTACHMENT0_EXT,
                                   GL_TEXTURE_2D, d_ptr-&gt;texture, 0);
         glFramebufferRenderbufferOES(GL_FRAMEBUFFER_EXT,
                                      GL_DEPTH_ATTACHMENT_EXT,
                                      GL_RENDERBUFFER_EXT, d_ptr-&gt;depthbuf);
         glBindFramebufferOES(GL_FRAMEBUFFER_EXT, 0);
     }

     QWSGLWindowSurface::setGeometry(rect);
 }</pre>
<p>Since there can be several instances of the QAhiGLWindowSurface, we need to make sure that the correct framebuffer object is active before painting. This is done by reimplementing <a href="qwindowsurface.html#beginPaint">QWindowSurface::beginPaint</a>():</p>
<pre> void QAhiGLWindowSurface::beginPaint(const QRegion &amp;region)
 {
     QWSGLWindowSurface::beginPaint(region);

     if (d_ptr-&gt;frameBufferObject)
         glBindFramebufferOES(GL_FRAMEBUFFER_EXT, d_ptr-&gt;frameBufferObject);
 }</pre>
<p>Finally we need to make sure that whenever a widget grows beyond the size supported by this driver (256 x 256), the surface is deleted and a new standard surface is created instead. This is handled by reimplementing <a href="qwswindowsurface.html#isValid">QWSWindowSurface::isValid</a>():</p>
<pre> bool QAhiGLWindowSurface::isValid() const
 {
     if (!qobject_cast&lt;QGLWidget*&gt;(window())) {
         const QRect r = window()-&gt;frameGeometry();
         if (r.width() &gt; 256 || r.height() &gt; 256)
             return false;
     }
     return true;
 }</pre>
<p /><address><hr /><div align="center">
<table width="100%" cellspacing="0" border="0"><tr class="address">
<td width="30%" align="left">Copyright &copy; 2008 Nokia</td>
<td width="40%" align="center"><a href="trademarks.html">Trademarks</a></td>
<td width="30%" align="right"><div align="right">Qt 4.4.3</div></td>
</tr></table></div></address></body>
</html>
