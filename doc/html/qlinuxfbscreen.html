<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<!-- /tmp/automatedbuild/qt-2.3.7/src/kernel/qgfxlinuxfb_qws.cpp:58 -->
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
<title>QLinuxFbScreen Class</title>
<style type="text/css"><!--
h3.fn,span.fn { margin-left: 1cm; text-indent: -1cm; }
a:link { color: #004faf; text-decoration: none }
a:visited { color: #672967; text-decoration: none }
body { background: #ffffff; color: black; }
--></style>
</head>
<body>

<table border="0" cellpadding="0" cellspacing="0" width="100%">
<tr bgcolor="black"><td>
<a href="classes.html"><font color="white">Qt API</font></a>
<font color="white">|</font>
<a href="qtopiaemb.html"> <font color="white">Qtopia API</font></a>
</td>
<td align="right"><a href="../index.html"><font color="white"><i>Qtopia Documentation</i></font></a></td>
<td align="right" valign="center"><img src="logo32.png" align="right" width="64" height="32" border="0"></td></tr></table><h1 align=center>QLinuxFbScreen Class Reference</h1>

<p>QLinuxFbScreen manages the Linux framebuffer. Accelerated drivers
for Linux should inherit from it; it contains code for reading information
about the framebuffer from the Linux framebuffer interface, managing
the color palette, managing offscreen graphics memory and mapping the 
framebuffer interface itself, removing the need for drivers to do this.
It also acts as a factory for the unaccelerated screen cursor and
unaccelerated QGfxes. QLinuxFbScreen is a descendant of QScreen;
there is precisely one per Qt/Embedded application.
<a href="#details">More...</a>
<p><tt>#include &lt;<a href="qgfxlinuxfb_qws-h.html">qgfxlinuxfb_qws.h</a>&gt;</tt>
<p>Inherits <a href="qscreen.html">QScreen</a>.
<p><a href="qlinuxfbscreen-members.html">List of all member functions.</a>
<h2>Public Members</h2>
<ul>
<li><div class=fn><b>QLinuxFbScreen</b> ( int&nbsp;display_id )</div></li>
<li><div class=fn>virtual <a href="#~QLinuxFbScreen"><b>~QLinuxFbScreen</b></a> ()</div></li>
<li><div class=fn>virtual bool <a href="#initDevice"><b>initDevice</b></a> ()</div></li>
<li><div class=fn>virtual bool <a href="#connect"><b>connect</b></a> ( const&nbsp;QString&nbsp;&amp;&nbsp;displaySpec )</div></li>
<li><div class=fn>virtual bool <b>useOffscreen</b> ()</div></li>
<li><div class=fn>virtual void <a href="#disconnect"><b>disconnect</b></a> ()</div></li>
<li><div class=fn>virtual void <a href="#shutdownDevice"><b>shutdownDevice</b></a> ()</div></li>
<li><div class=fn>virtual void <a href="#setMode"><b>setMode</b></a> ( int&nbsp;nw, int&nbsp;nh, int&nbsp;nd )</div></li>
<li><div class=fn>virtual void <a href="#save"><b>save</b></a> ()</div></li>
<li><div class=fn>virtual void <a href="#restore"><b>restore</b></a> ()</div></li>
<li><div class=fn>virtual void <b>blank</b> ( bool&nbsp;on )</div></li>
<li><div class=fn>virtual void <a href="#set"><b>set</b></a> ( unsigned&nbsp;int&nbsp;i, unsigned&nbsp;int&nbsp;r, unsigned&nbsp;int&nbsp;g, unsigned&nbsp;int&nbsp;b )</div></li>
<li><div class=fn>virtual uchar * <a href="#cache"><b>cache</b></a> ( int&nbsp;amount, int&nbsp;optim )</div></li>
<li><div class=fn>virtual void <a href="#uncache"><b>uncache</b></a> ( uchar&nbsp;*&nbsp;c )</div></li>
</ul>
<h2>Protected Members</h2>
<ul>
<li><div class=fn>void <a href="#deleteEntry"><b>deleteEntry</b></a> ( uchar&nbsp;*&nbsp;c )</div></li>
</ul>
<h2>Static Protected Members</h2>
<ul>
<li><div class=fn>void <b>clearCache</b> ( QScreen&nbsp;*&nbsp;instance, int )</div></li>
</ul>
<hr><a name="details"></a><h2>Detailed Description</h2>


QLinuxFbScreen manages the Linux framebuffer. Accelerated drivers
for Linux should inherit from it; it contains code for reading information
about the framebuffer from the Linux framebuffer interface, managing
the color palette, managing offscreen graphics memory and mapping the 
framebuffer interface itself, removing the need for drivers to do this.
It also acts as a factory for the unaccelerated screen cursor and
unaccelerated QGfxes. QLinuxFbScreen is a descendant of <a href="qscreen.html">QScreen</a>;
there is precisely one per <a href="qt.html">Qt</a>/Embedded application.

<hr><h2>Member Function Documentation</h2>
<h3 class=fn><a name="~QLinuxFbScreen"></a>QLinuxFbScreen::~QLinuxFbScreen ()<tt> [virtual]</tt>
</h3>

Destroys a QLinuxFbScreen.

<h3 class=fn>uchar * <a name="cache"></a>QLinuxFbScreen::cache ( int&nbsp;amount, int&nbsp;optim )<tt> [virtual]</tt>
</h3>
Requests a block of offscreen graphics card memory from the memory
manager; it will be aligned at pixmapOffsetAlignment(). If no memory
is free 0 will be returned, otherwise a pointer to the data within
the framebuffer. QScreen::onCard can be used to retrieve a byte offset
from the start of graphics card memory from this pointer. The display
is locked while memory is allocated and unallocated in order to
preserve the memory pool's integrity, so cache and uncache should not
be called if the screen is locked.
<p> \amount is the amount of memory to allocate, <em>optim</em> gives the optimization
level (same values as QPixmap::Optimization).

<h3 class=fn>bool <a name="connect"></a>QLinuxFbScreen::connect ( const&nbsp;<a href="qstring.html">QString</a>&nbsp;&amp;&nbsp;displaySpec )<tt> [virtual]</tt>
</h3>

This is called by <a href="qt.html">Qt</a>/Embedded clients to map in the framebuffer.
It should be reimplemented by accelerated drivers to map in graphics
card registers; those drivers should then call this method in order to set 
up offscreen memory management.

<h3 class=fn>void <a name="deleteEntry"></a>QLinuxFbScreen::deleteEntry ( uchar&nbsp;*&nbsp;c )<tt> [protected]</tt>
</h3>
Delete a block of memory allocated from graphics card memory.

<h3 class=fn>void <a name="disconnect"></a>QLinuxFbScreen::disconnect ()<tt> [virtual]</tt>
</h3>

This simply unmaps the framebuffer

<h3 class=fn>bool <a name="initDevice"></a>QLinuxFbScreen::initDevice ()<tt> [virtual]</tt>
</h3>

This is called by the <a href="qt.html">Qt</a>/Embedded server at startup time.
It turns off console blinking, sets up the color palette, enables
write combining on the framebuffer and initialises the offscreen
memory manager.

<h3 class=fn>void <a name="restore"></a>QLinuxFbScreen::restore ()<tt> [virtual]</tt>
</h3>

This is called when the virtual console is switched back to <a href="qt.html">Qt</a>/Embedded
and restores the palette.

<p>Reimplemented from <a href="qscreen.html#restore">QScreen</a>.
<h3 class=fn>void <a name="save"></a>QLinuxFbScreen::save ()<tt> [virtual]</tt>
</h3>

This doesn't do anything; accelerated drivers may wish to reimplement
it to save graphics cards registers. It's called by the <a href="qt.html">Qt</a>/Embedded server
when the virtual console is switched.

<p>Reimplemented from <a href="qscreen.html#save">QScreen</a>.
<h3 class=fn>void <a name="set"></a>QLinuxFbScreen::set ( unsigned&nbsp;int&nbsp;i, unsigned&nbsp;int&nbsp;r, unsigned&nbsp;int&nbsp;g, unsigned&nbsp;int&nbsp;b )<tt> [virtual]</tt>
</h3>

In paletted graphics modes, this sets color index i to the specified RGB
value.

<p>Reimplemented from <a href="qscreen.html#set">QScreen</a>.
<h3 class=fn>void <a name="setMode"></a>QLinuxFbScreen::setMode ( int&nbsp;nw, int&nbsp;nh, int&nbsp;nd )<tt> [virtual]</tt>
</h3>

Sets the framebuffer to a new resolution and bit depth. After doing this
any currently-existing gfx's will be invalid and the screen should be
completely redrawn. In a multiple-process Embedded <a href="qt.html">Qt</a> situation you will
need to signal all other applications to also <a href="#setMode">setMode</a>() to the same mode
and redraw.

<h3 class=fn>void <a name="shutdownDevice"></a>QLinuxFbScreen::shutdownDevice ()<tt> [virtual]</tt>
</h3>

This is called by the <a href="qt.html">Qt</a>/Embedded server when it shuts down, and should
be inherited if you need to do any card-specific shutting down.
The default version hides the screen cursor and reenables the blinking cursor
and screen blanking.

<p>Reimplemented from <a href="qscreen.html#shutdownDevice">QScreen</a>.
<h3 class=fn>void <a name="uncache"></a>QLinuxFbScreen::uncache ( uchar&nbsp;*&nbsp;c )<tt> [virtual]</tt>
</h3>
Delete a block of memory allocated from graphics card memory.
<p> This function will first sync the graphics card to ensure the 
memory isn't still being used by a command in the graphics 
card fifo queue.
<p> You can speed up a driver by overriding uncache to avoid 
syncing, however it will then be up to the driver to ensure
the memory at <em>c</em> is no longer being used.  For example the
driver might delay deleting the memory until it detects that
all commands dealing with the memory are no longer in the
queue.
<p> <p>See also <a href="#deleteEntry">deleteEntry</a>() and sync().

<!-- eof -->
<hr><p>
This file is part of the <a href="../index.html">Qtopia </a>,
copyright &copy; 1995-2002
<a href="http://www.trolltech.com/">Trolltech</a>, all rights reserved.<p><address><hr><div align=center>
<table width=100% cellspacing=0 border=0><tr>
<td>Copyright &copy; 2001-2002 Trolltech<td><a href="http://www.trolltech.com/trademarks.html">Trademarks</a>
<td align=right><div align=right>Qtopia version 1.7.0</div>
</table></div></address></body>
</html>
