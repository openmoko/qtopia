<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<!-- /home/ianw/dev/packages/qtopia/1.6/tmp12327/qtopia/doc/pluginintro.doc:1 -->
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
<style type="text/css"><!--
h3.fn,span.fn { margin-left: 1cm; text-indent: -1cm; }
a:link { color: #004faf; text-decoration: none }
a:visited { color: #672967; text-decoration: none }
body { background: #ffffff; color: black; }
--></style>
</head>
<body>

<table border="0" cellpadding="0" cellspacing="0" width="100%">
<tr bgcolor="black"><td>
<a href="classes.html"><font color="white">Qt API</font></a>
<font color="white">|</font>
<a href="../classes.html"> <font color="white">Qtopia API</font></a>
</td>
<td align="right"><a href="../index.html"><font color="white"><i>Qtopia Documentation</i></font></a></td>
<td align="right" valign="center"><img src="logo32.png" align="right" width="64" height="32" border="0"></td></tr></table>
<p> 
<p> <h2> Introduction to Qtopia Plugins
</h2>
<a name="1"></a><p> Plugins are implemented in Qtopia via a COM-like layer.  The basic steps
to writing any Qtopia plugin are:
<ul>
<li> Write the functionality that the plugin will provide.
<li> Subclass the interface for the plugin you wish to write.
<li> Provide implemetations for the interface methods.
<li> Create an instance of the plugin.
</ul>
<p> There are also some basic rules to follow when writing a plugin:
<ul>
<li> Due to the implementation details of moc, it is important that any <a href="qobject.html">QObject</a>
subclasses in your plugin have unique names to prevent clashes between
two plugins.  As a rule, use a unique prefix for all classes including
internal classes.  For example, if a plugin "foo" has an internal helper
class that is a QObject subclass, it should be named FooHelper
rather than Helper.
<li> Plugins should not leak memory.  Since a plugin may be unloaded at any
time it is important to cleanup all used memory when your plugin interface
is destructed.
</ul>
<p> <h3> Writing the functionality
</h3>
<a name="1-1"></a><p> Consider the following fictious plugin interface:
<p> <pre>
// {05E0A4AB-DDC5-4449-85A9-828100DE00A9} 
#ifndef IID_WidgetPlugin
#define IID_WidgetPlugin QUuid( 0x05e0a4ab, 0xddc5, 0x4449, 0x85, 0xa9, 0x82, 0x81, 0x00, 0xde, 0x00, 0xa9)
#endif

struct WidgetPluginInterface : public QUnknownInterface
{
    virtual QWidget *widget( <a href="qwidget.html">QWidget</a> *parent ) = 0;
    virtual QString name() const = 0;
};
</pre>
 
<p> This is a simple interface that provides a plugin name and a widget that
is created with the supplied parent.
<p> IID_WidgetPlugin defines a unique ID for this interface.
<p> The plugin that we are writing provides a widget that draws an ellipse in
its center.  The code below implements the functionality that this plugin
provides.
<p> <pre>
class EllipseWidget : public <a href="qwidget.html">QWidget</a>
{
    Q_OBJECT
public:
    EllipseWidget( <a href="qwidget.html">QWidget</a> *parent=0 ) : <a href="qwidget.html">QWidget</a>( parent, "Ellipse" )
    {
    }

protected:
    void paintEvent( <a href="qpaintevent.html">QPaintEvent</a> * )
    {
        <a href="qpainter.html">QPainter</a> p( this );
        p.<a href="qpainter.html#drawEllipse">drawEllipse</a>( rect() );
    }
};
</pre>
 
<p> <h3> Subclassing the interface
</h3>
<a name="1-2"></a><p> Now you can subclass the WidgetPluginInterface:
<p> <pre>
struct CirclePlugin : public WidgetPluginInterface
{
public:
    virtual QWidget *widget( <a href="qwidget.html">QWidget</a> *parent );
    virtual QString name() const;

    QRESULT queryInterface( const <a href="quuid.html">QUuid</a>&amp;, QUnknownInterface** );
    Q_REFCOUNT

protected:
    CircleWidget *w;
    ulong ref;
};
</pre>
 
<p> There are two things to note in the CirclePlugin struct:
<ul>
<li> the queryInterface() function allows the plugin loader to query
what interfaces the plugin implements.
<li> Q_REFCOUNT is a macro to simplify the reference counting.
This macro expects the ulog ref variable to be present.
</ul>
<p> <h3> Implementing the interface
</h3>
<a name="1-3"></a><p> The constructor an destructor are straight-forward.  The most important
point is that ref must be initialised with 0.
<pre>
CirclePlugin::CirclePlugin()
    : w(0), ref(0)
{
}

CirclePlugin::~CirclePlugin()
{
    delete w;
}
</pre>
 
<p> The queryInterface() function can be implemented using the
following boilerplate code:
<p> <pre>
QRESULT CirclePlugin::queryInterface( const <a href="quuid.html">QUuid</a> &amp;uuid, QUnknownInterface **iface )
{
    *iface = 0;
    if ( uuid == IID_QUnknown )
        *iface = this;
    else if ( uuid == IID_WidgetPlugin )
        *iface = this;
    else
        return QS_FALSE;

    (*iface)-&gt;addRef();
    return QS_OK;
}
</pre>
 
<p> A plugin can provide several interfaces.  At the very least QUnknownInterface
is provided by all plugins.
<p> The widget() function returns the widget.
<p> <pre>
QWidget *CirclePlugin::widget( <a href="qwidget.html">QWidget</a> *parent )
{
    if ( !w )
        w = new CircleWidget( parent );
    return w;
}
</pre>
 
<p> The name() function returns the name of the plugin.
<p> <pre>
QString CirclePlugin::name()
{
    return qApp-&gt;<a href="qapplication.html#translate">translate</a>( "WidgetPlugin", "Circle" );
}
</pre>
 
<p> <h3> Creating an instance
</h3>
<a name="1-4"></a><p> You must also create an instance of the widget plugin using the
following boilerplate code:
<p> <pre>
Q_EXPORT_INTERFACE()
{
    Q_CREATE_INSTANCE( CirclePlugin )
}
</pre>
 
<p> 
<!-- eof -->
<p><address><hr><div align=center>
<table width=100% cellspacing=0 border=0><tr>
<td>Copyright &copy; 2001-2002 Trolltech<td><a href="http://www.trolltech.com/trademarks.html">Trademarks</a>
<td align=right><div align=right>Qtopia version 1.6.0</div>
</table></div></address></body>
</html>
