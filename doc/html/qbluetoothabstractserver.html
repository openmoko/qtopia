<?xml version="1.0" encoding="iso-8859-1"?>
<!DOCTYPE html
    PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
  <title>QBluetoothAbstractServer Class Reference</title>
  <link href="classic.css" rel="stylesheet" type="text/css" />
</head>
<body>
<table border="0" cellpadding="0" cellspacing="0" width="100%">
<tr>
<td align="left" valign="top" width="32"><img src="images/qpelogo.png" align="left" width="32" height="32" border="0" /></td>
<td width="1">&nbsp;&nbsp;</td><td class="postheader" valign="center"><a href="index.html"><font color="#004faf">Home</font></a>&nbsp;&middot; <a href="classes.html"><font color="#004faf">All&nbsp;Classes</font></a>&nbsp;&middot; <a href="groups.html"><font color="#004faf">Grouped Classes</font></a>&nbsp;&middot; <a href="annotated.html"><font color="#004faf">Annotated</font></a>&nbsp;&middot; <a href="functions.html"><font color="#004faf">Functions</font></a></td>
<td align="right" valign="top" width="230"><img src="images/trolltech-logo.png" align="right" width="203" height="32" border="0" /></td></tr></table><h1 class="title">QBluetoothAbstractServer Class Reference</h1>
<p>The QBluetoothAbstractServer class represents an abstract Bluetooth server socket. <a href="#details">More...</a></p>
<pre>    #include &lt;QBluetoothAbstractServer&gt;</pre><p>Inherits <a href="qobject.html">QObject</a>.</p>
<p>Inherited by <a href="qbluetoothl2capserver.html">QBluetoothL2CapServer</a>, <a href="qbluetoothrfcommserver.html">QBluetoothRfcommServer</a>, and <a href="qbluetoothscoserver.html">QBluetoothScoServer</a>.</p>
<ul>
<li><a href="qbluetoothabstractserver-members.html">List of all members, including inherited members</a></li>
</ul>
<a name="public-functions"></a>
<h3>Public Functions</h3>
<ul>
<li><div class="fn"/><b><a href="qbluetoothabstractserver.html#dtor.QBluetoothAbstractServer">~QBluetoothAbstractServer</a></b> ()</li>
<li><div class="fn"/>virtual void <b><a href="qbluetoothabstractserver.html#close">close</a></b> ()</li>
<li><div class="fn"/>QString <b><a href="qbluetoothabstractserver.html#errorString">errorString</a></b> () const</li>
<li><div class="fn"/>bool <b><a href="qbluetoothabstractserver.html#hasPendingConnections">hasPendingConnections</a></b> () const</li>
<li><div class="fn"/>bool <b><a href="qbluetoothabstractserver.html#isListening">isListening</a></b> () const</li>
<li><div class="fn"/>int <b><a href="qbluetoothabstractserver.html#maxPendingConnections">maxPendingConnections</a></b> () const</li>
<li><div class="fn"/>QBluetoothAbstractSocket * <b><a href="qbluetoothabstractserver.html#nextPendingConnection">nextPendingConnection</a></b> ()</li>
<li><div class="fn"/>QBluetoothAbstractSocket::SocketError <b><a href="qbluetoothabstractserver.html#serverError">serverError</a></b> () const</li>
<li><div class="fn"/>void <b><a href="qbluetoothabstractserver.html#setMaxPendingConnections">setMaxPendingConnections</a></b> ( int <i>numConnections</i> )</li>
<li><div class="fn"/>int <b><a href="qbluetoothabstractserver.html#socketDescriptor">socketDescriptor</a></b> () const</li>
<li><div class="fn"/>bool <b><a href="qbluetoothabstractserver.html#waitForNewConnection">waitForNewConnection</a></b> ( int <i>msecs</i> = 0, bool * <i>timedOut</i> = 0 )</li>
</ul>
<ul>
<li><div class="fn"/>29 public functions inherited from <a href="qobject.html#public-functions">QObject</a></li>
</ul>
<a name="signals"></a>
<h3>Signals</h3>
<ul>
<li><div class="fn"/>void <b><a href="qbluetoothabstractserver.html#newConnection">newConnection</a></b> ()</li>
</ul>
<ul>
<li><div class="fn"/>1 signal inherited from <a href="qobject.html#signals">QObject</a></li>
</ul>
<h3>Additional Inherited Members</h3>
<ul>
<li><div class="fn"/>1 property inherited from <a href="qobject.html#properties">QObject</a></li>
<li><div class="fn"/>1 public slot inherited from <a href="qobject.html#public-slots">QObject</a></li>
<li><div class="fn"/>1 public type inherited from <a href="qobject.html#public-variables">QObject</a></li>
<li><div class="fn"/>4 static public members inherited from <a href="qobject.html#static-public-members">QObject</a></li>
<li><div class="fn"/>7 protected functions inherited from <a href="qobject.html#protected-functions">QObject</a></li>
<li><div class="fn"/>2 protected variables inherited from <a href="qobject.html#protected-variables">QObject</a></li>
</ul>
<a name="details"></a>
<hr />
<h2>Detailed Description</h2>
<p>The QBluetoothAbstractServer class represents an abstract Bluetooth server socket.</p>
<p>This class is a common base class for all Bluetooth server socket implementations and makes it possible to accept incoming Bluetooth connections. The users should not use this class directly, instead they should use concrete implementations.</p>
<p>The subclasses will implement a <tt>listen()</tt> implementation in order to create a listening socket for each particular Bluetooth socket type. In particular, <a href="qbluetoothl2capserver.html">QBluetoothL2CapServer</a>, <a href="qbluetoothrfcommserver.html">QBluetoothRfcommServer</a>, and <a href="qbluetoothscoserver.html">QBluetoothScoServer</a> will create L2CAP, RFCOMM and SCO sockets respectively.</p>
<p>Services that provide RFCOMM based profiles should use the <a href="qbluetoothrfcommserver.html">QBluetoothRfcommServer</a> class. L2CAP based services should use the <a href="qbluetoothl2capserver.html">QBluetoothL2CapServer</a> class. Headset and Handsfree profile implementations will require the use of <a href="qbluetoothscoserver.html">QBluetoothScoServer</a> class.</p>
<p>The typical use of this class is to call the <tt>listen()</tt> implementation in the subclass, and then hook onto the <a href="qbluetoothabstractserver.html#newConnection">newConnection</a>() signal to get an indication of an incoming connection. The <a href="qbluetoothabstractserver.html#newConnection">newConnection</a>() signal is emitted each time a client has connected to the server. Call <a href="qbluetoothabstractserver.html#nextPendingConnection">nextPendingConnection</a>() to accept the pending connection as a connected <a href="qbluetoothabstractsocket.html">QBluetoothAbstractSocket</a>. The actual socket type depends on the type of the server. E.g&#x2e; the <a href="qbluetoothrfcommserver.html">QBluetoothRfcommServer</a> socket will return <a href="qbluetoothrfcommsocket.html">QBluetoothRfcommSocket</a> type sockets.</p>
<p>If an error occurs, <a href="qbluetoothabstractserver.html#serverError">serverError</a>() returns the type of error that has occurred.</p>
<p>Calling <a href="qbluetoothabstractserver.html#close">close</a>() makes the QBluetoothAbstractServer stop listening for incoming connections and deletes all pending connections.</p>
<p>See also <a href="qbluetoothabstractsocket.html">QBluetoothAbstractSocket</a>.</p>
<hr />
<h2>Member Function Documentation</h2>
<h3 class="fn"><a name="dtor.QBluetoothAbstractServer"></a>QBluetoothAbstractServer::~QBluetoothAbstractServer ()</h3>
<p>Destroys the server.</p>
<h3 class="fn"><a name="close"></a>void QBluetoothAbstractServer::close ()&nbsp;&nbsp;<tt> [virtual]</tt></h3>
<p>Closes the server. The server will no longer listen for incoming connections and all pending connections will be closed.</p>
<p>See also <a href="qbluetoothabstractserver.html#isListening">isListening</a>() and <a href="qbluetoothabstractserver.html#socketDescriptor">socketDescriptor</a>().</p>
<h3 class="fn"><a name="errorString"></a><a href="qstring.html">QString</a> QBluetoothAbstractServer::errorString () const</h3>
<p>Returns a human-readable description of the last device error that occurred.</p>
<p>See also <a href="qbluetoothabstractserver.html#serverError">serverError</a>().</p>
<h3 class="fn"><a name="hasPendingConnections"></a>bool QBluetoothAbstractServer::hasPendingConnections () const</h3>
<p>Returns true if the server has a pending connection(s); otherwise returns false.</p>
<p>See also <a href="qbluetoothabstractserver.html#nextPendingConnection">nextPendingConnection</a>() and <a href="qbluetoothabstractserver.html#setMaxPendingConnections">setMaxPendingConnections</a>().</p>
<h3 class="fn"><a name="isListening"></a>bool QBluetoothAbstractServer::isListening () const</h3>
<p>Returns true if the server is currently listening for remote connections, and false otherwise.</p>
<p>See also <a href="qbluetoothabstractserver.html#close">close</a>() and <a href="qbluetoothabstractserver.html#socketDescriptor">socketDescriptor</a>().</p>
<h3 class="fn"><a name="maxPendingConnections"></a>int QBluetoothAbstractServer::maxPendingConnections () const</h3>
<p>Returns the maximum number of pending accepted connections. The default is 1.</p>
<p>See also <a href="qbluetoothabstractserver.html#setMaxPendingConnections">setMaxPendingConnections</a>() and <a href="qbluetoothabstractserver.html#hasPendingConnections">hasPendingConnections</a>().</p>
<h3 class="fn"><a name="newConnection"></a>void QBluetoothAbstractServer::newConnection ()&nbsp;&nbsp;<tt> [signal]</tt></h3>
<p>This signal is emitted every time a new connection is available. Call <a href="qbluetoothabstractserver.html#nextPendingConnection">nextPendingConnection</a>() in order to accept the connection.</p>
<p>See also <a href="qbluetoothabstractserver.html#hasPendingConnections">hasPendingConnections</a>() and <a href="qbluetoothabstractserver.html#nextPendingConnection">nextPendingConnection</a>().</p>
<h3 class="fn"><a name="nextPendingConnection"></a><a href="qbluetoothabstractsocket.html">QBluetoothAbstractSocket</a> * QBluetoothAbstractServer::nextPendingConnection ()</h3>
<p>Returns the next pending connection as a connected <a href="qbluetoothabstractsocket.html">QBluetoothAbstractSocket</a> object. The function returns a pointer to a <a href="qbluetoothabstractsocket.html">QBluetoothAbstractSocket</a> in <a href="qbluetoothabstractsocket.html#SocketState-enum">QBluetoothAbstractSocket::ConnectedState</a> that you can use for communicating with the client.</p>
<p>The type of the socket returned will be based on the server socket type used. You will need to use qobject_cast to convert the result into the concrete socket type required.</p>
<pre>    QBluetoothAbstractSocket *sock = server-&gt;nextPendingConnection();
    if (sock) {
        QBluetoothRfcommSocket *rfcomm =
            qobject_cast&lt;QBluetoothRfcommSocket *&gt;(sock);
        if (rfcomm) {
            <span class="comment">// use RFCOMM socket</span>
        }
    }</pre>
<p>The socket is created as a child of the server, which means that it is automatically deleted when the <a href="qbluetoothabstractserver.html">QBluetoothAbstractServer</a> object is destroyed. It is still a good idea to delete the object explicitly when you are done with it, to avoid wasting memory.</p>
<p>A NULL pointer is returned if this function is called when there are no pending connections.</p>
<p>See also <a href="qbluetoothabstractserver.html#hasPendingConnections">hasPendingConnections</a>().</p>
<h3 class="fn"><a name="serverError"></a><a href="qbluetoothabstractsocket.html#SocketError-enum">QBluetoothAbstractSocket::SocketError</a> QBluetoothAbstractServer::serverError () const</h3>
<p>Returns the last error that has occurred.</p>
<p>See also <a href="qbluetoothabstractserver.html#errorString">errorString</a>().</p>
<h3 class="fn"><a name="setMaxPendingConnections"></a>void QBluetoothAbstractServer::setMaxPendingConnections ( int <i>numConnections</i> )</h3>
<p>Sets the maximum number of pending accepted connections to <i>numConnections</i>. <a href="qbluetoothabstractserver.html">QBluetoothAbstractServer</a> will accept no more than <i>numConnections</i> incoming connections before <a href="qbluetoothabstractserver.html#nextPendingConnection">nextPendingConnection</a>() is called. By default, the limit is 1 pending connection.</p>
<p>See also <a href="qbluetoothabstractserver.html#maxPendingConnections">maxPendingConnections</a>() and <a href="qbluetoothabstractserver.html#hasPendingConnections">hasPendingConnections</a>().</p>
<h3 class="fn"><a name="socketDescriptor"></a>int QBluetoothAbstractServer::socketDescriptor () const</h3>
<p>Returns the socket descriptor the server is currently listening on. If the server is not listening, then -1 is returned.</p>
<p>See also <a href="qbluetoothabstractserver.html#isListening">isListening</a>().</p>
<h3 class="fn"><a name="waitForNewConnection"></a>bool QBluetoothAbstractServer::waitForNewConnection ( int <i>msecs</i> = 0, bool * <i>timedOut</i> = 0 )</h3>
<p>Waits for at most <i>msecs</i> milliseconds or until an incoming connection is available. Returns true if a connection is available; otherwise returns false. If the operation timed out and <i>timedOut</i> is not 0, *<i>timedOut</i> will be set to true.</p>
<p>This is a blocking function call. Its use is not advised in a single-threaded GUI application, since the whole application will stop responding until the function returns. waitForNewConnection() is mostly useful when there is no event loop available.</p>
<p>The non-blocking alternative is to connect to the <a href="qbluetoothabstractserver.html#newConnection">newConnection</a>() signal.</p>
<p>See also <a href="qbluetoothabstractserver.html#hasPendingConnections">hasPendingConnections</a>() and <a href="qbluetoothabstractserver.html#nextPendingConnection">nextPendingConnection</a>().</p>
<p /><address><hr /><div align="center">
<table width="100%" cellspacing="0" border="0"><tr class="address">
<td align="left">Copyright &copy; 2008 <a href="trolltech.html">Trolltech</a></td>
<td align="center"><a href="trademarks.html">Trademarks</a></td>
<td align="right"><div align="right">Qtopia 4.3.2</div></td>
</tr></table></div></address></body>
</html>
