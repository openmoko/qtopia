<?xml version="1.0" encoding="iso-8859-1"?>
<!DOCTYPE html
    PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
  <title>RuleEngineScheduler Class Reference</title>
  <link href="classic.css" rel="stylesheet" type="text/css" />
</head>
<body>
<table border="0" cellpadding="0" cellspacing="0" width="100%">
<tr>
<td align="left" valign="top" width="32"><img src="images/qpelogo.png" align="left" width="32" height="32" border="0" /></td>
<td width="1">&nbsp;&nbsp;</td><td class="postheader" valign="center"><a href="index.html"><font color="#004faf">Home</font></a>&nbsp;&middot; <a href="overviews.html"><font color="#004faf">Overviews</font></a>&nbsp;&middot; <a href="reference.html"><font color="#004faf">Reference</font></a>&nbsp;&middot; <a href="classes.html"><font color="#004faf">Classes</font></a></td>
<td align="right" valign="top"><img src="images/codeless.png" align="right" border="0" /></td></tr></table><h1 class="title">RuleEngineScheduler Class Reference</h1>
<pre>    #include &lt;RuleEngineScheduler&gt;</pre><ul>
<li><a href="ruleenginescheduler-members.html">List of all members, including inherited members</a></li>
</ul>
<a name="public-types"></a>
<h3>Public Types</h3>
<ul>
<li><div class="fn"/>typedef <b><a href="ruleenginestate.html#Threads-typedef">Threads</a></b></li>
</ul>
<a name="public-functions"></a>
<h3>Public Functions</h3>
<ul>
<li><div class="fn"/>bool <b><a href="ruleenginescheduler.html#beginCategory">beginCategory</a></b> ( const QStringList &amp; <i>cats</i> )</li>
<li><div class="fn"/>void <b><a href="ruleenginescheduler.html#completeRule">completeRule</a></b> ( const SchedulerRule &amp; <i>me</i>, RuleEngineState::ExecuteState <i>state</i> )</li>
<li><div class="fn"/>void <b><a href="ruleenginescheduler.html#dumpCirc">dumpCirc</a></b> ( Rule * <i>rule</i> )</li>
<li><div class="fn"/>void <b><a href="ruleenginescheduler.html#endCategory">endCategory</a></b> ( const QStringList &amp; <i>cats</i> )</li>
<li><div class="fn"/>QHash&lt;QString, int&gt; <b><a href="ruleenginescheduler.html#guiCategoryRules">guiCategoryRules</a></b> ()</li>
<li><div class="fn"/>void <b><a href="ruleenginescheduler.html#scheduleRule">scheduleRule</a></b> ( const SchedulerRule &amp; <i>srule</i> )</li>
<li><div class="fn"/>SchedulerRule <b><a href="ruleenginescheduler.html#sruleFromName">sruleFromName</a></b> ( const QString &amp; <i>n</i> )</li>
<li><div class="fn"/>SchedulerRule <b><a href="ruleenginescheduler.html#sruleFromRule">sruleFromRule</a></b> ( Rule * <i>r</i> )</li>
<li><div class="fn"/>void <b><a href="ruleenginescheduler.html#throttledRule">throttledRule</a></b> ( const SchedulerRule &amp; <i>srule</i> )</li>
<li><div class="fn"/>void <b><a href="ruleenginescheduler.html#waitOnRule">waitOnRule</a></b> ( const SchedulerRule &amp; <i>me</i>, const QList&lt;SchedulerRule&gt; &amp; <i>requiredRules</i> )</li>
<li><div class="fn"/>void <b><a href="ruleenginescheduler.html#waitUntilDone">waitUntilDone</a></b> ()</li>
</ul>
<a name="public-variables"></a>
<h3>Public Variables</h3>
<ul>
<li><div class="fn"/>Threads <b><a href="ruleenginescheduler.html#threads-var">threads</a></b></li>
</ul>
<a name="details"></a>
<hr />
<h2>Detailed Description</h2>
<p>There is one RuleEngineScheduler per <a href="ruleengine.html">RuleEngine</a> instance.</p>
<hr />
<h2>Member Type Documentation</h2>
<h3 class="fn"><a name="Threads-typedef"></a>typedef RuleEngineScheduler::Threads</h3>
<p>Equivalent to QList&lt;<a href="ruleenginethread.html">RuleEngineThread</a> *&gt;</p>
<hr />
<h2>Member Function Documentation</h2>
<h3 class="fn"><a name="beginCategory"></a>bool RuleEngineScheduler::beginCategory ( const QStringList &amp; <i>cats</i> )</h3>
<p>Attempt to begin running commands for <i>cats</i>. Returns true if the rule can run, false if it is throttled.</p>
<p>Call unlocked.</p>
<h3 class="fn"><a name="completeRule"></a>void RuleEngineScheduler::completeRule ( const <a href="schedulerrule.html">SchedulerRule</a> &amp; <i>me</i>, <a href="ruleenginestate.html#ExecuteState-enum">RuleEngineState::ExecuteState</a> <i>state</i> )</h3>
<p>Do the post-run cleanup for <i>me</i>. Set the state to <i>state</i>.</p>
<p>Call unlocked.</p>
<h3 class="fn"><a name="dumpCirc"></a>void RuleEngineScheduler::dumpCirc ( <a href="rule.html">Rule</a> * <i>rule</i> )</h3>
<p>Dump circular dependencies into a .dot file and inform the user where this file has been written. This happens after the engine has run all of the rules it can run.</p>
<p>Note that <i>rule</i> is not used.</p>
<p>Scheduler stalled - no locking needed.</p>
<h3 class="fn"><a name="endCategory"></a>void RuleEngineScheduler::endCategory ( const QStringList &amp; <i>cats</i> )</h3>
<p>Finish running commands for <i>cats</i>.</p>
<p>Call unlocked.</p>
<h3 class="fn"><a name="guiCategoryRules"></a>QHash&lt;QString, int&gt; RuleEngineScheduler::guiCategoryRules ()</h3>
<p>Returns a list with the number of job running for each category.</p>
<h3 class="fn"><a name="scheduleRule"></a>void RuleEngineScheduler::scheduleRule ( const <a href="schedulerrule.html">SchedulerRule</a> &amp; <i>srule</i> )</h3>
<p>Schedule <i>srule</i>.</p>
<p>Call unlocked.</p>
<h3 class="fn"><a name="sruleFromName"></a><a href="schedulerrule.html">SchedulerRule</a> RuleEngineScheduler::sruleFromName ( const QString &amp; <i>n</i> )</h3>
<p>Returns the scheduler rule that matches <i>n</i>.</p>
<p>Call unlocked.</p>
<h3 class="fn"><a name="sruleFromRule"></a><a href="schedulerrule.html">SchedulerRule</a> RuleEngineScheduler::sruleFromRule ( <a href="rule.html">Rule</a> * <i>r</i> )</h3>
<p>Returns the scheduler rule for <i>r</i>.</p>
<p>Call unlocked.</p>
<h3 class="fn"><a name="throttledRule"></a>void RuleEngineScheduler::throttledRule ( const <a href="schedulerrule.html">SchedulerRule</a> &amp; <i>srule</i> )</h3>
<p>Add a throttled <i>srule</i> to the ready queue. It will not be taken off the queue unless <a href="ruleenginescheduler.html#beginCategory">beginCategory</a>() returns true.</p>
<p>Call unlocked.</p>
<h3 class="fn"><a name="waitOnRule"></a>void RuleEngineScheduler::waitOnRule ( const <a href="schedulerrule.html">SchedulerRule</a> &amp; <i>me</i>, const QList&lt;<a href="schedulerrule.html">SchedulerRule</a>&gt; &amp; <i>requiredRules</i> )</h3>
<p>Scheduler rule <i>me</i> must wait for <i>requiredRules</i> to complete before running. If the rules have already run the rule may be executed immediately.</p>
<p>Call unlocked.</p>
<h3 class="fn"><a name="waitUntilDone"></a>void RuleEngineScheduler::waitUntilDone ()</h3>
<p>Wait until there are no more rules to process (or deadlock is reached).</p>
<p>Call unlocked.</p>
<hr />
<h2>Member Variable Documentation</h2>
<h3 class="fn"><a name="threads-var"></a><a href="ruleenginestate.html#Threads-typedef">Threads</a> RuleEngineScheduler::threads</h3>
<p>All the available threads. Used for tracking and shutdown.</p>
<p /><address><hr /><div align="center">
<table width="100%" cellspacing="0" border="0"><tr class="address">
<td align="left">Copyright &copy; 2008 Trolltech</td>
<td align="right"><div align="right">Qt Extended  - QBuild Maintainer Guide</div></td>
</tr></table></div></address></body>
</html>
