<!DOCTYPE html
    PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
  <title>QtopiaServerApplication Class Reference</title>
  <link href="classic.css" rel="stylesheet" type="text/css" />
</head>
<body>
<table border="0" cellpadding="0" cellspacing="0" width="100%">
<tr>
<td align="left" valign="top" width="32"><img src="images/qpelogo.png" align="left" width="32" height="32" border="0" /></td>
<td width="1">&nbsp;&nbsp;</td><td class="postheader" valign="center"><a href="index.html"><font color="#004faf">Home</font></a>&nbsp;&middot; <a href="classes.html"><font color="#004faf">All&nbsp;Classes</font></a>&nbsp;&middot; <a href="annotated.html"><font color="#004faf">Annotated</font></a>&nbsp;&middot; <a href="functions.html"><font color="#004faf">Functions</font></a></td>
<td align="right" valign="top" width="230"><img src="images/trolltech-logo.png" align="right" width="203" height="32" border="0" /></td></tr></table><h1 align="center">QtopiaServerApplication Class Reference</h1>
<p>The QtopiaServerApplication class provides additional <a href="qtopiaapplication.html">QtopiaApplication</a> functionality. <a href="#details">More...</a></p>
<pre>    #include &lt;QtopiaServerApplication&gt;</pre><p>Inherits <a href="qtopiaapplication.html">QtopiaApplication</a>.</p>
<ul>
<li><a href="qtopiaserverapplication-members.html">List of all members, including inherited members</a></li>
</ul>
<a name="public-types"></a>
<h3>Public Types</h3>
<ul>
<li><div class="fn"/>class <b><a href="qtopiaserverapplication-qwseventfilter.html">QWSEventFilter</a></b></li>
<li><div class="fn"/>enum <b><a href="qtopiaserverapplication.html#ShutdownType-enum">ShutdownType</a></b> { NoShutdown, RebootSystem, RestartDesktop, ShutdownSystem, TerminateDesktop }</li>
</ul>
<a name="public-functions"></a>
<h3>Public Functions</h3>
<ul>
<li><div class="fn"/>void <b><a href="qtopiaserverapplication.html#installQWSEventFilter">installQWSEventFilter</a></b> ( QWSEventFilter * <i>filter</i> )</li>
<li><div class="fn"/>void <b><a href="qtopiaserverapplication.html#removeQWSEventFilter">removeQWSEventFilter</a></b> ( QWSEventFilter * <i>filter</i> )</li>
</ul>
<ul>
<li><div class="fn"/>11 public functions inherited from <a href="qtopiaapplication.html#public-functions">QtopiaApplication</a></li>
<li><div class="fn"/>14 public functions inherited from <a href="qapplication.html#public-functions">QApplication</a></li>
<li><div class="fn"/>8 public functions inherited from <a href="qcoreapplication.html#public-functions">QCoreApplication</a></li>
<li><div class="fn"/>37 public functions inherited from <a href="qobject.html#public-functions">QObject</a></li>
</ul>
<a name="public-slots"></a>
<h3>Public Slots</h3>
<ul>
<li><div class="fn"/>void <b><a href="qtopiaserverapplication.html#shutdown">shutdown</a></b> ( QtopiaServerApplication::ShutdownType <i>type</i> )</li>
</ul>
<ul>
<li><div class="fn"/>3 public slots inherited from <a href="qapplication.html#public-slots">QApplication</a></li>
<li><div class="fn"/>1 public slot inherited from <a href="qcoreapplication.html#public-slots">QCoreApplication</a></li>
<li><div class="fn"/>1 public slot inherited from <a href="qobject.html#public-slots">QObject</a></li>
</ul>
<a name="signals"></a>
<h3>Signals</h3>
<ul>
<li><div class="fn"/>void <b><a href="qtopiaserverapplication.html#shutdownRequested">shutdownRequested</a></b> ()</li>
</ul>
<ul>
<li><div class="fn"/>9 signals inherited from <a href="qtopiaapplication.html#signals">QtopiaApplication</a></li>
<li><div class="fn"/>4 signals inherited from <a href="qapplication.html#signals">QApplication</a></li>
<li><div class="fn"/>1 signal inherited from <a href="qcoreapplication.html#signals">QCoreApplication</a></li>
<li><div class="fn"/>1 signal inherited from <a href="qobject.html#signals">QObject</a></li>
</ul>
<a name="static-public-members"></a>
<h3>Static Public Members</h3>
<ul>
<li><div class="fn"/>void <b><a href="qtopiaserverapplication.html#addAggregateObject">addAggregateObject</a></b> ( QObject * <i>me</i>, QObject * <i>them</i> )</li>
<li><div class="fn"/>int &amp; <b><a href="qtopiaserverapplication.html#argc">argc</a></b> ()</li>
<li><div class="fn"/>char ** <b><a href="qtopiaserverapplication.html#argv">argv</a></b> ()</li>
<li><div class="fn"/>QtopiaServerApplication * <b><a href="qtopiaserverapplication.html#instance">instance</a></b> ()</li>
<li><div class="fn"/>QObject * <b><a href="qtopiaserverapplication.html#qtopiaTask">qtopiaTask</a></b> ( const QByteArray &amp; <i>taskName</i>, bool <i>onlyRunning</i> = false )</li>
<li><div class="fn"/>ShutdownType <b><a href="qtopiaserverapplication.html#shutdownType">shutdownType</a></b> ()</li>
<li><div class="fn"/>bool <b><a href="qtopiaserverapplication.html#startup">startup</a></b> ( int &amp; <i>argc</i>, char ** <i>argv</i> )</li>
<li><div class="fn"/>QString <b><a href="qtopiaserverapplication.html#taskConfigFile">taskConfigFile</a></b> ()</li>
<li><div class="fn"/>QByteArray <b><a href="qtopiaserverapplication.html#taskValueSpaceObject">taskValueSpaceObject</a></b> ( const QByteArray &amp; <i>taskName</i> )</li>
<li><div class="fn"/>bool <b><a href="qtopiaserverapplication.html#taskValueSpaceSetAttribute">taskValueSpaceSetAttribute</a></b> ( const QByteArray &amp; <i>taskName</i>, const QByteArray &amp; <i>attribute</i>, const QVariant &amp; <i>value</i> )</li>
</ul>
<ul>
<li><div class="fn"/>18 static public members inherited from <a href="qtopiaapplication.html#static-public-members">QtopiaApplication</a></li>
<li><div class="fn"/>90 static public members inherited from <a href="qapplication.html#static-public-members">QApplication</a></li>
<li><div class="fn"/>37 static public members inherited from <a href="qcoreapplication.html#static-public-members">QCoreApplication</a></li>
<li><div class="fn"/>4 static public members inherited from <a href="qobject.html#static-public-members">QObject</a></li>
</ul>
<a name="related-non-members"></a>
<h3>Related Non-Members</h3>
<ul>
<li><div class="fn"/>T * <b><a href="qtopiaserverapplication.html#qtopiaTask">qtopiaTask</a></b> ( bool <i>onlyActive</i> = false )</li>
<li><div class="fn"/>QList&lt;T *&gt; <b><a href="qtopiaserverapplication.html#qtopiaTasks">qtopiaTasks</a></b> ( bool <i>onlyActive</i> = false )</li>
<li><div class="fn"/>T * <b><a href="qtopiaserverapplication.html#qtopiaWidget">qtopiaWidget</a></b> ( QWidget * <i>parent</i>, Qt::WFlags <i>flags</i> )</li>
</ul>
<a name="macros"></a>
<h3>Macros</h3>
<ul>
<li><div class="fn"/><b><a href="qtopiaserverapplication.html#QTOPIA_DEMAND_TASK">QTOPIA_DEMAND_TASK</a></b> (  <i>TaskName</i>,  <i>Object</i> )</li>
<li><div class="fn"/><b><a href="qtopiaserverapplication.html#QTOPIA_REPLACE_WIDGET">QTOPIA_REPLACE_WIDGET</a></b> (  <i>AbstractWidget</i>,  <i>ConcreteWidget</i> )</li>
<li><div class="fn"/><b><a href="qtopiaserverapplication.html#QTOPIA_REPLACE_WIDGET_OVERRIDE">QTOPIA_REPLACE_WIDGET_OVERRIDE</a></b> (  <i>AbstractWidget</i>,  <i>ConcreteWidget</i> )</li>
<li><div class="fn"/><b><a href="qtopiaserverapplication.html#QTOPIA_REPLACE_WIDGET_WHEN">QTOPIA_REPLACE_WIDGET_WHEN</a></b> (  <i>AbstractWidget</i>,  <i>ConcreteWidget</i>,  <i>Feature</i> )</li>
<li><div class="fn"/><b><a href="qtopiaserverapplication.html#QTOPIA_STATIC_TASK">QTOPIA_STATIC_TASK</a></b> (  <i>TaskName</i>,  <i>Function</i> )</li>
<li><div class="fn"/><b><a href="qtopiaserverapplication.html#QTOPIA_TASK">QTOPIA_TASK</a></b> (  <i>TaskName</i>,  <i>Object</i> )</li>
<li><div class="fn"/><b><a href="qtopiaserverapplication.html#QTOPIA_TASK_INTERFACE-16">QTOPIA_TASK_INTERFACE</a></b> (  <i>ClassName</i> )</li>
<li><div class="fn"/><b><a href="qtopiaserverapplication.html#QTOPIA_TASK_PROVIDES">QTOPIA_TASK_PROVIDES</a></b> (  <i>TaskName</i>,  <i>Interface</i> )</li>
<li><div class="fn"/><b><a href="qtopiaserverapplication.html#QTOPIA_TASK_QINTERFACE">QTOPIA_TASK_QINTERFACE</a></b> (  <i>InterfaceName</i> )</li>
</ul>
<h3>Additional Inherited Members</h3>
<ul>
<li><div class="fn"/>11 properties inherited from <a href="qapplication.html#properties">QApplication</a></li>
<li><div class="fn"/>3 properties inherited from <a href="qcoreapplication.html#properties">QCoreApplication</a></li>
<li><div class="fn"/>1 property inherited from <a href="qobject.html#properties">QObject</a></li>
<li><div class="fn"/>2 public variables inherited from <a href="qapplication.html#public-variables">QApplication</a></li>
<li><div class="fn"/>1 public type inherited from <a href="qobject.html#public-variables">QObject</a></li>
<li><div class="fn"/>8 protected functions inherited from <a href="qobject.html#protected-functions">QObject</a></li>
<li><div class="fn"/>2 protected variables inherited from <a href="qobject.html#protected-variables">QObject</a></li>
<li><div class="fn"/>1 static protected member inherited from <a href="qobject.html#static-protected-members">QObject</a></li>
</ul>
<a name="details"></a>
<hr />
<h2>Detailed Description</h2>
<p>The QtopiaServerApplication class provides additional <a href="qtopiaapplication.html">QtopiaApplication</a> functionality.</p>
<a name="qtopia-server-tasks"></a>
<h3>Qtopia Server Tasks</h3>
<p>The QtopiaServerApplication class acts as a <a href="qtopiaapplication.html">QtopiaApplication</a> instance in Qtopia Server. QtopiaServerApplication is primarily responsible for bringing up and shutting down the Qtopia server and acts as the &quot;core&quot; contoller in the system.</p>
<p>The Qtopia server is structured as a collection of largely independent <i>tasks</i>. Tasks are responsible for performing a small, well defined portion of work or functionality. Often tasks form the &quot;backend&quot; to other system capabilities. For example, Qtopia's network management APIs ultimately communicate with the <a href="qtopianetworkserver.html">QtopiaNetworkServer</a> task. Other tasks operate more independently. Tasks can be thought of as the building blocks that, when arranged appropriately, form the Qtopia server.</p>
<p>Tasks are QObjects. Tasks may work together by exporting C++ interfaces. Other tasks or modules within the server may request tasks that support a particular interface. For example, when the system is shutting down, all the tasks that provide the <a href="systemshutdownhandler.html">SystemShutdownHandler</a> interface are invoked to perform all the necessary cleanup.</p>
<p>The order in which the task objects are instantiated is configurable. Both the configurator and the task developer has a degree of control over the instantiation order. The configurator controls the start up order through the <tt>$QPEDIR/etc/Tasks.cfg</tt> file. The <tt>Tasks.cfg</tt> file has the following simple syntax:</p>
<pre>    # Sample comment for TaskGroup1.  Comments may appear anywhere, as long as
    # the first character in the line is a '#'
    [TaskGroup1]
    TaskName1
    +TaskGroup2
    # Likewise, blank lines, as well as leading and trailing white space is
    # ignored

    [TaskGroup2]
    TaskName2
    TaskName3</pre>
<p>Task groups are free form descriptors used to collect related classes together. Task group names may only contain alphanumeric characters. In particular, they may <i>not</i> contain spaces. A task's name is the name given to the task when it is declared in code. Much like task group names, task names consist only of alphanumeric characters and, again, cannot contain spaces. Groups may be nested heirarchally as shown in the example. Nesting one group in another is <i>exactly</i> the same as pasting the body of the nested group into the parent group. The above <tt>Tasks.cfg</tt> file is equivalent to:</p>
<pre>    [TaskGroup1]
    TaskName1
    TaskName2
    TaskName3

    [TaskGroup2]
    TaskName2
    TaskName3</pre>
<p>There are three reserved group names. The <tt>startup</tt> group contains tasks to be launched at startup. The <tt>exclude</tt> group contains tasks that, while present in the server, will <i>never</i> be created. Adding a task to the <tt>exclude</tt> list is equivalent to removing it from the server. Finally, the <tt>All</tt> group is a catch all tasks whose startup preference is not otherwise specified. How these groups interact will be covered shortly.</p>
<p>Tasks are constructed in one of two ways: preemptively or on-demand. Preemptive tasks are those started by the system during startup, regardless of whether or not any other task has asked for it. On-demand tasks are those whose creation is deferred until another task requests it be started. Tasks in the <tt>startup</tt> group in <tt>Tasks.cfg</tt> are the only tasks that are created preemptively. All other tasks (with the exception of those in the <tt>exclude</tt> group which are never started) are started on-demand.</p>
<p>While it is possible to instantiate an on-demand task by name, it is generally not advisable as doing so often creates unnecessary coupling within the system. Instead, requestors ask the system to return to them a task that supports a given interface. Doing so allows the particular implementation to be switched out without any code changes to the requestor.</p>
<p>The <a href="qtopiaserverapplication.html#qtopiaTask">qtopiaTask</a>() and <a href="qtopiaserverapplication.html#qtopiaTasks">qtopiaTasks</a>() templates are used to request a task interface. <a href="qtopiaserverapplication.html#qtopiaTask">qtopiaTask</a>() returns the first task that implements the interface and <a href="qtopiaserverapplication.html#qtopiaTasks">qtopiaTasks</a>() returns all the tasks that implement the interface. Each of these calls takes an optional boolean parameter to indicate whether the system should instantiate a task to satisfy the request (if needed) or only return tasks that have previously been instantiated.</p>
<p>The order of tasks returned by <a href="qtopiaserverapplication.html#qtopiaTask">qtopiaTask</a>() and <a href="qtopiaserverapplication.html#qtopiaTasks">qtopiaTasks</a>() is controllable through the order in which they appear in the <tt>Tasks.cfg</tt> file. Consider the <tt>Tasks.cfg</tt> flattened so that it consists of all groups in the order in which they appear in the <tt>Tasks.cfg</tt> file. Each task in this imaginary task list implements zero or more interfaces. The order tasks will be returned when requested by interface is the same order as those tasks appear in this list, with duplicates removed.</p>
<p>As a special &quot;catch all&quot;, primarily to prevent misconfiguration, the special <tt>All</tt> &quot;task&quot; can be added to the <tt>startup</tt> group. This has the effect of inserting all tasks not otherwise in the <tt>startup</tt> or <tt>exclude</tt> groups or explicitly marked as demand started tasks. Tasks in the <tt>Tasks.cfg</tt> file can be marked as demand started tasks by appending the <tt>:demand</tt> to their task name. Likewise, group names can have <tt>:demand</tt> appended, which is equivalent to adding the designator to each of their containing task or sub-group names. Demand tasks will never be picked by the <tt>All</tt> catch all task, but are otherwise subject to all ordering primatives.</p>
<p>While the QtopiaServerApplication class itself is not strictly a task, it is instantiated during startup by the task system in the same way as other tasks under the special task name <tt>QtopiaApplication</tt>. The <tt>QtopiaApplication</tt> task should be instantiated immediately after any environment setup or cleanup type tasks as many other tasks have an implicit reliance on its existance.</p>
<p>The order that the system will try and start preemptive tasks and the order in which tasks will be given interface preference can be read from the value space immediately followign the <tt>QtopiaApplication</tt> task executing. The exact schema is:</p>
<p><table align="center" cellpadding="2" cellspacing="1" border="0">
<thead><tr valign="top" class="qt-style"><th>Item</th><th>Type</th><th>Description</th></tr></thead>
<tr valign="top" class="odd"><td><tt>/System/Tasks/&lt;TaskName&gt;/Order/Static</tt></td><td>int</td><td>The preemptive order that the system determined it would launch tasks. This may be different from the actual order if one task demand loads another that would otherwise be loaded later.</td></tr>
<tr valign="top" class="even"><td><tt>/System/Tasks/&lt;TaskName&gt;/Order/Launch</tt></td><td>int</td><td>The order that the tasks were actually launched in. This key will only exist if the task is active.</td></tr>
<tr valign="top" class="odd"><td><tt>/System/Tasks/&lt;TaskName&gt;/Order/Interface</tt></td><td>int</td><td>The order that the task will be given when determining interface associations.</td></tr>
<tr valign="top" class="even"><td><tt>/System/Tasks/&lt;TaskName&gt;/State</tt></td><td>String</td><td>&quot;Disable&quot; if the task was in the <tt>exclude</tt> list, &quot;Active&quot; if the task is running, or &quot;Inactive&quot; if not.</td></tr>
</table></p>
<a name="qtopia-server-widgets"></a>
<h3>Qtopia Server Widgets</h3>
<p>There are many cases of Qt widgets being used throughout the Qtopia server that may need to be customized to achieve a desired look and feel. For example, while it supports customization through themeing, a customer that wants to replace the Qtopia phone dialer with a &quot;rotary dial&quot; style dialer would need to replace the entire dialer widget.</p>
<p>To simplify the task and minimize the code changes needed to replace visual components of the Qtopia Server, the concept of Qtopia Server Widgets exists. Qtopia Server Widgets splits the definition of a visual component - or server widget - into two parts: the server widget interface (hereafter referred to as the AbstractWidget) and the concrete server widget implementation (ConcreteWidget). While not technically necessary, the AbstractWidget is generally an abstract interface that derives directly from <a href="qwidget.html">QWidget</a>.</p>
<p>Rather than using the regular <tt>new ClassName(parent, flags)</tt> syntax for instantiating a widget, the special <a href="qtopiaserverapplication.html#qtopiaWidget">qtopiaWidget</a>() template method, parameterized on AbstractWidget, is provided. This method uses the server widgets replacement system to look up the ConcreteWidget instance type it should return.</p>
<p>Developers use the <a href="qtopiaserverapplication.html#QTOPIA_REPLACE_WIDGET">QTOPIA_REPLACE_WIDGET</a>(), <a href="qtopiaserverapplication.html#QTOPIA_REPLACE_WIDGET_WHEN">QTOPIA_REPLACE_WIDGET_WHEN</a>() and <a href="qtopiaserverapplication.html#QTOPIA_REPLACE_WIDGET_OVERRIDE">QTOPIA_REPLACE_WIDGET_OVERRIDE</a>() macros to provide ConcreteWidget for a particular AbstractWidget. The server widget replacement system then resolves which ConcreteWidget to return by executing the following set of rules in order until a ConcreteWidget is determined.</p>
<p><table align="center" cellpadding="2" cellspacing="1" border="0">
<thead><tr valign="top" class="qt-style"><th>Rule</th><th>Description</th></tr></thead>
<tr valign="top" class="odd"><td>Explicitly specified</td><td>The <tt>Trolltech/ServerWidgets</tt> configuration file is read to determine if the ConcreteWidget to use has been explicitly specified. The configuration file contains one group, <tt>Mapping</tt> that contains mappings between <i>AbstractName</i> and <i>ConcreteName</i>. How these two names are determined is discussed below. For example,<pre>    [Mapping]
    BrowserScreen=Wheel
    DialerScreen=Rotary</pre>
<p>Unless the specified widget does not exist, the mapping is always honoured. That is, using <a href="qtopiaserverapplication.html#QTOPIA_REPLACE_WIDGET_WHEN">QTOPIA_REPLACE_WIDGET_WHEN</a>() can not override explicitly specified widgets. The special name <tt>None</tt> will disable the widget, causing <a href="qtopiaserverapplication.html#qtopiaWidget">qtopiaWidget</a>() to always return null.</p>
</td></tr>
<tr valign="top" class="even"><td>Primary Default</td><td>The primary default is the value of the <tt>Mapping/Default</tt> key, or <tt>Default</tt> if not specified. The primary default name is tried as the <i>ConcreteName</i>. Feature dependencies are honoured.</td></tr>
<tr valign="top" class="odd"><td>Other Defaults</td><td>All <i>ConcreteName</i>'s beginning with the primary default name are tried. Feature dependencies are honoured.</td></tr>
<tr valign="top" class="even"><td>All Replacements</td><td>All available ConcreteWidgets are tried. Feature dependencies are honoured.</td></tr>
</table></p>
<p>The <i>AbstractName</i> and <i>ConcreteName</i> names used to identify a server widget are derived from the widget class names. <i>AbstractName</i> is set to the AbstractWidget's full name, unless the name begins with <tt>QAbstract</tt> in which case it is set to the widget class name, minus the <tt>QAbstract</tt> prefix. The <i>ConcreteName</i> is set to the class name of the ConcreteWidget, unless the class name ends with the <i>AbstractName</i> of the widget it is replacing, in which case it is set to the widget class name minus the <i>AbstractName</i> suffix. These rules are designed to simplify writing mapping files - a class <tt>WheelBrowserScreen</tt> replacing <tt>QAbstractBrowserScreen</tt> is written as <tt>BrowserScreen=Wheel</tt> rather than <tt>QAbstractBrowserScreen=WheelBrowserScreen</tt>.</p>
<hr />
<h2>Member Type Documentation</h2>
<h3 class="fn"><a name="ShutdownType-enum"></a>enum QtopiaServerApplication::ShutdownType</h3>
<p><table border="1" cellpadding="2" cellspacing="1" width="100%">
<tr><th width="25%">Constant</th><th width="15%">Value</th><th width="60%">Description</th></tr>
<tr><td valign="top"><tt>QtopiaServerApplication::NoShutdown</tt></td><td align="center" valign="top"><tt>0</tt></td><td valign="top">No shutdown has been requested.</td></tr>
<tr><td valign="top"><tt>QtopiaServerApplication::RebootSystem</tt></td><td align="center" valign="top"><tt>2</tt></td><td valign="top">The server terminates and initiates the reboot of the system.</td></tr>
<tr><td valign="top"><tt>QtopiaServerApplication::RestartDesktop</tt></td><td align="center" valign="top"><tt>3</tt></td><td valign="top">The server terminates and requests its restart by the calling environment.</td></tr>
<tr><td valign="top"><tt>QtopiaServerApplication::ShutdownSystem</tt></td><td align="center" valign="top"><tt>1</tt></td><td valign="top">The server terminates and initiates the shutdown of the system.</td></tr>
<tr><td valign="top"><tt>QtopiaServerApplication::TerminateDesktop</tt></td><td align="center" valign="top"><tt>4</tt></td><td valign="top">The server terminates only.</td></tr>
</table></p>
<hr />
<h2>Member Function Documentation</h2>
<h3 class="fn"><a name="addAggregateObject"></a>void QtopiaServerApplication::addAggregateObject ( <a href="qobject.html">QObject</a> * <i>me</i>, <a href="qobject.html">QObject</a> * <i>them</i> )&nbsp;&nbsp;<tt> [static]</tt></h3>
<p>Add an object <i>them</i> to <i>me</i> to create an &quot;aggregate&quot; task. Aggregate tasks are designed to work around the limitations in Qt's support for multiple interface inheritance by allowing multiple objects to be &quot;stuck together&quot; to form a single object from the task system's perspective.</p>
<p>For example, consider the following interfaces:</p>
<pre>    class ApplicationLauncherType : public QObject {};
    QTOPIA_TASK_INTERFACE(ApplicationLauncherType);
    class SystemShutdownHandler : public QObject {};
    QTOPIA_TASK_INTERFACE(SystemShutdownHandler);</pre>
<p>Using direct inheritance a single task could not implement both interfaces. Instead, a task can create one object that implements the <tt>ApplicationLauncherType</tt> interface and one that implements the <tt>SystemShutdownHandler</tt> interface and aggregate them together.</p>
<pre>    class MyLauncherShutdown : public SystemShutdownHandler
    {
    public:
        MyLauncherShutdown(MyLauncherType *);
    };

    class MyLauncherType : public ApplicationLauncherType
    {
    public:
        MyLauncherType()
        {
            MyLauncherShutdown *s = new MyLauncherShutdown(this);
            QtopiaServerApplication::addAggregateObject(this, s);
        }
    };
    QTOPIA_TASK(MyLauncherType, MyLauncherType);
    QTOPIA_TASK_PROVIDES(MyLauncherType, ApplicationLauncherType);
    QTOPIA_TASK_PROVIDES(MyLauncherType, SystemShutdownHandler);</pre>
<p>When the system attempts to cast a task to a particular interface, it first tries the task object itself, and then each of the aggregate objects for that task.</p>
<h3 class="fn"><a name="argc"></a>int &amp; QtopiaServerApplication::argc ()&nbsp;&nbsp;<tt> [static]</tt></h3>
<p>Returns the argc reference passed to <a href="qtopiaserverapplication.html#startup">startup</a>().</p>
<h3 class="fn"><a name="argv"></a>char ** QtopiaServerApplication::argv ()&nbsp;&nbsp;<tt> [static]</tt></h3>
<p>Returns the argv reference passed to <a href="qtopiaserverapplication.html#startup">startup</a>().</p>
<h3 class="fn"><a name="installQWSEventFilter"></a>void QtopiaServerApplication::installQWSEventFilter ( <a href="qtopiaserverapplication-qwseventfilter.html">QWSEventFilter</a> * <i>filter</i> )</h3>
<p>Install the <i>filter</i> for QWS events. Installing an event filter is equivalent to deriving from <a href="qtopiaapplication.html">QtopiaApplication</a> directly and overriding the <a href="qapplication.html#qwsEventFilter">QtopiaApplication::qwsEventFilter</a>() method.</p>
<p>Multiple QWS event filters may be installed simultaneously. In this case, each event filter is queried sequentially in the order it was installed. If any filter filters the event, subsequent filters will not be called.</p>
<h3 class="fn"><a name="instance"></a>QtopiaServerApplication * QtopiaServerApplication::instance ()&nbsp;&nbsp;<tt> [static]</tt></h3>
<p>Return the instantiated <a href="qtopiaserverapplication.html">QtopiaServerApplication</a> instance. An instance of the class <b>must</b> have been constructed prior to calling this method.</p>
<h3 class="fn"><a name="qtopiaTask"></a><a href="qobject.html">QObject</a> * QtopiaServerApplication::qtopiaTask ( const <a href="qbytearray.html">QByteArray</a> &amp; <i>taskName</i>, bool <i>onlyRunning</i> = false )&nbsp;&nbsp;<tt> [static]</tt></h3>
<p>Return the task with name <i>taskName</i>. If <i>onlyRunning</i> is true, the task will be returned only if it has already been instantiated, otherwise it will be instantiated and returned.</p>
<h3 class="fn"><a name="removeQWSEventFilter"></a>void QtopiaServerApplication::removeQWSEventFilter ( <a href="qtopiaserverapplication-qwseventfilter.html">QWSEventFilter</a> * <i>filter</i> )</h3>
<p>Remove all instances of <i>filter</i> from the list of event filters. This method should be called when an event filter is destroyed. No automatic cleanup is performed.</p>
<h3 class="fn"><a name="shutdown"></a>void QtopiaServerApplication::shutdown ( <a href="qtopiaserverapplication.html#ShutdownType-enum">QtopiaServerApplication::ShutdownType</a> <i>type</i> )&nbsp;&nbsp;<tt> [slot]</tt></h3>
<p>Initiates a system shutdown of the specified <i>type</i>.</p>
<h3 class="fn"><a name="shutdownRequested"></a>void QtopiaServerApplication::shutdownRequested ()&nbsp;&nbsp;<tt> [signal]</tt></h3>
<p>Emitted whenever the user or an application requests that the system shutdown. A system shutdown is requested by sending a <tt>shutdown()</tt> message to the <tt>QPE/System</tt> QCop channel.</p>
<p>Generally a UI will be connected to the shutdownRequested() signal to ask the user what they want to do. This UI should then invoke the <a href="qtopiaserverapplication.html#shutdown">shutdown</a>() method to perform the appropriate action.</p>
<h3 class="fn"><a name="shutdownType"></a><a href="qtopiaserverapplication.html#ShutdownType-enum">ShutdownType</a> QtopiaServerApplication::shutdownType ()&nbsp;&nbsp;<tt> [static]</tt></h3>
<p>Returns the type of shutdown previously requested by calling <a href="qtopiaserverapplication.html#shutdown">shutdown</a>(), or <a href="qtopiaserverapplication.html#ShutdownType-enum">NoShutdown</a> if no shutdown has been requested.</p>
<h3 class="fn"><a name="startup"></a>bool QtopiaServerApplication::startup ( int &amp; <i>argc</i>, char ** <i>argv</i> )&nbsp;&nbsp;<tt> [static]</tt></h3>
<p>Launches server tasks. This method is used to start the Qtopia server and should never be called from other code. Returns true on success, false on failure.</p>
<p><i>argc</i> and <i>argv</i> should be the values passed to the main() function.</p>
<h3 class="fn"><a name="taskConfigFile"></a><a href="qstring.html">QString</a> QtopiaServerApplication::taskConfigFile ()&nbsp;&nbsp;<tt> [static]</tt></h3>
<p>Returns the task system's configuration file.</p>
<h3 class="fn"><a name="taskValueSpaceObject"></a><a href="qbytearray.html">QByteArray</a> QtopiaServerApplication::taskValueSpaceObject ( const <a href="qbytearray.html">QByteArray</a> &amp; <i>taskName</i> )&nbsp;&nbsp;<tt> [static]</tt></h3>
<p>Returns the path to an object in the value space that the task <i>taskName</i> can use to store status information. Will return a null byte array if the value space has not been initialized. This method is for task implementors only.</p>
<h3 class="fn"><a name="taskValueSpaceSetAttribute"></a>bool QtopiaServerApplication::taskValueSpaceSetAttribute ( const <a href="qbytearray.html">QByteArray</a> &amp; <i>taskName</i>, const <a href="qbytearray.html">QByteArray</a> &amp; <i>attribute</i>, const <a href="qvariant.html">QVariant</a> &amp; <i>value</i> )&nbsp;&nbsp;<tt> [static]</tt></h3>
<p>Sets a value space <i>attribute</i> for task <i>taskName</i> to <i>value</i>. This is a convenience method to simplify the usage of the value space for a task. For more complex usage, tasks should use the <a href="qtopiaserverapplication.html#taskValueSpaceObject">taskValueSpaceObject</a>() to request a path, and manually create a <a href="qvaluespaceobject.html">QValueSpaceObject</a> for their own use.</p>
<p>The value remains in the value space until the task is unloaded.</p>
<hr />
<h2>Related Non-Members</h2>
<h3 class="fn"><a name="qtopiaTask"></a>T * qtopiaTask ( bool <i>onlyActive</i> = false )</h3>
<p>Return a task instance that supports the T interface. If <i>onlyActive</i> is true the system will only select from tasks that are already active. Otherwise, if needed, the system will instantiate tasks to satisfy the request.</p>
<h3 class="fn"><a name="qtopiaTasks"></a><a href="qlist.html">QList</a>&lt;T *&gt; qtopiaTasks ( bool <i>onlyActive</i> = false )</h3>
<p>Returns all task instances that support the T interface. The instances are in the intended instantiation order. If <i>onlyActive</i> is true the system will only select from tasks that are already active. Otherwise, if needed, the system will instantiate tasks to satisfy the request.</p>
<h3 class="fn"><a name="qtopiaWidget"></a>T * qtopiaWidget ( <a href="qwidget.html">QWidget</a> * <i>parent</i>, <a href="qt.html#WFlags-typedef">Qt::WFlags</a> <i>flags</i> )</h3>
<p>Returns a concrete implementation of T, with the specified <i>parent</i> and <i>flags</i>. Concrete implementations are provided with the <a href="qtopiaserverapplication.html#QTOPIA_REPLACE_WIDGET">QTOPIA_REPLACE_WIDGET</a>(), <a href="qtopiaserverapplication.html#QTOPIA_REPLACE_WIDGET_WHEN">QTOPIA_REPLACE_WIDGET_WHEN</a>() and <a href="qtopiaserverapplication.html#QTOPIA_REPLACE_WIDGET_OVERRIDE">QTOPIA_REPLACE_WIDGET_OVERRIDE</a>() macros and selected as described in the <a href="qtopiaserverapplication.html#qtopia-server-widgets">Qtopia Server Widgets</a> overview.</p>
<hr />
<h2>Macro Documentation</h2>
<h3 class="fn"><a name="QTOPIA_DEMAND_TASK"></a>QTOPIA_DEMAND_TASK (  <i>TaskName</i>,  <i>Object</i> )</h3>
<p>Mark the <i>Object</i> as task <i>TaskName</i>. Only <a href="qobject.html">QObject</a> derived types may be tasks. QTOPIA_DEMAND_TASK() differs from <a href="qtopiaserverapplication.html#QTOPIA_TASK">QTOPIA_TASK</a>() in that tasks installed using this macro are automatically marked as &quot;demand&quot; tasks, unless specifically overridden in the <tt>Tasks.cfg</tt> file. That is, tasks installed like this will only be instantiated on request, not during server startup.</p>
<p>As the QTOPIA_DEMAND_TASK() macro defines symbols, it should appear only in the implementation file of a task, and not in the header file.</p>
<h3 class="fn"><a name="QTOPIA_REPLACE_WIDGET"></a>QTOPIA_REPLACE_WIDGET (  <i>AbstractWidget</i>,  <i>ConcreteWidget</i> )</h3>
<p>Mark <i>ConcreteWidget</i> as a replacement for <i>AbstractWidget</i>. While <i>AbstractWidget</i> does not actually have to be abstract, it is generally an interface that <i>ConcreteWidget</i> implements. This macro should appear as part of the definition of <i>ConcreteWidget</i>.</p>
<p>For example,</p>
<pre><span class="comment">    // wheelbrowserscreen.h</span>
    class WheelBrowserScreen : public QAbstractBrowserScreen
    {
        <span class="comment">// ...</span>
    };

<span class="comment">    // wheelbrowserscreen.cpp</span>
    QTOPIA_REPLACE_WIDGET(QAbstractBrowserScreen, WheelBrowserScreen);</pre>
<h3 class="fn"><a name="QTOPIA_REPLACE_WIDGET_OVERRIDE"></a>QTOPIA_REPLACE_WIDGET_OVERRIDE (  <i>AbstractWidget</i>,  <i>ConcreteWidget</i> )</h3>
<p>Set <i>ConcreteWidget</i> as the <b>static</b> replacement for <i>AbstractWidget</i>.</p>
<p>While as efficient as possible, use of the widget replacement system instead of explicitly instantiating concrete classes does introduce some indirection costs. For shipping software where this flexibility is not necessary, QTOPIA_REPLACE_WIDGET_OVERRIDE() can be used to force the selection of a specified <i>ConcreteWidget</i>. This eliminates the cost of the widget replacement system for the particular <i>AbstractWidget</i> by bypassing the replacement system. The macro should appear inline with the <i>AbstractWidget</i> declaration, and must have visibility of the <i>ConcreteWidget</i>'s declaration.</p>
<p>For example,</p>
<pre><span class="comment">    // qabstractbrowserscreen.h</span>
    class QAbstractBrowserScreen : public QWidget
    {
        <span class="comment">// ...</span>
    };

    #include &quot;wheelbrowserscreen.h&quot;
    QTOPIA_REPLACE_WIDGET_OVERRIDE(QAbstractBrowserScreen, WheelBrowserScreen);</pre>
<h3 class="fn"><a name="QTOPIA_REPLACE_WIDGET_WHEN"></a>QTOPIA_REPLACE_WIDGET_WHEN (  <i>AbstractWidget</i>,  <i>ConcreteWidget</i>,  <i>Feature</i> )</h3>
<p>Mark <i>ConcreteWidget</i> as a replacement for <i>AbstractWidget</i>. While <i>AbstractWidget</i> does not actually have to be abstract, it is generally an interface that <i>ConcreteWidget</i> implements. This macro should appear as part of the definition of <i>ConcreteWidget</i>.</p>
<p>Unless explicitly specified in the <tt>Trolltech/ServerWidgets</tt> file, a widget specified in this fashion if <i>Feature</i> is currently provided by Qtopia, as returned by the <a href="qtopiafeatures.html#hasFeature">QtopiaFeatures::hasFeature</a>() method.</p>
<p>For example,</p>
<pre><span class="comment">    // touchscreendialer.h</span>
    class TouchscreenDialerScreen : public QAbstractDialerScreen
    {
        <span class="comment">// ...</span>
    };

<span class="comment">    // touchscreendialer.cpp</span>
    QTOPIA_REPLACE_WIDGET_WHEN(QAbstractDialerScreen, TouchscreenDialerScreen, Touchscreen);</pre>
<h3 class="fn"><a name="QTOPIA_STATIC_TASK"></a>QTOPIA_STATIC_TASK (  <i>TaskName</i>,  <i>Function</i> )</h3>
<p>Install a functional task. A functional task is one that does not consist of an instantiable object, but is, instead, a simple function. Static tasks can obviously not provide interfaces.</p>
<p><i>TaskName</i> should be set to the name of the task, and <i>Function</i> to the static function to call to run the task.</p>
<p>As the QTOPIA_STATIC_TASK() macro defines symbols, it should appear only in the implementation file of a task, and not in the header file.</p>
<h3 class="fn"><a name="QTOPIA_TASK"></a>QTOPIA_TASK (  <i>TaskName</i>,  <i>Object</i> )</h3>
<p>Mark the <i>Object</i> as task <i>TaskName</i>. Only <a href="qobject.html">QObject</a> derived types may be tasks.</p>
<p>As the QTOPIA_TASK() macro defines symbols, it should appear only in the implementation file of a task, and not in the header file.</p>
<h3 class="fn"><a name="QTOPIA_TASK_INTERFACE-16"></a>QTOPIA_TASK_INTERFACE (  <i>ClassName</i> )</h3>
<p>This is an overloaded member function, provided for convenience.</p>
<p>Mark the specified <a href="qobject.html">QObject</a>-derived <i>ClassName</i> as a task interface. Any class interface that is required to support the qtopiaTask&lt;&gt;() or qtopiaTasks&lt;&gt;() request mechanism must be marked as a task interface.</p>
<p>The QTOPIA_TASK_INTERFACE() macro must be used in a header file, immediately following the interface's declaration.</p>
<p>If the interface is not a <a href="qobject.html">QObject</a> type, but rather a Qt Q_INTERFACE() style interface, use the <a href="qtopiaserverapplication.html#QTOPIA_TASK_QINTERFACE">QTOPIA_TASK_QINTERFACE</a>() macro instead.</p>
<h3 class="fn"><a name="QTOPIA_TASK_PROVIDES"></a>QTOPIA_TASK_PROVIDES (  <i>TaskName</i>,  <i>Interface</i> )</h3>
<p>Indicate that the task <i>TaskName</i> provides <i>Interface</i>, as previously declared by QTOPIA_TASK_INTERFACE. A task can provide more than one interface.</p>
<p>For a task to support the interface, it must either inherit directly from the interface or aggregate itself with an object that does during its construction. The <a href="qtopiaserverapplication.html#addAggregateObject">QtopiaServerApplication::addAggregateObject</a>() method can be used to aggregate a task with another object.</p>
<h3 class="fn"><a name="QTOPIA_TASK_QINTERFACE"></a>QTOPIA_TASK_QINTERFACE (  <i>InterfaceName</i> )</h3>
<p>Mark the specified <i>InterfaceName</i> as a task interface. Any class interface that is required to support the qtopiaTask&lt;&gt;() or qtopiaTasks&lt;&gt;() request mechanism must be marked as a task interface.</p>
<p>The QTOPIA_TASK_!INTERFACE() macro must be used in a header file, immediately following the interface's declaration.</p>
<p><i>InterfaceName</i> should be a Qt Q_INTERFACE style interface. If you want to use a <a href="qobject.html">QObject</a> derived type as an interface, use the QTOPIA_TASK_INTERFACE() macro instead.</p>
<p /><address><hr /><div align="center">
<table width="100%" cellspacing="0" border="0"><tr class="address">
<td width="30%">Copyright &copy; 2006 <a href="trolltech.html">Trolltech</a></td>
<td width="40%" align="center"><a href="trademarks.html">Trademarks</a></td>
<td width="30%" align="right"><div align="right">Qtopia 4.2.0</div></td>
</tr></table></div></address></body>
</html>
