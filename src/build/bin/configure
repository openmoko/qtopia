#!/usr/bin/perl
use strict;
use warnings;

use Cwd;
use POSIX qw(uname strftime);
use FileHandle;
use Sys::Hostname;
use File::stat;
use File::Find;
use File::Copy;
use File::Path;
use File::Glob;
use File::Basename;
use lib ( dirname($0) );
use Qtopia::Paths;
use Qtopia::Vars;
use Qtopia::Opt;
#perl2exe_include Qtopia::Opt::Getopt
use Qtopia::File;
use Hash::Ordered;
use Carp;
#perl2exe_include Carp::Heavy
$Carp::CarpLevel = 1;

#print "\$0: $0\n";
#print "CWD: ".getcwd()."\n";
#print "ARGV: ".join(" ::: ", @ARGV)."\n";
#exit -1;

use constant DEBUG => 0;

# Turn on autoflush (fast pipes)
$| = 1;

Qtopia::Paths::get_paths();

# Windows depot builds use the perl scripts directly rather than the compiled code
if ( $isWindows ) {
    check_script($0, "$depotpath/src/build/bin", $ARGV[0]);
}

# We need to figure out the Qt/Qtopia Core paths so that Qtopia::Paths::get_paths() can work for other scripts.
get_qtopiacore_paths();
# Set the MKSPECS variable so that config tests can work.
$ENV{MKSPECS} = "$qt_depot_path/mkspecs";

my $cols = $ENV{COLUMNS};
$cols = 80 unless ( $cols );
# Setup the terminal-width-dependant formats;
init_formats();

# Try to locate a pre-built Qt
$HOST_QT = undef;
$HOST_QT_BINS = undef;
$HOST_QT_LIBS = undef;
if ( !$isWindows ) {
    #get_host_qt();
}
if ( !defined($HOST_QT) ) {
    #print "Qt not detected. It will be built from source.\n";
    $HOST_QT = $DQTDIR;
    $HOST_QT_LIBS = fixpath("$DQTDIR/lib");
    $HOST_QT_BINS = fixpath("$DQTDIR/bin");
}
if ( $isWindows ) {
    # Use the qmake from the Qt we build for Qtopia Sync Agent
    $HOST_QMAKE = fixpath("$DQTDIR/bin/qmake");
    $TARGET_QMAKE = fixpath("$DQTDIR/bin/qmake");
} else {
    # Actually, we want to use the Qtopia Core qmake because we don't trust
    # a Qt (host) build someone else did (not to mention the version issues)
    $HOST_QMAKE = fixpath("$DQTDIR/bin/qmake");
    $TARGET_QMAKE = fixpath("$QTEDIR/bin/qmake");
}

# Write the path information to config.cache
Qtopia::Paths::write_config_cache();

# special early bail-out hook
if ( @ARGV && $ARGV[0] =~ /^--?init-cache$/ ) {
    exit 0;
}

# This is the engine to use as a backend to Qtopia::Opt.
my $engine = "Getopt";

# We need to check for the engine before we actually parse arguments...
if ( configopt("depot") ) {
    my @tmp = @ARGV;
    for ( @tmp ) {
        if ( /^--?opt-engine$/ ) {
            $engine = undef;
            next;
        }
        if ( !defined($engine) ) {
            $engine = $_;
        }
    }
}

# Check the license
my %licenseInfo = ();
{
    my @products;
    push (@products, "Phone") if ( configopt("phone") );
    push (@products, "Platform") if ( configopt("platform") );
    push (@products, "Media") if ( configopt("media") );
    push (@products, "PDA") if ( configopt("pda") );
    $licenseInfo{Product} = "Qtopia ".join("/", @products);
}
checkLicenseKey();

# Remove any license files left over
if ( !configopt("depot") ) {
    for my $location ( $qt_depot_path ) {
        for my $file ( glob("$location/LICENSE*"), glob("$location/.LICENSE*") ) {
            unlink $file;
        }
        my $source = "$depotpath/".$licenseInfo{LicenseFile};
        my $dest = "$location/".$licenseInfo{DestLicenseFile};
        if ( -f $dest ) {
            unlink $dest;
        }
        copy("$depotpath/".$licenseInfo{LicenseFile}, "$location/".$licenseInfo{DestLicenseFile});
        if ( $isWindows ) {
            # configure.exe doesn't know about LICENSE.Qtopia, just put in all of the .LICENSE* files
            copy("$depotpath/".$licenseInfo{LicenseFile}, "$location/.LICENSE");
            copy("$depotpath/".$licenseInfo{LicenseFile}, "$location/.LICENSE-US");
            copy("$depotpath/".$licenseInfo{LicenseFile}, "$location/.LICENSE-EVALUATION");
            copy("$depotpath/".$licenseInfo{LicenseFile}, "$location/.LICENSE-EVALUATION-US");
        }
    }
}

# Check for x86_64
my $x86_64 = 0;
{
    my ( $sysname, $nodename, $release, $version, $machine ) = uname();
    $x86_64 = ( $machine eq "x86_64" );
}

# The $build_ variables limit what you can build
my $build_desktop = configopt("desktop");
my $build_pda = configopt("pda");
my $build_phone = configopt("phone");
my $build_media = configopt("media");
my $build_platform = configopt("platform");
# For now, Windows and Mac OS X cannot build Qtopia
if ( $isWindows || $isMac ) {
    $build_platform = 0;
    $build_pda = 0;
    $build_phone = 0;
    $build_media = 0;
}

# Version stuff
my $qtopiaVersionStr = "0.0.0";
my $qtVersionStr = "0.0.0";
getVersions();

# Edition-specific defaults
my %dispsz = ( "phone" => "160-240",
               "pda" => "240-320",
               "media" => "240-320",
               "platform" => "160-800" );

# edition limiters
my $qtopia_visref = sub { $build_platform || $build_pda || $build_phone  || $build_media };
my $qtopia_autoref = sub { opt("edition") };
my $nonplatform_visref = sub { $build_pda || $build_phone || $build_media };
my $nonplatform_autoref = sub { opt("edition") && opt("edition") ne "platform" };
my $desktop_visref = sub { $build_desktop };
my $desktop_autoref = sub { opt("qtopiadesktop") };

# general build stuff
set_optvar( "help", +{
    "set" => [ "%", "Print help and usage information." ],
    "default" => 0,
    "engine" => "nogui",
});
set_optvar( "verbose", +{
    "set" => [ "%", "Print out extra information while configuring." ],
    "setfunc" => sub {
        # Turn off silent output
        opt("silent", "default") = 0;
        opt("verbose") = 1;
    },
    "value" => 0,
    "type" => "bool",
});
set_optvar( "silent", +{
    "set" => [ "%", "Hide compiler commandlines." ],
    "unset" => [ "no-%", "Show compiler commandlines." ],
    "default" => 0,
    "visible" => sub { !$isWindows },
    "config_pri" => "CONFIG+=silent",
    "type" => "bool",
});
set_optvar( "release", +{
    "set" => [ "%", "Create a release build." ],
    "unset" => [ "debug", "Create a debug build." ],
    "default" => 1,
    "showauto" => 1,
    "type" => "bool",
});
set_optvar( "separate_debug_info", +{
    "set" => [ "%", "Separate debug info into a .debug file." ],
    "unset" => [ "no-%", "Do not separate debug info into a .debug file." ],
    "default" => 0,
    "showauto" => 1,
    "type" => "bool",
});
set_optvar( "clean", +{
    "set" => [ "%", "Clean the build tree." ],
    "unset" => [ "no-%", "Do not clean the build tree." ],
    "default" => 1,
    "showauto" => 1,
    "no_keep" => 1,
    "type" => "bool",
});
set_optvar( "profile", +{
    "set" => [ "%", "Create a build with profiling." ],
    "unset" => [ "no-%", "Create a build without profiling." ],
    "default" => 0,
    "config_pri" => "CONFIG+=nostrip\n".
                    "QMAKE_CFLAGS+=-pg\n".
                    "QMAKE_CXXFLAGS+=-pg\n".
                    "QMAKE_LFLAGS+=-pg",
    "type" => "bool",
});
set_optvar( "reduce_exports", +{
    "set" => [ "%=s", "Reduce symbol exports in Qt/Qtopia Core/Qtopia (requires GCC 4)." ],
    "available" => [ qw(auto yes no) ],
    "default" => "auto",
});
set_optvar( "target_little_endian", +{
    "set" => [ "little-endian", "Force target build to use little endian (LSB first)." ],
    "unset" => [ "big-endian", "Force target build to use big endian (MSB first)." ],
});
add_separator();
set_optvar( "extraIncPaths", +{
    "set" => [ "I=s", "Add an explicit include path." ],
    "arg" => "dir",
    "type" => '@',
});
set_optvar( "extraLibPaths", +{
    "set" => [ "L=s", "Add Add an explicit library path." ],
    "arg" => "dir",
    "type" => '@',
});
set_optvar( "extraLibs", +{
    "set" => [ "l=s", "Add Add an explicit library." ],
    "arg" => "lib",
    "type" => '@',
});
set_optvar( "extraRPaths", +{
    "set" => [ "R=s", "Add an explicit dynamic library runtime search path." ],
    "arg" => "dir",
    "type" => '@',
});
set_optvar( "extraDefines", +{
    "set" => [ "D=s", "Add an explicit define to the build. Use -D FOO=bar to give it a value." ],
    "arg" => "def",
    "type" => '@',
});
add_note("The -I, -L, -l, -R and -D flags apply when building Qtopia and Qtopia Core. ".
         "If you need to pass these flags to Qt you should use -extra-qt-config 'flags'.");
set_optvar( "rpath", +{
    "set" => [ "%", "Set an automatic RPATH (so LD_LIBRARY_PATH is not required to run Qtopia).".
                    " Note that this requires QMAKE_RPATH to be set in your selected mkspec."],
    "unset" => [ "no-%", "Do not set an automatic RPATH." ],
    "default" => 1,
    "default_tested" => 1,
    "showauto" => 1,
    "visible" => sub { !$isWindows },
    "config_pri" => [ "!isEmpty(QTOPIA_RPATH):EMBEDDED_RPATH=\$\${QTOPIA_RPATH}%{prefix}",
                      "CONFIG+=enable_rpath" ],
});
add_separator();
set_optvar( "posix_locks", +{
    "set" => [ "%", "Use POSIX file locking." ],
    "unset" => [ "flock-locks", "Use flock() for file locking." ],
    "default" => 1,
    "config_pri" => "DEFINES+=QTOPIA_POSIX_LOCKS",
    "type" => "bool",
});
set_optvar( "strict_warnings", +{
    "set" => [ "%", "Use strict compiler warning flags." ],
    "unset" => [ "no-%", "Do not use strict compiler warning flags." ],
    "default" => 1,
    "default_tested" => 1,
    "config_pri" => [ "CONFIG+=enable_strict_flags",
                      "QTOPIA_STRICT_FLAGS=%{flags}" ],
    "type" => "bool",
    "flags" => "",
});
set_optvar( "error", +{
    "set" => [ "%", "Treat warnings as errors when compiling Qtopia (except for code in src/3rdparty)." ],
    "unset" => [ "no-%", "Do not treat warnings as errors." ],
    "default" => 0,
    "config_pri" => "CONFIG+=enable_werror",
    "type" => "bool",
});
add_separator();
set_optvar( "device", +{
    "set" => [ "%=s", "Build using a device profile." ],
    "arg" => "device",
    "visible" => $qtopia_visref,
    "autodep" => $qtopia_autoref,
    "available" => sub {
        my @avail;
        map { push(@avail, basename($_)) if ( -d $_ && basename($_) ne "default" ); } glob("$depotpath/devices/*");
        @avail;
    },
    "config_pri" => [ "device=%",
                      "CONFIG+=build_device",
                      "DEVICE_CONFIG_PATH=%{config_path}",
                      "DEFAULT_DEVICE_PATH=%{default_path}",
                      "DEVICE_BIN=%{device_bin}" ],
    "default_path" => "$depotpath/devices/default",
});
set_optvar( "using_device", +{
    "set" => [ "%=s", "hidden" ],
    "setfunc" => sub { opt("using_device") = $_[1]; opt("device") = $_[1]; },
    "visible" => $qtopia_visref,
    "autodep" => $qtopia_autoref,
});
add_note("Using -device may cause many defaults to change.");
add_separator();
set_optvar( "edition", +{
    "set" => [ "%=s", "Build Qtopia <edn> Edition." ],
    "arg" => "edn",
    "available" => [],
    "visible" => $qtopia_visref,
    "default" => 0,
    "showauto" => $qtopia_visref,
    "config_pri" => "QTOPIA_EDITION=%",
    "engine" => "mandatory",
});
set_optvar( "qtopiadesktop", +{
    "set" => [ "qtopiasyncagent", "Build Qtopia Sync Agent." ],
    "setaliases" => [ "qtopiadesktop" ],
    "visible" => $desktop_visref,
    "default" => 0,
    "showauto" => $desktop_visref,
    "config_pri" => "CONFIG+=build_qtopiadesktop",
    "type" => "bool",
});
add_separator();
set_optvar( "platform", +{
    "set" => [ "%=s",
        "The host platform that you are compiling on. ".
        "If not specified, configure will attempt to autodetect the host." ],
    "arg" => "host",
    "config_pri" => [ "PLATFORM=%", "PLATFORM_SDK=%{sdk}" ],
});
set_optvar( "xplatform", +{
    "set" => [ "%=s",
        "The target platform that you are compiling for. ".
        "If not specified, configure will attempt to autodetect the target based on the host." ],
    "arg" => "target",
    "visible" => $qtopia_visref,
    "autodep" => $qtopia_autoref,
    "config_pri" => [ "XPLATFORM=%", "XPLATFORM_SDK=%{sdk}" ],
});
set_optvar( "arch", +{
    "set" => [ "%=s", "The CPU family you are building for." ],
    "arg" => "architecture",
    "visible" => $qtopia_visref,
    "autodep" => $qtopia_autoref,
    "config_pri" => "arch=%",
});
set_optvar( "qws", +{
    "set" => [ "qws", "Use the Qtopia Core windowing system." ],
    "unset" => [ "x11", "Use the X11 windowing system." ],
    "setaliases" => [ "no-x11" ],
    "default" => 1,
    "visible" => sub { configopt("depot") && &$qtopia_visref() },
    "autodep" => $qtopia_autoref,
    "config_pri" => [ "(!)CONFIG+=x11", "CONFIG+=qws" ],
    "force_default" => 1,
});
# not visible for now because this doesn't come close to working
set_optvar( "keypad_navigation", +{
    "set" => [ "%", "Use QT_KEYPAD_NAVIGATION (required for phone edition)." ],
    "unset" => [ "no-%", "Do not use QT_KEYPAD_NAVIGATION (platform edition only)." ],
    "default" => 1,
    "visible" => 0,
    "autodep" => $qtopia_autoref,
    "force_default" => 1,
});
set_optvar( "defaultbuttons", +{
    "set" => [ "%=s", "Use <arg> (if you pass a complete path) or \$QTOPIA_DEPOT_PATH/etc/defaultbuttons-<arg>.conf (if you do not pass a complete path)." ],
    "arg" => "arg",
    "visible" => $qtopia_visref,
    "autodep" => $qtopia_autoref,
});
set_optvar( "sdkroot", +{
    "set" => [ "sdk=s", "Set the SDK location to <dir>. Note that you cannot run 'make sdk' with -sdk $QPEDIR." ],
    "arg" => "dir",
    "default" => fixpath("$QPEDIR"),
    "visible" => $qtopia_visref,
    "config_pri" => "QTOPIA_SDKROOT=%",
    "force_default" => 1,
});
set_optvar( "image", +{
    "set" => [ "%=s", "Set the Qtopia install location to <dir>." ],
    "arg" => "dir",
    "default" => fixpath("$QPEDIR/image"),
    "visible" => $qtopia_visref,
    "showauto" => sub { opt("edition") },
    "force_default" => 1,
});
set_optvar( "prefix", +{
    "set" => [ "%=s", "Set the runtime location of Qtopia to <dir>." ],
    "arg" => "dir",
    "default" => sub { opt_resolve("image") },
    "visible" => $qtopia_visref,
    "showauto" => sub { opt("edition") },
    "config_pri" => "QTOPIA_PREFIX=%",
    "force_default" => 1,
});
set_optvar( "dimage", +{
    "set" => [ "%=s", "Set the Qtopia Sync Agent install location to <dir>." ],
    "arg" => "dir",
    "default" => fixpath("$QPEDIR/dimage"),
    "visible" => $desktop_visref,
    "showauto" => sub { opt("qtopiadesktop") },
    "force_default" => 1,
});
set_optvar( "dprefix", +{
    "set" => [ "%=s", "Set the runtime location of Qtopia Sync Agent to <dir>." ],
    "arg" => "dir",
    "default" => sub { opt("dimage") },
    "visible" => $desktop_visref,
    "showauto" => sub { opt("qtopiadesktop") },
    "config_pri" => "QTOPIA_DPREFIX=%",
});
add_separator();
set_optvar( "qvfb", +{
    "set" => [ "%", "Enable QVfb support." ],
    "unset" => [ "no-%", "Disable QVfb support." ],
    "default" => sub { opt("xplatform")?0:1 },
    "visible" => $qtopia_visref,
    "autodep" => $qtopia_autoref,
    "config_pri" => [ "CONFIG+=enable_qvfb", "(!)DEFINES+=QT_NO_QWS_VFB" ],
});
set_optvar( "launch_method", +{
    "set" => [ "%=s", "Launch applications using the selected method. Please see the documentation for a description of each launch method." ],
    "arg" => "method",
    "available" => [ qw(normal quicklaunch) ],
    "default" => "quicklaunch",
    "visible" => $qtopia_visref,
    "autodep" => $qtopia_autoref,
    "showauto" => 1,
    "config_pri" => "LAUNCH_METHOD=%\n".
                    "equals(LAUNCH_METHOD,normal):CONFIG+=no_quicklaunch",
});
set_optvar( "setproc_method", +{
    "set" => [ "%=s", "Select the method used by quicklauncher to change the process title." ],
    "arg" => "method",
    "available" => [ "prctl", "argv0", "none" ],
    "default" => sub { opt("xplatform")?"prctl":"argv0" },
    "default_tested" => 1,
    "visible" => $qtopia_visref,
    "autodep" => $qtopia_autoref,
    "config_pri" => "QTOPIA_SETPROC_METHOD=%",
});
add_note("The prctl method uses the prctl() system call. This is available to Linux 2.6.9 and later.");
add_note("The argv0 method overwrites argv[0]. This is the traditional approach used by Qtopia. ".
         "It makes assumptions about the layout in memory or argv and char **environ.");
add_note("The none method is provided for systems that cannot use prctl() and break on the argv0 method.");
set_optvar( "force_quicklaunch", +{
    "set" => [ "%", "Force apps using QTOPIA_MAIN to be quicklaunched. This results in larger binaries but faster launching." ],
    "unset" => [ "no-%", "Do not force apps using QTOPIA_MAIN to be quicklaunched." ],
    "default" => 0,
    "visible" => $qtopia_visref,
    "autodep" => $qtopia_autoref,
    "config_pri" => "CONFIG+=force_quicklaunch",
});
set_optvar( "singleexec", +{
    "set" => [ "%",
        "Qtopia is compiled into a single binary that contains all the libraries, plug-ins and applications. ".
        "This implies -no-sxe." ],
    "unset" => [ "shared",
        "Qtopia is compiled as a collection of libraries, plug-ins and applications." ],
    "default" => 0,
    "visible" => $qtopia_visref,
    "autodep" => $qtopia_autoref,
    "config_pri" => "CONFIG+=enable_singleexec",
});
set_optvar( "languages", +{
    "set" => [ "%=s",
        "Resources (translations, dictionary files, icons) are updated/installed for the specified languages." ],
    "arg" => "lang,lang",
    "type" => "multi-value",
    "available" => sub {
        # Figure out what languages exist
        my @avail;
        map { push(@avail, basename($_)) if ( -f "$_/.directory" ); } glob("$depotpath/i18n/*");
        if ( !@avail ) {
            warn "WARNING: Could not detect any langauges... Assuming that en_US is available.\n";
            push(@avail, "en_US");
        }
        @avail;
    },
    "default" => sub {
        my $def;
        if ( configopt("depot") ) {
            # In the depot, default to en_US, en_SU (for RTL testing), and de
            $def = "en_US en_SU de";
        } else {
            $def = join(" ", Qtopia::Opt::_resolve_to_array(opt("languages", "available")));
        }
        $def;
    },
    "config_pri" => [ "LANGUAGES=%",
                      "AVAILABLE_LANGUAGES=%{available}" ],
});
set_optvar( "iconsize", +{
    "set" => [ "%=s", "Non-scalable icons are installed at the requested size. ".
                      "Can be a single number (for square icons) or WxH. ".
                      "Images will be scaled from one of the available sizes." ],
    "arg" => "size",
    "available" => sub {
        my @avail;
        map { if ( -d $_ ) { $_ = basename($_); s/x.*//; push(@avail, $_); } } glob("$depotpath/pics/icons/[0-9]*");
        @avail = sort { $a <=> $b } @avail;
        @avail;
    },
    "default" => sub { my @all = Qtopia::Opt::_resolve_to_array(opt("iconsize", "available")); return $all[$#all]; },
    "showauto" => 1,
    "config_pri" => "QTOPIA_ICON_SIZE=%",
});
set_optvar( "svg_format", +{
    "set" => [ "%=s", "Specify the format to convert SVG files to at install time. ".
                      "Converting to the pic (QPicture) format allows for faster image loading." ],
    "arg" => "ext",
    "available" => [ "svg", "pic" ],
    "default" => "pic",
});
set_optvar( "image_extension_order", +{
    "set" => [ "%=s", "An image may exist with multiple extensions but only 1 of these will be installed. ".
                      "This list determines the priority of extensions. ".
                      "An image with multiple extensions, none of which appear in this list will have the first ".
                      "(as determined by perl's glob(\"\$file.*\");) extension chosen." ],
    "arg" => "ext,ext",
    "type" => "multi-value",
    "available" => [ "png", "gif", "xpm" ],
    "default" => sub { join(" ", Qtopia::Opt::_resolve_to_array(opt("image_extension_order", "available"))); },
    "showauto" => 1,
    "config_pri" => "IMAGE_EXTENSION_ORDER=%",
});
add_note("You cannot force extensions other than .svg to have the highest priority with -image-extension-order.");
set_optvar( "displaysize", +{
    "set" => [ "%=s",
        "Resources (images) suitable for the requested size are installed. ".
        "Size can be a single width and height or a minimum and maximum width and height." ],
    "arg" => "WxH[-WxH]",
    "default" => sub { $dispsz{opt_resolve("edition")} },
    "visible" => $qtopia_visref,
    "autodep" => $qtopia_autoref,
    "showauto" => $qtopia_visref,
    "config_pri" => "QTOPIA_DISP_SIZES=%{codes}\n".
                    "QTOPIA_DISP_WIDTH=%{width}\n".
                    "QTOPIA_DISP_HEIGHT=%{height}",
});
add_separator();
set_optvar( "auto_i18n_fonts", +{
    "set" => [ "%", "Allow automatic installation of i18n fonts based on the configured language." ],
    "unset" => [ "no-%", "Do not automatically install i18n fonts." ],
    "default" => 1,
    "visible" => $qtopia_visref,
    "autodep" => $qtopia_autoref,
    "showauto" => $qtopia_visref,
});
set_optvar( "font", +{
    "set" => [ "%=s", "Install font <fontspec> (defined as \"family:sizes:styles\" OR ".
                      "a truetype font file (eg. qtopiadejavu.ttf). ".
                      "Pass -font multiple times to install multiple fonts." ],
    "arg" => "fontspec",
    "type" => '@',
    "default" => ["dejavu_sans_condensed:*:*"],
    "config_pri" => "QTOPIA_FONTS=%{files}",
    "visible" => $qtopia_visref,
    "autodep" => $qtopia_autoref,
    "showauto" => $qtopia_visref,
});
add_note("family is the name of the font.");
add_note("sizes is a list or range. For example, '80,100,120', '80-120', '*'. ".
         "Note that .qpf2 files are named with pixel height so 8-12 is more likely.");
add_note("styles is a list of weights. ".
         "For example: '50,50i,80', '*'.");
add_note("Unless you have changed the Qtopia Core configuration, fonts must be truetype, .qpf or .qpf2 files.".
         "format and are searched for in $qt_depot_path/dist/embedded/lib/fonts ".
         "and $depotpath/dist/fonts. ".
         "One .qpf/.qpf2 file is installed for each combination of family, size, style and rotation. ".
         "Note that fonts may not be available in all styles and sizes.");
add_separator();
set_optvar( "make", +{
    "set" => [ "%=s", "Use <makecmd> when building." ],
    "arg" => "makecmd",
    "default" => ($isWindows?"nmake /nologo":"make"),
});
set_optvar( "extraBuildPaths", +{
    "set" => [ "build=s",
        "Add directory <dir> to the Qtopia build system. ".
        "For example, -build /path/to/myapp will add /path/to/myapp to ".
        "the build system." ],
    "arg" => "dir",
    "type" => '@',
});
add_separator();
set_optvar( "qdoc", +{
    "set" => [ "run-%", "Automatically build class documentation to provide documentation errors and warnings at compile time." ],
    "unset" => [ "no-run-%", "Do not automatically build class documentation." ],
    "default" => 0,
    "visible" => sub { configopt("depot") },
    "config_pri" => "CONFIG+=qdoc",
});
add_separator();
set_optvar( "ssl", +{
    "set" => [ "%", "Enable the use of OpenSSL. This lets qtmail connect over SSL and use SMTP authentication. It also allows communication with Google services." ],
    "setaliases" => [ "qtmail-ssl" ],
    "unset" => [ "no-%", "Disable the use of OpenSSL." ],
    "unsetaliases" => [ "no-qtmail-ssl" ],
    "default" => 1,
    "default_tested" => 1,
    "visible" => $qtopia_visref,
    "autodep" => $qtopia_autoref,
    "config_pri" => "CONFIG+=enable_ssl",
});
set_optvar( "ssl_ciphers", +{
    "set" => [ "%=s", "Use additional ciphers when building OpenSSL. WARNING: These ciphers are patented and should only be enabled if a suitable licensing agreement is in place." ],
    "arg" => "cipher,cipher",
    "type" => "multi-value",
    "available" => [ qw(dsa idea mdc2 rc5) ],
    "default" => "",
    "visible" => $qtopia_visref,
    "autodep" => $qtopia_autoref,
    "config_pri" => [ "SSL_CIPHERS=%",
                      "SSL_DISABLED_CIPHERS=%{available}\nSSL_DISABLED_CIPHERS-=\$\$SSL_CIPHERS" ],
    "qtopiaconfig" => sub {
        my @ret;
        my %disabled;
        map { $disabled{$_}++ } Qtopia::Opt::_resolve_to_array(opt("ssl_ciphers", "available"));
        map { $disabled{$_}-- } split(/ /, opt("ssl_ciphers"));
        for ( keys %disabled ) {
            if ( $disabled{$_} ) {
                push(@ret, "#define OPENSSL_NO_".uc($_));
            }
        }
        @ret;
    },
    "value" => "",
});
set_optvar( "sxe", +{
    "set" => [ "%", "Enable the Safe Execution Environment so that native third party applications can run safely." ],
    "unset" => [ "no-%", "Disable the Safe Execution Environment." ],
    "default" => 1,
    "visible" => $qtopia_visref,
    "autodep" => $qtopia_autoref,
    "silentignore" => [ "no-sxe" ],
    "config_pri" => "CONFIG+=enable_sxe",
});
set_optvar( "sxe_discovery", +{
    "set" => [ "%", "Turn on support for SXE discovery mode so that new policy rules can be tested. ".
                    "To utilise SXE discovery mode you must set the SXE_DISCOVERY_MODE environment variable to 1. ".
                    "WARNING: This option creates a security hole and should only be used when creating new policy rules." ],
    "unset" => [ "no-%", "Turn off support for SXE discovery mode." ],
    # Default is on when building from the depot (as a convenience thing for development)
    "default" => configopt("depot")?1:0,
    "visible" => $qtopia_visref,
    "autodep" => $qtopia_autoref,
});
set_optvar( "sxe_soft_kill", +{
    "set" => [ "%", "Turn on support for SXE soft kill so that processes can be sent a signal other than 9 when being killed. ".
                    "To utilise SXE soft kill you must set the SXE_SOFT_KILL environment variable to the number of the signal to send. ".
                    "To see the available signals run kill -l. ".
                    "WARNING: This option creates a security hole and should only be used when debugging SXE violations." ],
    "unset" => [ "no-%", "Turn off support for SXE soft kill." ],
    # Default is on when building from the depot (as a convenience thing for development)
    "default" => configopt("depot")?1:0,
    "visible" => $qtopia_visref,
    "autodep" => $qtopia_autoref,
    "config_pri" => "DEFINES+=SXE_SOFT_KILL",
});
set_optvar( "bluetooth", +{
    "set" => [ "%", "Enable Bluetooth." ],
    "setfunc" => sub { opt("bluetooth") = 1; opt("dbus") = 1; },
    "unset" => [ "no-%", "Disable Bluetooth." ],
    "default" => 1,
    "default_tested" => 1,
    "visible" => $qtopia_visref,
    "autodep" => $qtopia_autoref,
    "config_pri" => "CONFIG+=enable_bluetooth",
});
set_optvar( "infrared", +{
    "set" => [ "%", "Enable Infrared." ],
    "unset" => [ "no-%", "Disable Infrared." ],
    "default" => 1,
    "visible" => $qtopia_visref,
    "autodep" => $qtopia_autoref,
    "config_pri" => "CONFIG+=enable_infrared",
});
set_optvar( "dbus", +{
    "set" => [ "%", "Enable DBUS support." ],
    "unset" => [ "no-%", "Disable DBUS support." ],
    "default" => 1,
    "default_tested" => 1,
    "visible" => $qtopia_visref,
    "autodep" => $qtopia_autoref,
    "config_pri" => [ "CONFIG+=enable_dbus",
                      "DBUS_CFLAGS=%{cflags}",
                      "DBUS_LIBS=%{libs}" ],
});
set_optvar( "dbuspath", +{
    "set" => [ "%=s", "hidden" ],
    "setfunc" => sub { opt("dbuspath") = $_[1]; opt("dbus") = 1; },
    "setfunc" => sub {
        warn "WARNING: -dbuspath is deprecated. Please use -dbus instead.\n".
             "         Note that pkg-config is now used to locate dbus.\n";
        opt("dbus") = 1;
    },
});
set_optvar( "drm", +{
    "set" => [ "%", "Enable support for DRM (Using the Beep Science DRM Agent v2.4)." ],
    "unset" => [ "no-%", "Disable support for DRM." ],
    "default" => 1,
    "default_tested" => 1,
    "visible" => $qtopia_visref,
    "autodep" => $qtopia_autoref,
    "silentignore" => [ "no-drm" ],
    "config_pri" => "CONFIG+=drmagent",
});
set_optvar( "sound_system", +{
    "set" => [ "%=s", "Select the sound system to use. ".
                      "You might need to force OSS if your toolchain has ALSA but your kernel does not." ],
    "arg" => "ss",
    "available" => ["alsa", "oss"],
    "default" => "alsa",
    "default_tested" => 1,
    "visible" => $qtopia_visref,
    "autodep" => $qtopia_autoref,
    "config_pri" => "QTOPIA_SOUND_SYSTEM=%",
    "showauto" => 1,
});
set_optvar( "v4l2", +{
    "set" => [ "%", "Enable support for V4L2 (Video for Linux version 2)." ],
    "unset" => [ "no-%", "Disable support for V4L2. Video for Linux version 1 will be used instead. ".
                         "You might need to force this if your toolchain has V4L2 but your kernel does not." ],
    "default" => 1,
    "default_tested" => 1,
    "visible" => $qtopia_visref,
    "autodep" => $qtopia_autoref,
    "config_pri" => "DEFINES+=QTOPIA_HAVE_V4L2",
});
add_separator();
set_optvar( "telephony", +{
    "set" => [ "%", "Enable Telephony components (UI, Modem, VoIP)." ],
    "unset" => [ "no-%", "Disable Telephony components." ],
    "default" => 1,
    "visible" => $qtopia_visref,
    "autodep" => $qtopia_autoref,
    "config_pri" => [ "CONFIG+=enable_telephony",
                      "DEFINES+=QTOPIA_TELEPHONY" ],
});
set_optvar( "modem", +{
    "set" => [ "%", "Enable Modem communication (requires Telephony)." ],
    "unset" => [ "no-%", "Disable Modem communication." ],
    "default" => 1,
    "visible" => $qtopia_visref,
    "autodep" => $qtopia_autoref,
    "silentignore" => [ "no-modem" ],
    "config_pri" => "CONFIG+=enable_modem enable_cell",
});
set_optvar( "phonevendors", +{
    "set" => [ "%=s", "Build and install phonevendor plugins (reqires Modem)." ],
    "arg" => "plugin,plugin",
    "type" => "multi-value",
    "available_device" => sub {
        # Figure out what phonevendor plugins exist
        my @avail;
        if ( opt("device", "config_path") ) {
            map { push(@avail, basename($_)) if ( -f "$_/".basename($_).".pro" ); } glob(opt("device", "config_path")."/src/plugins/phonevendors/*");
        }
        @avail;
    },
    "available_depot" => sub {
        # Figure out what phonevendor plugins exist
        my @avail;
        map { push(@avail, basename($_)) if ( -f "$_/".basename($_).".pro" ); } glob("$depotpath/src/plugins/phonevendors/*");
        @avail;
    },
    "available" => sub {
        # Figure out what phonevendor plugins exist
        my @avail;
        push(@avail, Qtopia::Opt::_resolve_to_array(opt("phonevendors", "available_depot")));
        push(@avail, Qtopia::Opt::_resolve_to_array(opt("phonevendors", "available_device")));
        @avail;
    },
    "default" => sub {
        my $ret;
        if ( opt("device", "config_path") || !configopt("depot") ) {
            $ret = join(" ", Qtopia::Opt::_resolve_to_array(opt("phonevendors", "available_device")));
        } elsif ( configopt("depot") ) {
            $ret = join(" ", Qtopia::Opt::_resolve_to_array(opt("phonevendors", "available")));
        }
        $ret;
    },
    "config_pri" => "PHONEVENDORS=%",
    "visible" => $qtopia_visref,
    "autodep" => $qtopia_autoref,
});
set_optvar( "multiplexers", +{
    "set" => [ "%=s", "Build and install multiplexer plugins (reqires Modem)." ],
    "arg" => "plugin,plugin",
    "type" => "multi-value",
    "available_device" => sub {
        # Figure out what multiplexer plugins exist
        my @avail;
        if ( opt("device", "config_path") ) {
            map { push(@avail, basename($_)) if ( -f "$_/".basename($_).".pro" ); } glob(opt("device", "config_path")."/src/plugins/multiplexers/*");
        }
        @avail;
    },
    "available_depot" => sub {
        # Figure out what multiplexer plugins exist
        my @avail;
        map { push(@avail, basename($_)) if ( -f "$_/".basename($_).".pro" ); } glob("$depotpath/src/plugins/multiplexers/*");
        @avail;
    },
    "available" => sub {
        # Figure out what multiplexer plugins exist
        my @avail;
        push(@avail, Qtopia::Opt::_resolve_to_array(opt("multiplexers", "available_depot")));
        push(@avail, Qtopia::Opt::_resolve_to_array(opt("multiplexers", "available_device")));
        @avail;
    },
    "default" => sub {
        my $ret;
        if ( opt("device", "config_path") || !configopt("depot") ) {
            $ret = join(" ", Qtopia::Opt::_resolve_to_array(opt("multiplexers", "available_device")));
        } elsif ( configopt("depot") ) {
            $ret = join(" ", Qtopia::Opt::_resolve_to_array(opt("multiplexers", "available")));
        }
        $ret;
    },
    "config_pri" => "MULTIPLEXERS=%",
    "visible" => $qtopia_visref,
    "autodep" => $qtopia_autoref,
});
set_optvar( "voip", +{
    "set" => [ "%", "Enable VoIP (Voice over IP) communication. Note that the reference ".
                    "SIP agent will not build in singleexec mode. (requires Telephony)" ],
    "setaliases" => [ "enable-voip" ],
    "unset" => [ "no-%", "Disable VoIP communication." ],
    "unsetaliases" => [ "disable-voip" ],
    "default" => configopt("depot"),
    "visible" => $qtopia_visref,
    "autodep" => $qtopia_autoref,
    "silentignore" => [ "no-voip" ],
    "config_pri" => "CONFIG+=enable_voip",
});
add_note("Modem and VoIP communication are not exclusive or mandatory. You can enable one, both or none. ".
         "You must enable telephony to enable Modem or VoIP.");
add_separator();
set_optvar( "vpn", +{
    "set" => [ "%", "Enable VPN (Virtual Private Network) support." ],
    "unset" => [ "no-%", "Disable VPN." ],
    "default" => configopt("depot"),
    "default_tested" => 1,
    "visible" => $qtopia_visref,
    "autodep" => $qtopia_autoref,
    "config_pri" => "CONFIG+=enable_vpn",
});

add_separator();
set_optvar( "qtopiamedia", +{
    "set" => [ "%", "Enable the Qtopia Media API." ],
    "setaliases" => [ "mediaserver" ],
    "unset" => [ "no-%", "Disable the Qtopia Media API." ],
    "unsetaliases" => [ "no-mediaserver" ],
    "default" => 1,
    "default_tested" => 1,
    "visible" => $qtopia_visref,
    "autodep" => $qtopia_autoref,
    "showauto" => 1,
    "config_pri" => [ "CONFIG+=enable_qtopiamedia\n".
                      "DEFINES+=MEDIA_SERVER" ],
});
set_optvar( "mediaengines", +{
    "set" => [ "%=s", "Select the audio/video engines to use with the Qtopia Media API.".
                       "The order of the engines is significant" ],
    "arg" => "engine,engine",
    "type" => "multi-value",
    "available_device" => sub {
        my @avail;
        if ( opt("device", "config_path") ) {
            map { push(@avail, basename($_)) if ( -f "$_/".basename($_).".pro" ); } glob(opt("device", "config_path")."/src/plugins/mediaengines/*");
        }
        @avail;
    },
    "available_depot" => sub {
        my @avail;
        map { push(@avail, basename($_)) if ( -f "$_/".basename($_).".pro" ); } glob("$depotpath/src/plugins/mediaengines/*");
        @avail;
    },
    "available" => sub {
        my @avail;
        push(@avail, Qtopia::Opt::_resolve_to_array(opt("mediaengines", "available_depot")));
        push(@avail, Qtopia::Opt::_resolve_to_array(opt("mediaengines", "available_device")));
        @avail;
    },
    "default" => sub {
        my $ret;
        my @avail_device = Qtopia::Opt::_resolve_to_array(opt("mediaengines", "available_device"));
        if ( @avail_device ) {
            $ret = join(" ", @avail_device); # default to whatever is in the device profile
        } else {
            my @avail = Qtopia::Opt::_resolve_to_array(opt("mediaengines", "available"));
            for ( @avail ) {
                if ( $_ eq "cruxus" ) {
                    $ret = "cruxus"; # default to cruxus unless helix is available
                }
                if ( $_ eq "helix" ) {
                    $ret = "helix"; # default to helix, if it's available
                    last;
                }
            }
        }
        $ret;
    },
    "default_tested" => 1,
    "visible" => $qtopia_visref,
    "autodep" => $qtopia_autoref,
    "config_pri" => "QTOPIAMEDIA_ENGINES=%",
});

add_separator();
my $helix_depot_path = "$depotpath/src/3rdparty/libraries/helix/src";
my $helix_build_path = "$QPEDIR/src/3rdparty/libraries/helix/helixbuild";
my $helix_visref = sub { &$nonplatform_visref() && -d $helix_depot_path };
my $helix_autoref = sub { &$nonplatform_autoref() && -d $helix_depot_path };
# Disable the helix mediaengine if the helix options are not visible
if ( !&$helix_visref() ) {
    my @tmp = Qtopia::Opt::_resolve_to_array(opt("mediaengines", "available"));
    my @avail;
    for ( @tmp ) {
        if ( $_ ne "helix" ) {
            push(@avail, $_);
        }
    }
    opt("mediaengines", "available") = sub { @avail };
}
set_optvar( "helix", +{
    "set" => [ "helix", "hidden" ],
    "unset" => [ "no-helix", "hidden" ],
    "setfunc" => sub {
        warn "WARNING: -helix is deprecated. Please use -qtopiamedia -mediaengines helix instead.\n";
        opt("qtopiamedia") = 1;
        opt("mediaengines") = "helix";
    },
    "unsetfunc" => sub {
        warn "WARNING: -no-helix is deprecated. Please use -no-qtopiamedia instead.\n";
        opt("qtopiamedia") = 0;
    },
    "visible" => $helix_visref,
    "silentignore" => [ "no-helix" ],
    "die_if_not_auto" => "-mediaengines helix",
    "value" => 0,
    "config_pri" => [ "HELIX_CONFIG=%{atomic} %{alsa}" ],
});
set_optvar( "helix_system_id", +{
    "set" => [ "%=s", "Use SYSTEM_ID when building Helix."],
    "arg" => "SYSTEM_ID",
    "available" => "See ".fixpath("$helix_depot_path/build/umakecf")." or ".
                   fixpath("$depotpath/src/3rdparty/libraries/helix/trolltech/src/build/umakecf").
                   " for suitable values.",
    "visible" => $helix_visref,
    "autodep" => $helix_autoref,
    "silentignore" => [ "helix-system-id=s" ],
    "config_pri" => "HELIX_SYSTEM_ID=%",
});

add_separator();
set_optvar( "libamr", +{
    "set" => [ "%", "Enable libamr." ],
    "unset" => [ "no-%", "Disable libamr." ],
    "setaliases" => [ "with-libamr" ],
    "unsetaliases" => [ "without-libamr" ],
    "visible" => $nonplatform_visref,
    "autodep" => $nonplatform_autoref,
    "silentignore" => [ "no-libamr" ],
    "default" => 1,
    "config_pri" => "CONFIG+=build_libamr",
});
set_optvar( "readline", +{
    "set" => [ "%", "Enable GNU readline for vsexplorer." ],
    "unset" => [ "no-%", "Disable GNU readline." ],
    "default" => configopt("depot"),
    "default_tested" => 1,
    "visible" => sub { configopt("depot") && ($build_platform || $build_pda || $build_phone  || $build_media) },
    "autodep" => $qtopia_autoref,
    "silentignore" => [ "no-readline" ],
    "config_pri" => "CONFIG+=enable_readline",
});
set_optvar( "test", +{
    "set" => [ "%", "Enable the test framework which provides automated GUI testing functionality. ".
                    "WARNING: This option creates a security hole and should only be used when automated ".
                    "testing is going to be used." ],
    "unset" => [ "no-%", "Disable the test framework." ],
    "visible" => $qtopia_visref,
    "autodep" => $qtopia_autoref,
    "default" => configopt("depot"),
    "config_pri" => "CONFIG+=qtopiatest",
});
set_optvar( "samples", +{
    "set" => [ "enable-%", "Enable server widget samples." ],
    "unset" => [ "no-%", "Disable server widget samples." ],
    "default" => 1,
    "visible" => $qtopia_visref,
    "autodep" => $qtopia_visref,
    "silentignore" => [ "no-samples" ],
    "config_pri" => "CONFIG+=enable_samples",
});
set_optvar( "examples", +{
    "set" => [ "build-%", "Build the example code." ],
    "unset" => [ "no-%", "Do not build the example code." ],
    "default" => configopt("depot"),
    "visible" => $qtopia_visref,
    "autodep" => $qtopia_visref,
    "silentignore" => [ "no-examples" ],
    "config_pri" => "CONFIG+=build_examples",
});

# Qt passthrough options
add_separator();
set_optvar( "gif", +{
    "set" => [ "%", "Enable GIF support." ],
    "unset" => [ "no-%", "Disable GIF support." ],
    "setaliases" => [ "with-gif" ],
    "unsetaliases" => [ "without-gif" ],
    "default" => 1,
});
set_optvar( "glib", +{
    "set" => [ "%", "Enable Glib support in Qtopia Core."],
    "unset" => ["no-%", "Disable Glib support in Qtopia Core." ],
    "default" => 0,
    "visible" => $qtopia_visref,
    "autodep" => $qtopia_autoref,
});
set_optvar( "qte_config", +{
    "set" => [ "qtopiacore-config=s", "hidden" ],
    "setaliases" => [ "qte-config=s", "target-qt-config=s" ],
});
set_optvar( "extra_qte_config", +{
    "set" => [ "extra-qtopiacore-config=s", "Add something to the Qtopia Core configure commandline." ],
    "setaliases" => [ "extra_qte_config=s", "extra-target-qt-config=s" ],
    "arg" => '"-option arg"',
    "type" => '@',
});
set_optvar( "dqt_config", +{
    "set" => [ "qt-config=s", "hidden" ],
    "setaliases" => [ "dqt-config=s", "host-qt-config=s" ],
});
set_optvar( "extra_dqt_config", +{
    "set" => [ "extra-qt-config=s", "Add something to the Qt configure commandline." ],
    "setaliases" => [ "extra-dqt-config=s", "extra-host-qt-config=s" ],
    "type" => '@',
    "arg" => '"-option arg"',
});

# These are the "hidden" options.
set_optvar( "save_options", +{
    "set" => [ "%", "hidden" ],
    "unset" => [ "no-%", "hidden" ],
    "value" => 1,
    "no_keep" => 1,
});
set_optvar( "mkconf", +{
    "set" => [ "%=s", "hidden" ],
    "type" => '@',
    "no_keep" => 1,
});
set_optvar( "using_mkconf", +{
    "set" => [ "%", "hidden" ],
    "no_keep" => 1,
});
set_optvar( "config", +{
    "set" => [ "%=s", "hidden" ],
    "type" => '@',
});
set_optvar( "skip_qt_configure", +{
    "set" => [ "%", "hidden" ],
    "unset" => [ "no-%", "hidden" ],
});
set_optvar( "skip_qt", +{
    "set" => [ "%", "hidden" ],
    "unset" => [ "no-%", "hidden" ],
    "setfunc" => sub { opt("skip_dqt") = 1; opt("skip_qte") = 1; },
    "unsetfunc" => sub { opt("skip_dqt") = 0; opt("skip_qte") = 0; },
});
set_optvar( "skip_dqt", +{
    "set" => [ "%", "hidden" ],
    "unset" => [ "no-%", "hidden" ],
    "config_pri" => "(!)CONFIG+=build_dqt",
});
set_optvar( "skip_qte", +{
    "set" => [ "%", "hidden" ],
    "unset" => [ "no-%", "hidden" ],
    "config_pri" => "(!)CONFIG+=build_qte",
});
set_optvar( "qmake", +{
    "set" => [ "%", "hidden" ],
    "unset" => [ "no-%", "hidden" ],
    "value" => !$isWindows,
    "behaviors" => "",
    "config_pri" => "QMAKE_BEHAVIORS=%{behaviors}",
});
set_optvar( "qmake_debug", +{
    "set" => [ "%", "hidden" ],
});
set_optvar( "confirm_license", +{
    "set" => [ "%", "hidden" ],
    "unset" => [ "no-%", "hidden" ],
    "no_keep" => 1,
});
set_optvar( "config_defaults", +{
    "set" => [ "%=s", "hidden" ],
});
set_optvar( "quick", +{
    "set" => [ "%", "hidden" ],
    "unset" => [ "no-%", "hidden" ],
    "setfunc" => sub { opt("skip_qt_configure") = 1; opt("clean") = 0; },
    "no_keep" => 1,
});
set_optvar( "opt_engine", +{
    "set" => [ "%", "hidden" ],
    "value" => 0,
});
set_optvar( "configonly", +{
    "set" => [ "%", "hidden" ],
    "value" => 0,
    "setfunc" => sub {
        opt("configonly") = 1;
        opt("skip_dqt") = 1;
        opt("skip_qte") = 1;
        opt("qmake") = 0;
        opt("clean") = 0;
    },
    "no_keep" => 1,
});
set_optvar( "eval", +{
    "set" => [ "%=s", "hidden" ],
    "type" => '@',
    "setfunc" => sub { eval $_[1]; },
});

# compatibility option for the QA team
set_optvar( "quicklaunch", +{
    "set" => [ "%", "hidden" ],
    "unset" => [ "no-%", "hidden" ],
    "setfunc" => sub {
        warn "WARNING: -quicklaunch is deprecated. Please use -launch-method quicklaunch instead.\n";
        opt("launch_method") = "quicklaunch";
    },
    "unsetfunc" => sub {
        warn "WARNING: -no-quicklaunch is deprecated. Please use -launch-method normal instead.\n";
        opt("launch_method") = "normal";
    },
});

# New (experimental) features. These options should go away as soon as the features are stable.
set_optvar( "greenphone_effects", +{
    "set" => [ "%", "Enable the -effects build for the Greenphone." ],
    "config_pri" => [ "CONFIG+=enable_greenphone_effects", "DEFINES+=GREENPHONE_EFFECTS" ],
    "visible" => sub { configopt("depot") && &$qtopia_visref() },
});

# placeholders. These aren't switches but the values get propagated via config.cache
set_optvar( "compiler", +{
    "role" => "placeholder",
    "config_pri" => [ "QTOPIA_HOST_ENDIAN=%{host_endian}",
                      "QTOPIA_TARGET_ENDIAN=%{target_endian}" ],
});
set_optvar( "version", +{
    "role" => "placeholder",
    "qtopia" => $qtopiaVersionStr,
    "qt" => $qtVersionStr,
});
set_optvar( "storage_conf_file", +{
    "role" => "placeholder",
    "config_pri" => "STORAGE_CONF_FILE=%",
});
set_optvar( "hardware_conf_file", +{
    "role" => "placeholder",
    "config_pri" => "HARDWARE_CONF_FILE=%",
});
set_optvar( "page_size", +{
    "role" => "placeholder",
    "config_pri" => [ "QTOPIA_PAGE_SIZE=%{page_size}",
                      "QTOPIA_PAGE_MASK=%{page_mask}" ],
});
set_optvar( "builder", +{
    "role" => "placeholder",
    "value" => (getlogin() || getpwuid($<) || "unknown").'@'.(hostname() || "unknown"),
    "config_pri" => "BUILDER=%",
});
set_optvar( "libqtopiaphone", +{
    "role" => "placeholder",
    "config_pri" => [ "QTOPIA_LIBQTOPIAPHONE=%",
                      "QTOPIA_LIBQTOPIAPHONE_VERSION=%{version}",
                      "QTOPIA_LIBQTOPIAPHONE_MAJOR_VERSION=%{major_version}",
                      "QTOPIA_LIBQTOPIAPHONE_MINOR_VERSION=%{minor_version}" ],
});
set_optvar( "libqtopiaphonemodem", +{
    "role" => "placeholder",
    "config_pri" => [ "QTOPIA_LIBQTOPIAPHONEMODEM=%",
                      "QTOPIA_LIBQTOPIAPHONEMODEM_VERSION=%{version}",
                      "QTOPIA_LIBQTOPIAPHONEMODEM_MAJOR_VERSION=%{major_version}",
                      "QTOPIA_LIBQTOPIAPHONEMODEM_MINOR_VERSION=%{minor_version}" ],
});
set_optvar( "qpe_config", +{
    "role" => "placeholder",
});

# If we are a non-depot or desktop-only package, turn on Qtopia Sync Agent
#if ( !configopt("depot") || ($build_desktop && !$build_platform && !$build_pda && !$build_phone) ) {
if ( $build_desktop && !$build_platform && !$build_pda && !$build_phone && !$build_media )  {
    opt("qtopiadesktop", "default") = 1;
}

# Setup available editions and the default edition
if ( $build_platform ) {
    my $availref = opt("edition", "available");
    push(@$availref, "platform");
    opt("edition", "default") = "platform";
}
if ( $build_media ) {
    my $availref = opt("edition", "available");
    push(@$availref, "media");
    opt("edition", "default") = "media";
}
if ( $build_pda ) {
    my $availref = opt("edition", "available");
    push(@$availref, "pda");
    opt("edition", "default") = "pda";
}
if ( $build_phone ) {
    my $availref = opt("edition", "available");
    push(@$availref, "phone");
    opt("edition", "default") = "phone";
}

# Do a sanity check on the opt_ variables
if ( configopt("depot") ) {
    opt_sanity_check();
}

# Save the command line
my $configure;
my $quote;
if ( $isWindows ) {
    $configure = fixpath("$qbs_bin/configure");
    $quote = '"';
} else {
    $configure = fixpath("$depotpath/src/build/bin/configure");
    $quote = "'";
}
my @command_line = @ARGV;
# strip out options marked with "no_keep" => 1,
for my $optname ( keys %Qtopia::Opt::optvar_storage ) {
    if ( opt($optname, "no_keep") ) {
        my $setref = opt($optname, "set");
        my $set = $setref?$setref->[0]:"";
        my $unsetref = opt($optname, "unset");
        my $unset = $unsetref?$unsetref->[0]:"";
        for ( $set, $unset ) {
            s/%/$optname/;
            s/_/-/g;
        }
        if ( $set =~ s/=.*// ) {
            my @tmp = @command_line;
            @command_line = ();
            my $skip = 0;
            for ( @tmp ) {
                if ( $skip ) {
                    --$skip;
                    next;
                }
                if ( /^--?\Q$set\E$/ ) {
                    $skip = 1 unless ( /=/ );
                    next;
                }
                push(@command_line, $_);
            }
        } else {
            if ( $set || $unset ) {
                @command_line = grep { (!$set || !/^--?\Q$set\E$/) && (!$unset || !/^--?\Q$unset\E$/) } @command_line;
            }
        }
    }
}
my $command_line = (@command_line?$quote:"").join("$quote $quote", @command_line).(@command_line?$quote:"");
opt("qpe_config") = $command_line;
opt("qpe_config", "argv") = [ @ARGV ];
if ( open IN, "$QPEDIR/config.status" ) {
    while ( defined($_ = <IN>) ) {
        if ( /configure/ ) {
            chomp;
            opt("qpe_config", "config_status") = $_;
            last;
        }
    }
    close IN;
}

# Get options and print help
my @ARGV_SAVE = @ARGV;
Qtopia::Opt::setEngine($engine);
my $ok = opt_get_options( "nohelp", "noextra", "novalidate" );

# config.defaults simplifies configuring and building Qtopia for a specific environment (eg. greenphone SDK)
if ( opt("config_defaults") ) {
    my $configure_changes = opt("config_defaults")."/configure.pl";
    if ( -e $configure_changes ) {
        open IN, "$configure_changes" or die "Can't read $configure_changes";
        eval join("", <IN>) or die "Error while evaluating config.defaults/configure.pl: $!\n$@";
        close IN;
    }
} else {
    my $conf_dir;
    if ( -d "$QPEDIR/config.defaults" ) {
        $conf_dir = "$QPEDIR/config.defaults";
    } elsif ( -d "$depotpath/config.defaults" ) {
        $conf_dir = "$depotpath/config.defaults";
    }
    if ( $conf_dir ) {
        # Write config.status now so that it doesn't have the contents of config.defaults/configure
        if ( opt("save_options") ) {
            write_config_status();
        }
        my $conf = "";
        if ( open IN, "$conf_dir/configure" ) {
            $conf = join(" ", <IN>);
            $conf =~ s/\n//g;
            close IN;
        }
        my $command_line = "$configure '".join("' '", @ARGV_SAVE)."'";
        $command_line .= " -config-defaults '$conf_dir' $conf";
        $command_line .= " -no-save-options";
        DEBUG and print "config.defaults found... rerunning configure:\n$command_line\n";
        exec <<END;
CONFIG_DEFAULTS_PATH="$conf_dir"
[ -f "\$CONFIG_DEFAULTS_PATH/environment" ] && . "\$CONFIG_DEFAULTS_PATH/environment"
cd $cwd && $command_line
END
        die "ERROR: Could not re-run confiure!\n";
    }
}
# Device profiles simplify configuring and building Qtopia
if ( opt("device") ) {
    opt("device", "config_path") = fixpath("$depotpath/devices/".opt("device"));
    opt("device", "device_bin") = fixpath("$QPEDIR/devices/".opt("device")."/device_bin");
    if ( ! -e opt("device", "config_path") ) {
        $ok = 0;
    }
    # If the user selected a device, configure might need to be re-run with extra arguments
    if ( $ok && !opt("using_device") ) {
        # Write config.status now so that it has -device foo instead of the replaced line
        if ( opt("save_options") ) {
            write_config_status();
        }
        my $conf = "";
        if ( open IN, opt("device", "config_path")."/configure" ) {
            $conf = join(" ", <IN>);
            $conf =~ s/\n//g;
            close IN;
        }
        my $device = opt("device");
        my $command_line = "$configure ".(@ARGV_SAVE?"'":"").join("' '", @ARGV_SAVE).(@ARGV_SAVE?"'":"");
        $command_line =~ s/'--?(device' '\Q$device\E')/'-using-$1 $conf/;
        $command_line .= " -no-save-options";
        my $device_config_path = opt("device", "config_path");
        my $default_device_path = opt("device", "default_path");
        my $device_bin = opt("device", "device_bin");
        DEBUG and print "-device used... rerunning configure:\n$command_line\n";

# NOTE NOTE NOTE NOTE NOTE NOTE NOTE NOTE NOTE NOTE NOTE NOTE NOTE NOTE NOTE
#
# The environment file handling logic is duplicated in runwithvars.sh
# However, the removing of device_bin is specific to configure
#
# NOTE NOTE NOTE NOTE NOTE NOTE NOTE NOTE NOTE NOTE NOTE NOTE NOTE NOTE NOTE

        exec <<END;
DEVICE_CONFIG_PATH="$device_config_path"
DEFAULT_DEVICE_PATH="$default_device_path"
DEVICE_BIN="$device_bin"
# Ensure device_bin is empty (so the wrapper scripts get re-generated)
rm -rf \$DEVICE_BIN
mkdir -p \$DEVICE_BIN
. "\$DEFAULT_DEVICE_PATH/environment"
[ -f "\$DEVICE_CONFIG_PATH/environment" ] && . "\$DEVICE_CONFIG_PATH/environment"
setup_path
cd $cwd && $command_line
END
        die "ERROR: Could not re-run confiure!\n";
    }
}
# mkconf uses this to override configure arguments without screwing up config.status
my @mkconf = @{opt("mkconf")};
if ( @mkconf && !opt("using_mkconf") ) {
    # Write config.status now so that it doesn't have the contents of config.defaults/configure
    if ( opt("save_options") ) {
        write_config_status();
    }
    my $command_line = "$configure '".join("' '", @ARGV_SAVE)."'";
    $command_line .= " ".join(" ", @mkconf);
    $command_line .= " -using-mkconf -no-save-options";
    exec <<END;
cd $cwd && $command_line
END
    die "ERROR: Could not re-run confiure!\n";
}

if ( !Qtopia::Opt::validate() ) {
    $ok = 0;
}

if ( !$ok || opt("help") ) {
    Qtopia::Opt::get_help();
}

if ( $engine eq "Getopt" ) {
    print_configure_line("Qtopia (expanded commandline):", join(" ", @ARGV_SAVE));
}

# Check license stuff
validateLicense();

# Let the user know which locations we're using
print "Qtopia is using the following locations:\n";
if ( $HOST_QT eq $DQTDIR ) {
print "Qt          SOURCE tree = $qt_depot_path\n";
print "Qt          BUILD  tree = $DQTDIR\n";
} else {
print "Qt          PREFIX      = $HOST_QT\n";
print "Qt          LIBRARIES   = $HOST_QT_LIBS\n";
print "Qt          BINARIES    = $HOST_QT_BINS\n";
}
print "Qtopia Core SOURCE tree = $qt_depot_path\n";
print "Qtopia Core BUILD  tree = $QTEDIR\n";
print "Qtopia      SOURCE tree = $depotpath\n";
print "Qtopia      BUILD  tree = $QPEDIR\n";

# shadow build checks
if ( $shadow ) {
    if ( $isWindows ) {
	die "ERROR: Shadow builds are not supported on win32\n";
    }
    if ( index( $QPEDIR, fixpath("$depotpath/") ) != -1 ) {
	die "ERROR: You cannot shadow build from inside the source tree\n";
    }

    symlink_all_files("bin");
    symlink_all_files("scripts");
    symlink_all_files("tests/scripts");

    symlink_all_files("etc");
    unlink("$QPEDIR/etc/defaultbuttons.conf");
    unlink("$QPEDIR/etc/themes");
    mkpath("$QPEDIR/etc/themes");

    symlink_file($depotpath."/apps",$QPEDIR."/apps");
    symlink_file($depotpath."/doc",$QPEDIR."/doc");
    symlink_file($depotpath."/pics",$QPEDIR."/pics");
    symlink_file($depotpath."/services",$QPEDIR."/services");
    symlink_file($depotpath."/sounds",$QPEDIR."/sounds");
    symlink_file($depotpath."/help",$QPEDIR."/help");
    symlink_file($depotpath."/i18n",$QPEDIR."/i18n");
    symlink_all_files("src/build/bin");

    # Clean out any builds found in the Qtopia source tree
    clean_qtopia_sources();
} elsif ( !$isWindows ) {
    my $dir = basename($depotpath);
    die <<END;


ERROR: Qtopia cannot be built from the source directory. You should build
       from a different directory.

         eg.

             cd ..
             mkdir build
             cd build
             ../$dir/configure [options]


END
}
mkpath("$QPEDIR/lib/host");

# If the user selected Qtopia Sync Agent but not Qtopia, do not build Qtopia
if ( opt("qtopiadesktop") && !opt("edition") ) {
    opt("edition", "default") = undef;
}
# And vice versa
if ( opt("edition") && !opt("qtopiadesktop") ) {
    opt("qtopiadesktop", "default") = undef;
}

if ( opt("singleexec") ) {
    # There's no point doing "normal" launching in singleexec (no cost for symbol relocations)
    if ( opt_resolve("launch_method") eq "normal" ) {
        opt("launch_method") = "quicklaunch";
        opt("launch_method", "showauto") = 1;
    }

    # Disable sxe (it's pointless)
    opt("sxe") = undef;
    opt("sxe", "default") = undef;
}

# cross-compile defaults
if ( opt("xplatform") ) {
    # QVFb is not useful for a real device
    opt("qvfb", "default") = 0;
}

# Apply defaults
opt_apply_defaults("edition", "qtopiadesktop");

# i18n fonts
if ( opt("font") && opt("auto_i18n_fonts") ) {
    my $fontref = opt("font");
    if ( index(opt_resolve("languages"), "zh_CN") != -1 ) {
        push(@$fontref, "wenquanyi:*:*");
        opt("font", "auto") = 1;
    }
    if ( index(opt_resolve("languages"), "ko") != -1 ||
         index(opt_resolve("languages"), "ar") != -1 ) {
        push(@$fontref, "unifont:*:*");
        opt("font", "auto") = 1;
    }
    if ( index(opt_resolve("languages"), "ja") != -1 ) {
        push(@$fontref, "japanese:*:*");
        opt("font", "auto") = 1;
    }
}

# Host detection
if ( !opt("platform") ) {
    opt("platform", "auto") = 1;
    if ( defined($ENV{QMAKESPEC}) && $ENV{QMAKESPEC} ne "" ) {
	opt("platform") = basename($ENV{QMAKESPEC});
	if ( ! -d $qt_depot_path."/mkspecs/".opt("platform") ) {
	    warn "WARNING: Spec ".opt("platform")." (from \$QMAKESPEC) could not be found. Attempting autodetection.\n";
	    opt("platform") = undef;
	}
    }
    if ( !opt("platform") ) {
	if ( $^O eq "linux" ) {
	    opt("platform") = "linux-g++";
	} elsif ( $isMac ) {
	    opt("platform") = "macx-g++";
	} else { 
            die <<END;
ERROR: Can't autodetect the host platform. Host = $^O.
Please explicitly set a -platform parameter.
END
	}
    }
}

if ( opt("edition") ) {
    # Turn on engine-specific options (for per-engine checks)
    if ( opt("qtopiamedia") ) {
        for ( split(/ /, opt("mediaengines")) ) {
            if ( $_ eq "helix" ) {
                opt("helix") = 1;
                opt("helix", "auto") = opt("mediaengines", "auto");
            }
        }
    }

    if (!opt("xplatform")) {
        opt("xplatform", "auto") = 1;
	if ( opt("qws") && opt("platform") =~ /^([^-]+)-([^-]+)$/ ) {
	    opt("xplatform") = $1."-generic-".$2;
	} else {
	    opt("xplatform") = opt("platform");
	}
    }
    # Allow architecture short-hands
    if ( opt("qws") && index(opt("xplatform"), "-") == -1 ) {
	opt("xplatform") = "linux-".opt("xplatform")."-g++";
    }
    if ( !opt("arch") && opt("xplatform") ne opt("platform") ) {
        opt("arch", "auto") = 1;
	( opt("arch") ) = ( opt("xplatform") =~ /-(.*?)-/ );
    }
    if ( !opt("arch") && opt("xplatform", "auto") ) {
        opt("arch") = $x86_64?"x86_64":"i386";
    }
    if ( !opt("arch") ) {
        die "ERROR: Cannot detect architecture. Please specify -arch <architecture>\n";
    }
    if ( opt("arch") eq "x86" || (opt("arch", "auto") && opt("arch") eq "generic") ) {
        opt("arch") = $x86_64?"x86_64":"i386";
    }
    if ( ! -d "$qt_depot_path/src/corelib/arch/".opt("arch") ) {
        die "ERROR: Architecture ".opt("arch")." is not supported by Qtopia Core.\n".
            "       Please see the documentation for information about porting to a new architecture.\n";
    }
    # Check for defaultbuttons.conf in the device configuration
    if ( !opt("defaultbuttons") && opt("device") && -e opt("device", "config_path")."/defaultbuttons.conf" ) {
        opt("defaultbuttons", "auto") = 1;
        opt("defaultbuttons") = opt("device", "config_path")."/defaultbuttons.conf";
    }
    if ( opt("defaultbuttons") ) {
        chdir $cwd;
        my $db = opt("defaultbuttons");
        # If we do not have a full path, pick one based on the default location
        if ( ! -f $db ) {
            $db = "$depotpath/etc/defaultbuttons-$db.conf";
        }
        if ( ! -f $db ) {
            die "ERROR: Can't find ".opt("defaultbuttons").".\n".
                "       Tried $cwd".opt("defaultbuttons")." and $db\n";
        }
    }
    if ( !opt("defaultbuttons") ) {
        opt("defaultbuttons", "auto") = 1;
        if ( opt("edition") eq "phone" || opt("edition") eq "platform" || opt("edition") eq "media" ) {
            opt("defaultbuttons") = "phone";
        } else {
            opt("defaultbuttons") = "pda";
        }
        # Use the proper path
        opt("defaultbuttons") = "$depotpath/etc/defaultbuttons-".opt("defaultbuttons").".conf";
    }

    # Check for Storage.conf in the device configuration
    if ( opt("device") && -e opt("device", "config_path")."/Storage.conf" ) {
        opt("storage_conf_file") = fixpath(opt("device", "config_path")."/Storage.conf");
    } elsif ( -e "$depotpath/etc/default/Trolltech/Storage.conf" ) {
        opt("storage_conf_file") = fixpath("$depotpath/etc/default/Trolltech/Storage.conf");
    }

    # Check for Hardware.conf in the device configuration
    if ( opt("device") && -e opt("device", "config_path")."/Hardware.conf" ) {
        opt("hardware_conf_file") = fixpath(opt("device", "config_path")."/Hardware.conf");
    }
    elsif ( -e "$depotpath/etc/default/Trolltech/Hardware.conf" ) {
        opt("hardware_conf_file") = fixpath("$depotpath/etc/default/Trolltech/Hardware.conf");
    }

    # Can't specify -no-keypad-navigation when building phone
    if ( opt("edition") eq "phone" && !opt("keypad_navigation") ) {
        die "ERROR: You cannot disable keypad navigation in phone edition.\n";
    }
}

# Convert platform and xplatform to absolute paths
opt("platform", "absolute") = opt("platform");
opt("xplatform", "absolute") = opt("xplatform");
if ( !defined(opt("xplatform", "absolute")) ) {
    opt("xplatform", "absolute") = "";
}
chdir $cwd;
# The spec file might be inside the device configuration directory
if ( opt("device") && -e opt("device", "config_path")."/mkspecs/".opt("platform") ) {
    opt("platform", "absolute") = opt("device", "config_path")."/mkspecs/".opt("platform");
}
if ( ! -d opt("platform", "absolute") ) {
    opt("platform", "absolute") = "$qt_depot_path/mkspecs/".opt("platform");
}
if ( opt("edition") ) {
    # The spec file might be inside the device configuration directory
    if ( opt("device") && -e opt("device", "config_path")."/mkspecs/qws/".opt("xplatform") ) {
        opt("xplatform", "absolute") = opt("device", "config_path")."/mkspecs/qws/".opt("xplatform");
    }
    if ( ! -d opt("xplatform", "absolute") ) {
        opt("xplatform", "absolute") = "$qt_depot_path/mkspecs/qws/".opt("xplatform");
    }
    if ( !opt("qws") ) {
        # The spec file might be inside the device configuration directory
        if ( opt("device") && -e opt("device", "config_path")."/mkspecs/".opt("xplatform") ) {
            opt("xplatform", "absolute") = opt("device", "config_path")."/mkspecs/".opt("xplatform");
        }
        if ( ! -d opt("xplatform", "absolute") ) {
            opt("xplatform", "absolute") = "$qt_depot_path/mkspecs/".opt("xplatform");
        }
    }
}
opt("platform", "absolute") = fixpath(opt("platform", "absolute"));
opt("xplatform", "absolute") = fixpath(opt("xplatform", "absolute"));
if ( ! -e opt("platform", "absolute") ) {
    die "ERROR: ".fixpath(opt("platform", "absolute"))." does not exist, check -platform parameter is correct.\n";
}
if ( opt("edition") && ! -e opt("xplatform", "absolute") ) {
    die "ERROR: ".fixpath(opt("xplatform", "absolute"))." does not exist, check -xplatform parameter is correct.\n";
}
if ( !$isWindows ) {
    # When building the SDK we want to create the 'default' mkspecs... we need a path
    # relative to the install prefix for that...
    for my $platform ( "platform", "xplatform" ) {
        $_ = opt($platform, "absolute");
        if ( $_ ) {
            if ( s/^\Q$depotpath\E(\/devices)/$1/ ) {
                # This mkspec came from a device profile...
            } elsif ( s/^\Q$qt_depot_path\E(\/mkspecs)/\/qtopiacore\/qt$1/ ) {
                # This mkspec came from Qt...
            } else {
                # Hmm... skip this one because we can't locate it in our sources
                warn "Can't locate $_ relative to the Qtopia or Qt source trees";
                next;
            }
            opt($platform, "sdk") = $_;
        }
    }
}

# Qt assumes non-absolute paths to -platform and -xplatform and some tests (eg. x86_64
# support) rely on this. If the values are in the Qt depot path then make them relative
# again. This is better than assuming a relative path was passed to our -platform and
# -xplatform arguments.
my $qt_platform = opt("platform", "absolute");
my $qt_xplatform = opt("xplatform", "absolute");
my $qt_mkspecs = fixpath("$qt_depot_path/mkspecs/");
$qt_platform =~ s,^\Q$qt_mkspecs\E,,;
if ( opt("edition") ) {
    $qt_xplatform =~ s,^\Q$qt_mkspecs\E,,;
}

# Don't use a relative prefix!
for my $prefix ( opt("prefix"), opt("dprefix"), opt("image"), opt("dimage"), opt("sdkroot") ) {
    if ( !$prefix ) {
        next;
    }
    my $path = $prefix;
    if ( !$isWindows && index($path, "/") != 0 ) {
        my $old_prefix = $path;
        $prefix = fixpath($cwd."/".$path);
        warn "WARNING: Using $prefix instead of $old_prefix.\n";
    }
}

# set the prefix for the implicit rpath
if ( opt("prefix") ) {
    opt("rpath", "prefix") = fixpath(opt("prefix")."/lib");
} else {
    opt("rpath") = 0;
}

# Detect the Beep Science DRM Agent include and lib directories
if ( opt("edition") && opt("drm") ) {
    my $drmincdir = fixpath("/usr/local/include/bscidrm2.4");
    my $drmlibdir = fixpath("/usr/local/lib/bscidrm2.4");
    if ( -d $drmincdir && -d $drmlibdir ) {
        opt("extraIncPaths", "auto") = 1;
        my $ref = opt("extraIncPaths");
        push(@$ref, $drmincdir);
        opt("extraLibPaths", "auto") = 1;
        $ref = opt("extraLibPaths");
        push(@$ref, $drmlibdir);
    }
}

# Early config tests (needed before we build Qt)
print "\n";
opt("compiler", "host_gcc4") = 0;
opt("compiler", "host_endian") = "unknown";
opt("compiler", "target_gcc4") = 0;
opt("compiler", "target_endian") = "unknown";
# Qtopia's endian switches override the autodetect
if ( defined(opt("target_little_endian")) ) {
    if ( opt("target_little_endian") ) {
        opt("compiler", "target_endian") = "little";
    } else {
        opt("compiler", "target_endian") = "big";
    }
}
# Qtopia's endian switches also override Qtopia Core's switches so search through and remove them now
{
    my $ref = opt("extra_qte_config");
    for ( @$ref ) {
        if ( s/--?(little|big)-endian//g ) {
            print "Note: -extra-qtopiacore-config -$1-endian has no effect.\n";
        }
    }
}
my @combinations = ( "host", opt("platform", "absolute"),
                     "target", opt("xplatform", "absolute") );
while ( @combinations ) {
    my $host = shift(@combinations);
    my $plat = shift(@combinations);
    next if ( !$plat );

    # Detect gcc 4
    open IN, "$plat/qmake.conf" or die "Can't read $plat/qmake.conf\n";
    my @data = <IN>;
    close IN;
    my @old = @data;
    @data = ();
    for ( @old ) {
        if ( /include\((.*)\)/ ) {
            chdir $plat;
            open INC, "$1" or die "Can't read $1\n";
            push(@data, <INC>);
            close INC;
        } else {
            push(@data, $_);
        }
    }
    my ( $cxx ) = ( (grep /^QMAKE_CXX\s*\+?=/, @data)[0] =~ /=(.*)/ );
    my ( $cflags ) = ( (grep /^QMAKE_CFLAGS\s*\+?=/, @data)[0] =~ /=(.*)/ );
    my ( $cxxflags ) = ( (grep /^QMAKE_CXXFLAGS\s*\+?=/, @data)[0] =~ /=(.*)/ );
    my ( $lflags ) = ( (grep /^QMAKE_LFLAGS\s*\+?=/, @data)[0] =~ /=(.*)/ );
    for ( $cxx, $cflags, $cxxflags, $lflags ) {
        chomp;
        s/^\s+//;
        s/\s+$//;
    }
    $cxxflags =~ s/\$\$QMAKE_CFLAGS/$cflags/;
    my $envstring = "CXX='$cxx' CXXFLAGS='$cxxflags' LFLAGS='$lflags' QPEDIR='$QPEDIR' ".
                    "QTOPIA_DEPOT_PATH='$depotpath' HOST='$host' VERBOSE='".opt("verbose")."'";

    if ( !$isWindows ) {
        print "Checking the compiler ($host): ";
        print "\n" if ( opt("verbose") );
        my $out;
        my $ret = configtest("compiler", "env", $envstring, "outvar", $out);
        if ( $ret ) {
            my @msg;
            if ( grep /^GCC VERSION 4/, split(/\n/, $out)) {
                opt("compiler", $host."_gcc4") = 1;
                push(@msg, "GCC 4");
            } else {
                opt("compiler", $host."_gcc4") = 0;
            }
            if ( grep /^LeastSignificantByteFirst/, split(/\n/, $out)) {
                if ( opt("compiler", $host."_endian") eq "unknown" ) {
                    opt("compiler", $host."_endian") = "little";
                }
                if ( opt("compiler", $host."_endian") eq "little" ) {
                    push(@msg, "Little Endian");
                } else {
                    push(@msg, "Big Endian - user override");
                }
            } elsif ( grep /^MostSignificantByteFirst/, split(/\n/, $out)) {
                if ( opt("compiler", $host."_endian") eq "unknown" ) {
                    opt("compiler", $host."_endian") = "big";
                }
                if ( opt("compiler", $host."_endian") eq "big" ) {
                    push(@msg, "Big Endian");
                } else {
                    push(@msg, "Little Endian - user override");
                }
            } else {
                print "FAIL (cannot detect endianness)\n";
                print "Please use the -little-endian or -big-endian switch.\n";
                print "Note: Run configure -verbose for verbose errors\n";
                exit 1;
            }
            print "OK ".(@msg?"(":"").join(", ",@msg).(@msg?")":"")."\n";
        } else {
            if ( $out =~ /CANNOT RUN BINARIES/ ) {
                print "FAIL (cannot run binaries)\n";
            } else {
                print "FAIL\n";
            }
            print "Note: Run configure -verbose for verbose errors\n";
            exit 1;
        }
    }
}

if ( opt("sxe") ) {
    # Change 186258 in Qtopia renders SXE impotent unless change
    # 256275/256276/256278 (Qt 4.2/4.3/main) has been applied.
    # The problem is that change 186258 removes the per-app keys,
    # opting for magic in /proc instead. This gains us many things
    # but means that out-of-sync builds will have ALL operations denied.
    #
    # So because SXE has been enabled and because we don't want to
    # produce a build that can't do anything we're going to test that
    # Qt actually contains the required change and warn if it's missing.
    my $enable = 0;
    if ( open IN, "$qt_depot_path/src/gui/embedded/qtransportauth_qws.cpp" ) {
        my @data = <IN>;
        close IN;
        my @tmp = grep(/SxeRegistryLocker::SxeRegistryLocker/, @data);
        if ( @tmp ) {
            $enable = 1;
        }
    }
    if ( !$enable ) {
        warn <<END;
WARNING: SXE cannot be enabled because change 256276/256278 (4.3/main) has not
         been applied to Qt. Please apply this change to your Qt sources if
         you want SXE to be enabled.
END
        die_if_not_auto("sxe");
        opt("sxe", "auto") = 1;
        opt("sxe") = 0;
    }
}

# Validate options

if ( opt("edition") ) {
    # Check that helix exists
    if ( opt("helix") ) {
        print "Testing for helix: ";
        if ( -d $helix_depot_path ) {
            print "PRESENT\n";
        } else {
            print "MISSING\n";
            print "Helix is disabled. Please read the documentation for instructions on how to enable Helix.\n";
            die_if_not_auto("helix");
            opt("helix", "auto") = 1;
            opt("helix") = 0;
        }
    }
}

# Apply options
opt("displaysize", "codes") = "";
opt("displaysize", "width") = "";
opt("displaysize", "height") = "";
if ( opt("edition") ) {
    my ($szlo,$szhi);
    my ($szw,$szh);
    if ( ($szw,$szh) = opt("displaysize") =~ m{(\d+)[xX](\d+)} ) {
	$szhi=$szlo=$szw;
	opt("displaysize", "codes").=" X";
	opt("displaysize", "width").=$szw;
	opt("displaysize", "height").=$szh;
    } elsif ( ($szlo,$szhi) = opt("displaysize") =~ m{(\d*)(?:-(\d*))?} ) {
	$szhi=$szlo if !$szhi;
    } else {
	exit 1;
    }
    opt("displaysize", "codes").=" C" if $szlo <= 176;
    opt("displaysize", "codes").=" P" if $szlo <= 240 && 240 <= $szhi;
    opt("displaysize", "codes").=" W" if $szlo <= 640 && 640 <= $szhi;
    opt("displaysize", "codes").=" T" if                 800 <= $szhi;

    mkpath("$QPEDIR/etc/default/Trolltech/");

    # -no-telephony implies -no-modem and -no-voip (so enforce it)
    if ( !opt("telephony") ) {
        if ( opt("modem", "auto") ) {
            opt("modem") = 0;
        }
        if ( opt("voip", "auto") ) {
            opt("voip") = 0;
        }
        if ( opt("modem") || opt("voip") ) {
            warn "ERROR: You cannot pass -modem and -no-telephony.\n" if ( opt("modem") );
            warn "ERROR: You cannot pass -voip and -no-telephony.\n" if ( opt("voip") );
            exit 1;
        }
    }
}

# Fix up the font definitions (easier in perl than in qmake)
if ( opt("font") ) {
    my $fontref = opt("font");
    my %fontref_handled;
    my @fonts;
    my @files;
    push(@files, glob("$qt_depot_path/dist/embedded/lib/fonts/*.qpf"),
                 glob("$qt_depot_path/dist/embedded/lib/fonts/*.qpf2"),
                 glob("$depotpath/dist/fonts/*.qpf"),
                 glob("$depotpath/dist/fonts/*.qpf2"));
    for my $file ( @files ) {
        DEBUG and print "file $file\n";
        my $filename = basename($file);
        my $family;
        my $size;
        my $style;
        my $rotation;
        if ( $filename =~ /(.*)_(\d+)_(\d+i?)\.qpf$/ ) {
            $family = $1;
            $size = $2;
            $style = $3;
        } elsif ( $filename =~ /(.*)_(\d+)_(\d+i?)_(t\d+)\.qpf$/) {
            $family = $1;
            $size = $2;
            $style = $3;
            $rotation = $4;
        } elsif ( $filename =~ /(.*)_(\d+)_(\d+)\.qpf2/ ) {
            $family = $1;
            $size = $2;
            $style = $3;
        } elsif ( $filename =~ /(.*)_(\d+)_(\d+)_italic\.qpf2/ ) {
            $family = $1;
            $size = $2;
            $style = $3."i";
        } elsif ( $filename =~ /(.*)_(\d+)_(\d+)_(t\d+)\.qpf2/) {
            $family = $1;
            $size = $2;
            $style = $3;
            $rotation = $4;
        } elsif ( $filename =~ /(.*)_(\d+)_(\d+)_italic_(t\d+)\.qpf2/) {
            $family = $1;
            $size = $2;
            $style = $3."i";
            $rotation = $4;
        } else {
            warn "Can't understand the naming of font $file\n";
            next;
        }

        FONTSPEC: for my $fontspec ( @$fontref ) {
            #next if ( $fontspec =~ /\.ttf$/ );
            my ( $fsfamily, $sizes, $styles ) = split(/:/, $fontspec);
            next if ( !defined($fsfamily) || !defined($sizes) || !defined($styles) );
            my @sizes;
            for ( split(/,/, $sizes) ) {
                if ( /(\d+)-(\d+)/ ) {
                    for ( my $i = $1; $i < $2; $i++ ) {
                        push(@sizes, $i);
                    }
                } else {
                    push(@sizes, $_);
                }
            }
            my @styles = split(/,/, $styles);
            if ( $fsfamily eq $family ) {
                for ( @sizes ) {
                    if ( $_ eq "*" || $size eq $_ ) {
                        for ( @styles ) {
                            if ( $_ eq "*" || $style eq $_ ) {
                                DEBUG and print "FILE $file matches $fontspec\n";
                                push(@fonts, $file);
                                $fontref_handled{$fontspec} = 1;
                                last FONTSPEC;
                            } else {
                                DEBUG and print "$style does not equal $_\n";
                            }
                        }
                    } else {
                        DEBUG and print "$size does not equal $_\n";
                    }
                }
            } else {
                DEBUG and print "$family does not equal $fsfamily\n";
            }
        }
    }
    # Now add the truefype font files
    @files = ();
    push(@files, glob("$qt_depot_path/dist/embedded/lib/fonts/*.ttf"),
                 glob("$depotpath/dist/fonts/*.ttf"));
    for my $file ( @files ) {
        DEBUG and print "file $file\n";
        my $filename = basename($file);

        FONTSPEC: for my $fontspec ( @$fontref ) {
            if ( $fontspec eq $filename ) {
                DEBUG and print "FILE $file matches $fontspec\n";
                push(@fonts, $file);
                $fontref_handled{$fontspec} = 1;
                last FONTSPEC;
            }
        }
    }
    my $ok = 1;
    for my $fontspec ( @$fontref ) {
        if ( !$fontref_handled{$fontspec} ) {
            print "ERROR: -font $fontspec does not match any fonts.\n";
            $ok = 0;
        }
    }
    if ( !$ok ) {
        exit 1;
    }
    opt("font", "files") = [ @fonts ];
}

#
# This should be the end of the configuring stuff
#

# Write config.status
if ( opt("save_options") ) {
    write_config_status();
}

# Clean out any builds found in the Qt source tree
if ( $qt_depot_path ne $DQTDIR ) {
    clean_qt_sources();
}

# This is how we tell Qt to use our make instead of one they detect on their own
$ENV{MAKE} = opt("make");

touch_force_qmake();

# Configure Qt
if ( $HOST_QT eq $DQTDIR ) {
    if ( !opt("dqt_config") ) {
        my $args = "-platform $qt_platform ".
                   "-no-stl -no-exceptions -fast ".
                   "-D QTOPIA_NO_ICONV_OPEN_ERRORS -confirm-license";
        map { $args .= " -no-sql-".basename($_) if ( basename($_) ne "tmp" && -d $_ ); } glob("$qt_depot_path/src/plugins/sqldrivers/*");
        $args .= " -qt-sql-sqlite";
        if ( !$isWindows ) {
            $args .= " -no-qdbus -no-openssl";
            my $prefix = $DQTDIR;
            if ( opt("sdkroot") && !opt("sdkroot", "auto") ) {
                $prefix = fixpath(opt("sdkroot")."/qtopiacore/host");
            }
            $args .= " -prefix $prefix";
        }
        if ( opt("release") ) {
            $args .= " -release";
        } else {
            $args .= " -debug";
        }
        if ( opt("gif") ) {
            $args .= " -qt-gif";
        }
        if ( $isWindows ) {
            $args .= " -no-dsp -no-vcproj -no-qt3support";
            $args .= " -make ".fixpath("$QPEDIR/bin/winmake.exe");
        } elsif ( $isMac ) {
            $args .= " -no-framework";
        }
        if ( opt("verbose") ) {
            $args .= " -verbose";
        }
        if ( opt("compiler", "host_gcc4") && opt("reduce_exports") ne "auto" ) {
            $args .= " --reduce-exports=".opt("reduce_exports");
        }
        if ( !$isWindows ) {
            if ( opt("silent") ) {
                $args .= " -silent";
            }
            if ( !opt("separate_debug_info") ) {
                $args .= " -no-separate-debug-info";
            }
        }
        my $listref = opt("extra_dqt_config");
        if ( @$listref ) {
            $args .= " ".join(" ", @$listref);
        }
        opt("dqt_config") = $args;
    }
    if ( !opt("skip_dqt") ) {
        configure_qt($DQTDIR, "Qt (host)", "dqt_config");
        if ( -d "$qt_depot_path/tools/qdoc3" ) {
            # for some reason Qt 4.2 no longer does the qdoc3 directory
            mkpath("$DQTDIR/tools/qdoc3");
            chdir("$DQTDIR/tools/qdoc3");
            system("$DQTDIR/bin/qmake", "-o", "$DQTDIR/tools/qdoc3/Makefile", "$qt_depot_path/tools/qdoc3/qdoc3.pro");
        }
    }
}

#####
Qtopia::Opt::write_config_cache();
system("$qbs_bin/write_config_pri", "tests");

# Different qmake versions have different behaviors. Detect them here so the build system can work around them.
{
    print "Testing for qmake behaviors: ";
    print "\n" if ( opt("verbose") );
    my $out;
    configtest("qmake_behaviors", "outvar", $out, "platform", "qmake_only");
    my @behaviors;
    my @lines = grep /QMAKE_BEHAVIORS:/, split(/\n/, $out);
    my $line = pop(@lines);
    if ( $line ) {
        @behaviors = split(/\s+/, ($line =~ /QMAKE_BEHAVIORS: (.*)/)[0]);
    }
    if ( @behaviors ) {
        opt("qmake", "behaviors") = lc(join(" ", @behaviors));
        $out = uc(join(", ", @behaviors))
    } else {
        $out = "NONE";
    }
    print "$out\n";
    my %test;
    map { $test{$_}++ } @behaviors;
    if ( $test{func_out_join} ) {
        die "ERROR: Qtopia cannot work around the FUNC_OUT_JOIN behavior in qmake.\n".
            "       Please use a newer version of Qt.\n";
    }
    if ( $test{var_parse} ) {
        die "ERROR: Qtopia cannot work around the VAR_PARSE behavior in qmake.\n".
            "       Please use a newer version of Qt.\n";
    }
    if ( exists($test{keep_quotes}) ) {
        die "ERROR: Qtopia cannot work around the KEEP_QUOTES behavior in qmake.\n".
            "       Please use a newer version of Qt.\n";
    }
}

# Check that helix will work
if ( opt("edition") && opt("helix") ) {
    HELIX: while ( 1 ) {
        # setup the helixbuild directory so we can do tests based on it's contents
        print "Setting up the helix sources...\n";
        Qtopia::Opt::write_config_cache();
        system("$qbs_bin/write_config_pri");
        my $MAKE = opt("make");
        my $hide_debug = "exec >/dev/null 2>&1";
        if ( opt("verbose") ) {
            $hide_debug = "set -x";
        }
        system <<END;
$hide_debug
cd $helix_depot_path
cd ..
depot=\$(/bin/pwd)
mkdir -p $helix_build_path
cd $helix_build_path
cd ..
build=\$(/bin/pwd)
$QPEDIR/bin/qtopiamake -projectroots \$build
perl -i -pe '\$build="'\$build'"; \$depot="'\$depot'"; s/\\Q\$build\\E/\Q$QPEDIR/src\E/; s/\\Q\$depot\\E/\Q$depotpath/src\E/;' .qmake.cache
if [ ! -e $QTEDIR/.qmake.cache ]; then
    :>$QTEDIR/.qmake.cache
fi
# Hack that forces the host qmake to be used (since Qtopia Core hasn't been built yet)
HOST_QMAKE=1 $MAKE regenerate
END

        # Pick a default helix_system_id if we've detected the xplatform (ie. standard x86 build)
        if ( !opt("helix_system_id") && opt("xplatform", "auto") ) {
            opt("helix_system_id", "auto") = 1;
            if ( $x86_64 ) {
                opt("helix_system_id") = "linux-2.6-glibc23-amd64";
            } else {
                # GCC 4 requires a different helix_system_id to avoid the annoying "-mcpu is deprecated" messages
                if ( opt("compiler", "target_gcc4") ) {
                    opt("helix_system_id") = "linux-2.2-libc6-gcc32-i586-gcc4";
                } else {
                    opt("helix_system_id") = "linux-2.2-libc6-gcc32-i586";
                }
            }
        }

        if ( opt("helix_system_id") &&
             ! -e "$helix_build_path/build/umakecf/".opt("helix_system_id").".cf" ) {
            warn "Helix SYSTEM_ID ".opt("helix_system_id")." is not valid.\n";
            opt("helix_system_id") = undef;
        }

        if ( !opt("helix_system_id") ) {
            warn "WARNING: You must supply a SYSTEM_ID (via -helix-system-id) to build Helix.\n";
            die_if_not_auto("helix");
            opt("helix", "auto") = 1;
            opt("helix") = 0;
            last;
        }

        print "Testing for python: ";
        print "\n" if ( opt("verbose") );
        my $python = configtest("python", "host_qmake");
        if ( $python ) {
            print "OK\n";
        } else {
            print "FAIL\n";
            print "Helix is disabled.\n";
            die_if_not_auto("helix");
            opt("helix", "auto") = 1;
            opt("helix") = 0;
            last;
        }

        if ( opt("helix") &&
             $licenseInfo{Product} !~ /Free/ && $licenseInfo{LicenseFile} ne "LICENSE.TROLL" ) {
            while ( 1 ) {
                my $acceptance = "no";
                if ( opt("confirm_license") ) {
                    print "Skipping confirmation of the Helix license agreement.\n";
                    $acceptance = "yes";
                } else {
                    print <<END;

Type 'yes' if you have a Helix license agreement that is signed by you and RealNetworks.
Type 'no' if you do NOT have a Helix license agreement that is signed by you and RealNetworks.

END
                    print "Do you have a signed license agreement? ";
                    $acceptance = <STDIN>;
                    chomp $acceptance;
                }
                print "\n";
                if ( $acceptance eq "yes" ) {
                    last;
                } elsif ( $acceptance eq "no" ) {
                    print <<END;
You are not licensed to use this software.
Please visit http://helixcommunity.org/ to arrange a license.

END
                    die_if_not_auto("helix");
                    opt("helix", "auto") = 1;
                    opt("helix") = 0;
                    opt("helix_system_id") = undef;
                    opt("helix_system_id", "default") = undef;
                    last HELIX;
                }
            }
        }

        # this needs to be last
        last;
    }
}

if ( opt("edition") && opt("sound_system") eq "alsa" ) {
    print "Testing for ALSA: ";
    print "\n" if ( opt("verbose") );
    my $alsa = configtest("alsa", "host_qmake");
    if ( $alsa ) {
        print "OK\n";
    } else {
        print "FAIL\n";
        die_if_not_auto("sound_system");
        opt("sound_system", "auto") = 1;
        opt("sound_system") = "oss";
        print "Using OSS as the sound system.\n";
    }
    # let helix know which sound system we're using
    opt("helix", "alsa") = $alsa?"alsa":"";
}

if ( opt("edition") && opt("helix") ) {
    # Steal some flags from the chosen SYSTEM_ID to help atomic stuff work
    my @flags;
    my @defines;
    my $outdir;
    get_system_id_flags(opt("helix_system_id").".cf", \@flags, \@defines, \$outdir);
    open OUT, ">>$QPEDIR/src/config.pri" or die "Can't write $QPEDIR/src/config.pri";
    my $cfgref = opt("config");
    for my $flag ( @flags ) {
        for my $cc ( qw(C CXX) ) {
            my $line = "!contains(QMAKE_${cc}FLAGS,$flag):QMAKE_${cc}FLAGS+=$flag";
            push(@$cfgref, $line);
            print OUT $line."\n";
        }
    }
    for my $define ( @defines ) {
        print OUT "DEFINES+=$define\n";
    }
    if ( $outdir ) {
        push(@$cfgref, "HELIX_OUT_DIR=$outdir");
    } else {
        die "ERROR: Can't locate the Helix output dir.\n".
            "       Please ensure your SYSTEM_ID sets project.output_dir = '[prefix-]<rel|dbg>'.\n";
    }
    close OUT;

    print "Testing for atomic operations in helix: ";
    print "\n" if ( opt("verbose") );
    my $atomic = configtest("helix_atomic", "host_qmake");
    if ( $atomic ) {
        print "OK\n";
    } else {
        print "FAIL\n";
        print <<END;

WARNING: Your xplatform qmake.conf does not seem to allow building Helix with
         atomic operations. Helix requires the use of atomic operations in order
         to be thread-safe. Please inspect the SYSTEM_ID you are using to see
         if you need to add compiler switches or defines to qmake.conf.

         For more information on atomic operations please see:
         $helix_depot_path/common/include/atomicbase.h

END
    }
    opt("helix", "atomic") = $atomic?"atomic":"";
}

if ( opt("qtopiamedia") ) {
    print "Testing sound engines for the Qtopia Media API: ";

    mkpath("$QPEDIR/config.tests/mediaengines");

    my @engines;
    for ( split(/ /, opt("mediaengines")) ) {
        if ( $_ eq "helix" ) {
            if ( opt("helix") ) {
                push(@engines, $_);
            }
        } else {
            my $ok = 1;
            my $engine = $_;
            my $enginetest = "$engine.test";
            if (-e "$depotpath/config.tests/$enginetest") {
                my $out;
                $ok = configtest("$engine", "outvar", $out);
                if ($ok) {
                    open OUT, ">$QPEDIR/config.tests/mediaengines/$engine.pri" or die "Can't write $QPEDIR/config.tests/mediaengines/$engine.pri";
                    print OUT $out;              
                    close OUT;
                }
                else {
                    print("Could not configure $engine - removed from build\n");
                }
            }

            if ($ok) {
                push(@engines, $engine);
            }         
        }
    }
    opt("mediaengines") = join(" ", @engines);

    # You can't have a qtopiamedia without engines
    if ( opt("qtopiamedia") ) {
        if ( opt("mediaengines") ) {
            print opt("mediaengines")."\n";
        } else {
            print "NONE\n";
            die_if_not_auto("qtopiamedia");
            print "The Qtopia Media API will not be available.\n";
            opt("qtopiamedia", "auto") = 1;
            opt("qtopiamedia") = 0;
        }
    }
}

if ( opt("rpath") ) {
    print "Checking QMAKE_RPATH: ";
    print "\n" if ( opt("verbose") );
    my $out;
    my $ok = configtest("rpath", "host_qmake", "qmake_only", "outvar", $out);
    if ( $ok ) {
        $ok = 0;
        for ( split(/\n/, $out) ) {
            if ( /QMAKE_RPATH (.*)/ ) {
                print "$1\n";
                $ok = 1;
                last;
            }
        }
    }
    if ( !$ok ) {
        print "FAIL\n";
        print "Explicit RPATH is disabled.\n";
        die_if_not_auto("rpath");
        opt("rpath", "auto") = 1;
        opt("rpath") = 0;
    }
}

if ( opt("ssl") ) {
    print "Testing for OpenSSL: ";
    print "\n" if ( opt("verbose") );
    my $ok = configtest("ssl", "host_qmake", "env", "QTEDIR=$QTEDIR QT_DEPOT=$qt_depot_path SINGLEEXEC=".opt("singleexec"));
    if ( $ok ) {
        print "OK\n";
    } else {
        print "FAIL\n";
        die_if_not_auto("ssl");
        opt("ssl", "auto") = 1;
        opt("ssl") = 0;
    }
}

# Configure Qtopia Core
if ( opt("edition") && !opt("qte_config") ) {
    my $qconfig;
    if ( opt("device") && -e opt("device", "config_path")."/qconfig.h" ) {
        $qconfig = opt("device");
    } else {
        $qconfig = "qpe";
    }
    my $prefix = $QTEDIR;
    if ( !opt("sdkroot", "auto") ) {
        $prefix = fixpath(opt("sdkroot")."/qtopiacore/target");
    }
    my $args = "-embedded ".opt("arch")." -platform $qt_platform -xplatform $qt_xplatform ".
               "-DQTOPIA_NO_ICONV_OPEN_ERRORS ".
               "-prefix $prefix -make src -make tools ".
               "-no-stl -no-exceptions -no-qt3support -no-glib -no-cups -no-qdbus -no-accessibility ".
               "-DQT_QWS_DISABLE_FLUSHCLIPPING ".
               "-confirm-license";
    if ( opt("qws") ) {
        $args .= " -depths 8,16,18,24,32 -qconfig $qconfig".
                 " -DQT_NO_PLUGIN_CHECK -DQT_EXTERNAL_SOUND_SERVER -DQT_QWS_KEYEVENT_SINGLECLIENT";
    } else {
        $args .= " --enable-x11";
    }
    map { $args .= " -no-sql-".basename($_) if ( basename($_) ne "tmp" && -d $_ ); } glob("$qt_depot_path/src/plugins/sqldrivers/*");
    $args .= " -qt-sql-sqlite";
    if ( opt("release") ) {
        $args .= " -release";
    } else {
        $args .= " -debug";
    }
    if ( opt("profile") ) {
        $args .= " -profile";
    }
    if ( opt("qws") ) {
        if ( opt("qvfb") ) {
            $args .= " -qt-gfx-qvfb -qt-mouse-qvfb -qt-kbd-qvfb";
        } else {
            $args .= " -no-gfx-qvfb -no-mouse-qvfb -no-kbd-qvfb";
        }
    }
    if ( opt("gif") ) {
        $args .= " -qt-gif";
    }
    if ( opt("verbose") ) {
        $args .= " -verbose";
    }
    if ( opt("singleexec") ) {
        $args .= " -static";
    }
    if ( opt("sxe") ) {
        $args .= " -sxe";
        if ( opt("sxe_discovery") ) {
            # SXE_DISCOVERY is only for use during development of a Qtopia system, and
            # not be defined for a production system build.  When this macro is defined
            # code is compiled to read the environment variable SXE_DISCOVERY_MODE and
            # to TURN OFF the SXE system if that environment variable is defined.  Shipping
            # a system compiled with this macro defined is a security breach.
            $args .= " -DSXE_DISCOVERY";
        }
    }
    if ( opt("qtopiamedia") ) {
        $args .= " -DMEDIA_SERVER";
    }
    if ( opt("compiler", "target_gcc4") && opt("reduce_exports") ne "auto" ) {
        $args .= " --reduce-exports=".opt("reduce_exports");
    }
    if ( opt("silent") ) {
        $args .= " -silent";
    }
    if ( !opt("rpath") ) {
        $args .= " -no-rpath";
    }
    if ( !opt("separate_debug_info") ) {
        $args .= " -no-separate-debug-info";
    }
    if ( !opt("ssl") ) {
        $args .= " -no-openssl";
    }
    if ( opt("keypad_navigation") ) {
        $args .= " -DQT_KEYPAD_NAVIGATION";
    }
    if ( opt("glib") ) {
        $args .= " -glib";
    }
    my @data = (
        "extraIncPaths" => "-I",
        "extraLibPaths" => "-L",
        "extraLibs" => "-l",
        "extraRPaths" => "-R",
        "extraDefines" => "-D",
    );
    while ( @data ) {
        my $var = shift(@data);
        my $flag = shift(@data);
        my $listref = opt($var);
        if ( @$listref ) {
            $args .= " $flag".join(" $flag", @$listref);
        }
    }
    if ( opt("compiler", "target_endian") eq "little" ) {
        $args .= " -little-endian";
    } elsif ( opt("compiler", "target_endian") eq "big" ) {
        $args .= " -big-endian";
    }
    my $listref = opt("extra_qte_config");
    if ( @$listref ) {
        $args .= " ".join(" ", @$listref);
    }
    opt("qte_config") = $args;
}
if ( opt("edition") && !opt("skip_qte") ) {
    # Make sure qconfig-qpe.h is there
    symlink_file("$depotpath/qtopiacore/qconfig-qpe.h", "$qt_depot_path/src/corelib/global/qconfig-qpe.h");
    if ( opt("device") && -e opt("device", "config_path")."/qconfig.h" ) {
        # Make sure qconfig-[device].h is there
        symlink_file(opt("device", "config_path")."/qconfig.h", "$qt_depot_path/src/corelib/global/qconfig-".opt("device").".h");
    }
    configure_qt($QTEDIR, "Qtopia Core (target)", "qte_config");
}

# Remove these headers so that people don't get into bad habits.
if ( configopt("depot") ) {
    for my $QTDIR ( $qt_depot_path, $DQTDIR, $QTEDIR ) {
        rmrf("$QTDIR/include/Qt");
    }
}

# Some Qtopia-specific file copying
if ( opt("edition") ) {
    mkpath($QPEDIR."/src/libraries/qtopia");
    my $custom;
    if ( opt("device") && -e opt("device", "config_path")."/custom.h" ) {
        $custom = opt("device", "config_path")."/custom";
    } else {
        $custom = "$depotpath/src/libraries/qtopiabase/custom-".opt("xplatform");
    }
    if ( ! -e "$custom.h" || ! -e "$custom.cpp" ) {
        my $err = "";
        if ( opt("device") ) {
            $err .= "WARNING: You should provide custom files in your device profile:\n".
                    "         ".opt("device", "config_path")."/custom.h\n".
                    "         ".opt("device", "config_path")."/custom.cpp\n";
        } else {
            $err .= "WARNING: You should create a device profile with custom files:\n".
                    "         $depotpath/devices/<mydevice>/custom.h\n".
                    "         $depotpath/devices/<mydevice>/custom.cpp\n";
        }
        $err .=     "Using generic files instead.\n\n";
        warn $err;
        $custom = "$depotpath/src/libraries/qtopiabase/custom-linux-generic-g++";
    }
    if ( ! -e "$custom.h" || ! -e "$custom.cpp" ) {
        my $err =   "ERROR: You must provide custom files in the following locations:\n";
        if ( opt("device") ) {
            $err .= "       ".opt("device", "config_path")."/custom.h\n".
                    "       ".opt("device", "config_path")."/custom.cpp\n".
                    "       or\n";
        }
        $err .=     "       $depotpath/src/libraries/qtopiabase/custom-".opt("xplatform").".h\n".
                    "       $depotpath/src/libraries/qtopiabase/custom-".opt("xplatform").".cpp\n";
        die $err;
    }
    symlink_file("$custom.h",   $QPEDIR."/src/libraries/qtopiabase/custom-qtopia.h");
    # Read the file in again so we can put in an include guard
    open IN, "$QPEDIR/src/libraries/qtopiabase/custom-qtopia.h" or die "Can't read $QPEDIR/src/libraries/qtopiabase/custom-qtopia.h";
    my @data = <IN>;
    close IN;
    unshift(@data, "#ifndef QTOPIACUSTOM_H // resolveHeader skip 3\n".
                   "#error \"custom-qtopia.h is not part of the Qtopia API, include <custom.h> instead.\"\n".
                   "#endif\n");
    open OUT, ">$QPEDIR/src/libraries/qtopiabase/custom-qtopia.h" or die "Can't write $QPEDIR/src/libraries/qtopiabase/custom-qtopia.h";
    print OUT @data;
    close OUT;
    symlink_file("$custom.cpp", $QPEDIR."/src/libraries/qtopiabase/custom-qtopia.cpp");
    symlink_file(opt("defaultbuttons"), $QPEDIR."/etc/defaultbuttons.conf");
}

#
# config tests go here
#

Qtopia::Opt::write_config_cache();
system("$qbs_bin/write_config_pri", "tests");

# Check that drmagent is present
if ( opt("edition") && opt("drm") ) {
    print "Testing for Beep Science DRM Agent: ";
    print "\n" if ( opt("verbose") );
    my $out;
    my $ok = configtest("locate_drmagent", "outvar", $out);
    if ( $ok ) {
        $ok = 0;
        my @search_paths;
        for my $ref ( opt("extraLibPaths"), opt("extraRPaths") ) {
            push(@search_paths, @$ref);
        }
        my @lines = split(/\n/, $out);
        @lines = grep(/^libraries:/, @lines);
        if ( @lines ) {
            my $compiler_paths = $lines[0];
            $compiler_paths =~ s/^libraries: =//;
            push(@search_paths, split(/:/, $compiler_paths));
        }
        for my $dir ( @search_paths ) {
            debugMsg("searching $dir\n");
            if ( -f "$dir/libdrmagent.so" ) {
                debugMsg("testing $dir/libdrmagent.so\n");
                open OUT, ">$QPEDIR/config.tests/locate_drmagent.pri" or die "Can't write $QPEDIR/config.tests/locate_drmagent.pri";
                print OUT "DRMAGENT=$dir/libdrmagent.so\n";
                close OUT;
                $ok = configtest("test_drmagent", "outvar", $out);
                my @drmout = split(/\n/, $out);
                for ( @drmout ) {
                    if ( /warning.*libstdc\+\+.*conflict/ ) {
                        # If libstdc++ conflicts, don't use drmagent!
                        $ok = 0;
                        last;
                    }
                }
                last if ( $ok );
            }
        }
    } 
    if ( $ok ) {
        print "OK\n";
    } else {
        print "FAIL\n";
        print "DRM is disabled.\n";
        die_if_not_auto("drm");
        opt("drm", "auto") = 1;
        opt("drm") = 0;
    }
}

if ( opt("error") ) {
    print "Testing for -Werror: ";
    print "\n" if ( opt("verbose") );
    my $ok = configtest("error", "env", "XPLATFORM_ABSOLUTE=".opt("xplatform", "absolute")." ".
                                        "PLATFORM_ABSOLUTE=".opt("platform", "absolute")." ".
                                        "MAKECMD=".opt("make")." QMAKE=$TARGET_QMAKE QPEDIR=$QPEDIR ".
                                        "QTOPIA_DEPOT_PATH=$depotpath FLAG=-Werror");
    if ( $ok ) {
        print "OK\n";
    } else {
        print "FAIL\n";
        print "Use of -Werror is disabled.\n";
        die_if_not_auto("error");
        opt("error", "auto") = 1;
        opt("error") = 0;
    }
}

if ( opt("edition") ) {
    print "Checking for PAGE_SIZE and PAGE_MASK: ";
    print "\n" if ( opt("verbose") );
    my $out;
    my $ret = configtest("page_size", "outvar", $out,
                         "env", "XPLATFORM_ABSOLUTE=".opt("xplatform", "absolute")." ".
                                "PLATFORM_ABSOLUTE=".opt("platform", "absolute")." ".
                                "MAKECMD=".opt("make")." QPEDIR=$QPEDIR QTOPIA_DEPOT_PATH=$depotpath ".
                                "QMAKE=$TARGET_QMAKE VERBOSE=".opt("verbose"));
    if ( $ret ) {
        for ( split(/\n/, $out) ) {
            if ( /page_size=(.*)$/ ) {
                opt("page_size", "page_size") = $1;
            }
            if ( /page_mask=(.*)$/ ) {
                opt("page_size", "page_mask") = $1;
            }
            if ( /kernel=(.*)$/ ) {
                opt("page_size", "kernel") = 1;
            }
        }
    }
    if ( opt("page_size", "page_size") && opt("page_size", "page_mask") ) {
        print "PRESENT";
        if ( opt("page_size", "kernel") ) {
            print " (KERNEL)";
        }
        print "\n";
    } else {
        print "MISSING\n";
        print "WARNING: QSharedMemoryCache will not throw away unused pages\n";
        my $dref = opt("extraDefines");
        push(@$dref, "QTOPIA_NO_PAGE_SIZE_MASK");
    }
}

if ( opt("readline") ) {
    print "Testing for GNU readline: ";
    print "\n" if ( opt("verbose") );
    my $ret = configtest("readline");
    if ( $ret ) {
        print "OK\n";
    } else {
        print "FAIL\n";
        die_if_not_auto("readline");
        opt("readline", "auto") = 1;
        opt("readline") = 0;
    }
}

if ( opt("dbus") ) {
    print "Testing DBUS: ";
    print "\n" if ( opt("verbose") );
    my $out;
    my $ok = configtest("dbus_version", "outvar", $out);
    my $fail = "";
    if ( $ok ) {
        my ( $version, $cflags, $libs ) = split(/\n/, $out);
        my ( $maj, $min ) = ( $version =~ /(\d+)\.(\d+)/ );
        if ( !defined($maj) || !defined($min) ) {
            $fail = "Could not decode version - expecting 0.92 or later, found $version";
            $ok = 0;
        } else {
            if ( $maj >= 1 || ( $maj == 0 && $min >= 92 ) ) {
            } else {
                $ok = 0;
                $fail = "Version must be 0.92 or newer, found $version";
            }
        }
        opt("dbus", "cflags") = $cflags;
        opt("dbus", "libs") = $libs;
    } else {
        $fail = "DBUS could not be found. Check that PKG_CONFIG_PATH is set correctly.";
    }
    if ( $ok ) {
        $ok = configtest("dbus", "env", "DBUS_CFLAGS=\"".opt("dbus", "cflags")."\" DBUS_LIBS=\"".opt("dbus", "libs")."\"");
    }
    if ( $ok ) {
        print "OK\n";
    } else {
        print "FAIL";
        print " ($fail)" if ( $fail );
        print "\n";
        print "DBUS is disabled.\n";
        die_if_not_auto("dbus");
        opt("dbus", "auto") = 1;
        opt("dbus") = 0;
    }
}

if ( opt("bluetooth") ) {
    print "Testing for bluetooth: ";
    print "\n" if ( opt("verbose") );
    my $ok = 1;
    my $reason = "";
    if ( !opt("dbus") ) {
        $ok = 0;
        $reason = "Bluetooth requires DBUS.\n";
    }
    if ( $ok ) {
        $ok = configtest("bluetooth");
    }
    if ( $ok ) {
        print "OK\n";
    } else {
        print "FAIL\n";
        print $reason if ( $reason );
        print "Bluetooth is disabled.\n";
        die_if_not_auto("bluetooth");
        opt("bluetooth", "auto") = 1;
        opt("bluetooth") = 0;
    }
}

if ( opt("vpn") ) {
    print "Testing for VPN: ";
    if ( opt("ssl") ) {
        print "OK\n";
    } else {
        print "FAIL\n";
        print "VPN requires SSL\n";
        die_if_not_auto("vpn");
        opt("vpn", "auto") = 1;
        opt("vpn") = 0;
    }
}

if ( opt("edition") && opt("strict_warnings") ) {
    print "Testing for strict warning flags your compiler accepts:";
    print "\n" if ( opt("verbose") );
    # these are ok to use
    my @test = qw(-Wall -Woverloaded-virtual);
    # one or more of these cause our code to fail
    #push(@test, qw(-Wold-style-cast -pedantic -anso -Wno-long-long -Wshadow -Wunreachable-code -Wundef -Wformat-nonliteral -Wformat-security -Wcast-align -Wchar-subscripts -Wfloat-equal));
    my @flags;
    for ( @test ) {
        my $ok = configtest("error", "env", "XPLATFORM_ABSOLUTE=".opt("xplatform", "absolute")." ".
                                            "PLATFORM_ABSOLUTE=".opt("platform", "absolute")." ".
                                            "MAKECMD=".opt("make")." QMAKE=$TARGET_QMAKE QPEDIR=$QPEDIR ".
                                            "QTOPIA_DEPOT_PATH=$depotpath FLAG=$_");
        if ( $ok ) {
            print " $_";
            push(@flags, $_)
        }
    }
    if ( @flags ) {
        opt("strict_warnings", "flags") = join(" ", @flags);
        print "\n";
    } else {
        print "FAIL\n";
        print "Use of strict warning flags disabled.\n";
        die_if_not_auto("strict_warnings");
        opt("strict_warnings") = 0;
        opt("strict_warnings", "auto") = 1;
    }
}

if ( opt("v4l2") ) {
    print "Testing for V4L2: ";
    print "\n" if ( opt("verbose") );
    my $ok = configtest("v4l2");
    if ( $ok ) {
        print "OK\n";
    } else {
        print "MISSING\n";
        die_if_not_auto("v4l2");
        opt("v4l2", "auto") = 1;
        opt("v4l2") = 0;
    }
}

if ( opt("setproc_method") eq "prctl" ) {
    print "Testing for prctl(): ";
    print "\n" if ( opt("verbose") );
    my $ok = configtest("prctl");
    if ( $ok ) {
        print "OK\n";
    } else {
        print "FAIL\n";
        die_if_not_auto("setproc_method");
        opt("setproc_method", "auto") = 1;
        opt("setproc_method") = "argv0";
    }
}

print_configure_line("Qtopia Platform", "configure $command_line");

opt_print_autodetect();

#
# Handle project roots (src, src/qtopiadesktop and whatever was passed to -build)
#

my @projectRoots;
my $extraBuildPathsRef = opt("extraBuildPaths");
push(@projectRoots, fixpath("$QPEDIR"),
                    fixpath("$QPEDIR/src"),
                    fixpath("$QPEDIR/etc/themes"),
                    fixpath("$QPEDIR/src/qtopiadesktop"),
                    fixpath("$QPEDIR/tests"),
                    fixpath("$QPEDIR/examples"),
                    fixpath("$QPEDIR/src/plugins/designer"));
if ( opt("device") && -d opt("device", "config_path")."/src" && -f opt("device", "config_path")."/src/src.pro" ) {
    push(@$extraBuildPathsRef, opt("device", "config_path")."/src");
}
# Cleanup the locations passed as -build
for my $dir ( @$extraBuildPathsRef ) {
    chdir $cwd; # in case $dir is relative!
    chdir $dir or mkpath($dir); # this lets -build foo work (where $QPEDIR/foo doesn't exist but $depotpath/foo does)
    chdir $dir or die "Can't enter $dir";
    $dir = fixpath(getcwd());
    # Relocate it to the build tree
    $dir =~ s,\Q$depotpath\E,$QPEDIR,;
    my @checkRoots;
    map { push(@checkRoots, $_) unless ( $_ eq $QPEDIR ); } @projectRoots;
    # You can make new project roots under $QPEDIR but not under any of the alread-defined project roots.
    # For example, bad things would happen if you created a new project root in $QPEDIR/src/something.
    my $add = 1;
    for ( @checkRoots ) {
        if ( $dir =~ /^\Q$_\E/ ) {
            $add = 0;
            last;
        }
    }
    if ( $add ) {
        push(@projectRoots, $dir);
    }
}
opt("extraBuildPaths", "projectRoots") = \@projectRoots;

Qtopia::Opt::write_config_cache();
system("$qbs_bin/write_config_pri");

if ( opt("configonly") ) {
    exit 0;
}

system("$QPEDIR/bin/qtopiamake", "-projectroots", @projectRoots);

if ( -d "$QPEDIR/include" ) {
    rmrf("$QPEDIR/include");
}

touch_force_qmake();

if ( opt("qmake") ) {
    print "Running qmake...\n";
    my @dirs = ( $QPEDIR );
    for my $dir ( @dirs ) {
        chdir $dir or die "Can't enter ".fixpath($dir);
        filter_system(opt("make")." first_syncqtopia");
    }
}

my $make = opt("make");
my $prefix = opt("prefix");
my $image = opt("image");
my $config_status = fixpath("$QPEDIR/config.status");

if ( opt("edition") ) {
    print_wrapping_msg( "Qtopia has been configured. You can build Qtopia by running $make.",
                        "After building, you MUST run $make install, which will setup a runnable image in $image. You can override this by running $make install IMAGE=/other/location.",
                        "As configured, Qtopia MUST be run from $prefix. If this is not where you intend to run Qtopia from you should set the location by running configure -prefix /opt/Qtopia.");
    if ( opt("prefix", "auto") && !opt("xplatform", "auto") ) {
        print "WARNING: You have specified -xplatform but not -prefix.\n\n\n";
    }
}
exit 0;

###################################################################

# Helper functions

sub astIf
{
    return $_[0] ? "*" : " ";
}

sub write_config_status
{
    if ( $isWindows ) {
	my $reconf = $QPEDIR."/config.status.bat";
	if ( -f $reconf ) {
	    unlink $reconf or die $!;
	}
	open RECONF, ">".$reconf or die $!;
	print RECONF "\@echo off\n";
	print RECONF "$configure $command_line -confirm-license -no-clean -no-save-options %1 %2 %3 %4 %5 %6 %7 %8 %9\n";
	close RECONF or die $!;
    } else {
        my @paths = ( $QPEDIR );
        if ( $QPEDIR ne $depotpath ) {
            push(@paths, $depotpath);
        }
        for my $outpath ( @paths ) {
            my $reconf = "$outpath/config.status";
            if ( -f $reconf ) {
                unlink $reconf or die $!;
            }
            open RECONF, ">".$reconf or die "Can't write $reconf";
            print RECONF '#!/bin/sh'."\n";
            if ( $QPEDIR ne $depotpath && $outpath eq $depotpath ) {
                print RECONF 'if [ -z "$QTOPIA_BUILD" ]; then'."\n".
                             '    QTOPIA_BUILD=$QTOPIA_BUILD_TREE'."\n".
                             'fi'."\n".
                             'if [ -z "$QTOPIA_BUILD" ]; then'."\n".
                             '    QTOPIA_BUILD=$QPEDIR'."\n".
                             'fi'."\n".
                             'if [ -z "$QTOPIA_BUILD" ]; then'."\n".
                             '    echo "ERROR: You must set QTOPIA_BUILD if you want to shadow build."'."\n".
                             '    echo "When this file was created, QTOPIA_BUILD was set to:"'."\n".
                             '    echo "    '.$QPEDIR.'"'."\n".
                             '    exit 1'."\n".
                             'fi'."\n".
                             'if [ "`cd $QTOPIA_BUILD; /bin/pwd | sed \'s/\/$//\'`" != "'.$depotpath.'" ]; then'."\n".
                             '    exec "$QTOPIA_BUILD/config.status" "$@"'."\n".
                             'fi'."\n";
            } else {
                print RECONF <<END;
DEBUG=0
BUILD="$QPEDIR"
SOURCE="$depotpath"
userargs="$command_line"
END
                print RECONF "DEPOT=".(configopt("depot")?"1":"0")."\n";
                print RECONF "MAKE=\"".opt_resolve("make")."\"\n";
                print RECONF <<'END';

log()
{
    if [ "$DEBUG" = 1 ]; then
        echo "$@"
    fi
}

# capture the commandline options
[ -n "$userargs" ] && userargs="${userargs} "
userargs="${userargs}'-no-save-options' '-confirm-license' '-no-clean'"
for word in "$@"; do
    [ -n "$userargs" ] && userargs="${userargs} "
    userargs="${userargs}'$word'"
done

# write out a new args file (if the user arguments are different to the last run)
mkdir -p "$BUILD/src/build/mkconf"
argsfile="$BUILD/src/build/mkconf/userargs"
writeargs=1
if [ -f "$argsfile" ]; then
    prevargs="$(cat "$argsfile")"
    if [ "$prevargs" = "$userargs" ]; then
        writeargs=0
    fi
fi
if [ "$writeargs" = 1 ]; then
    log "Writing arguments $userargs"
    rm -f "$argsfile"
    echo "$userargs" > "$argsfile"
else
    log "Using the same arguments as last time ($userargs)"
fi

# FIXME should escape all shell/make special characters
escape()
{
    echo "$1" | sed 's/ /\\ /g'
}
SOURCE="$(escape "$SOURCE")"

# start the mkconf process
MAKEARGS="--no-print-directory"
[ "$DEBUG" = 1 ] || MAKEARGS="$MAKEARGS -s"
exec $MAKE $MAKEARGS -C "$BUILD" -f "$SOURCE/src/build/mkconf/configure.mk" "SOURCE=$SOURCE" "DEPOT=$DEPOT"

END
            }
            close RECONF or die $!;
            chmod 0755, $reconf;
        }
        open IN, "$QPEDIR/src/build/mkconf/userargs" or die "Can't read $QPEDIR/src/build/mkconf/userargs";
        my @data = <IN>;
        close IN;
        my $userargs = $data[0];
        chomp($userargs);

        if ( $userargs ne $command_line ) {
            open OUT, ">$QPEDIR/src/build/mkconf/userargs" or die "Can't write $QPEDIR/src/build/mkconf/userargs";
            print OUT "$command_line\n";
            close OUT;
        }
    }
}

sub configure_qt
{
    my ( $QTDIR, $qt, $qt_config ) = @_;
    
    # configure sets the output directory to $PWD
    chdir($QTDIR) or die "Can't enter $QTDIR";

    if ( opt("skip_qt_configure") ) {
        return;
    } else {
        print_configure_line($qt, "configure ".opt($qt_config));
    }

    # Forcibly re-create the include directory. This solves some wierd compile
    # problems caused by the include directory being out of date.
    print "Setting up the include directory for $qt. Please wait...\n";
    rmrf("$QTDIR/include");
    my $qtdir_backup = $ENV{QTDIR} || "";
    $ENV{QTDIR} = $qt_depot_path;
    open IN, "$qt_depot_path/bin/syncqt" or
        open IN, "$qt_depot_path/bin/syncqt.disabled" or
            die "Can't read $qt_depot_path/bin/syncqt";
    my @data = <IN>;
    close IN;
    mkpath("$QPEDIR/src/build/bin");
    unlink("$QPEDIR/src/build/bin/syncqt") if ( -e "$QPEDIR/src/build/bin/syncqt" );
    open OUT, ">$QPEDIR/src/build/bin/syncqt" or die "Can't write $QPEDIR/src/build/bin/syncqt";
    print OUT @data;
    close OUT;
    if ( $isWindows ) {
        # this code assumes that Qt is not built in a shadow
        filter_system(fixpath("$QPEDIR/bin/runsyncqt")." ".fixpath("$QPEDIR/src/build/bin/syncqt"));
    } else {
        filter_system("perl $QPEDIR/src/build/bin/syncqt -outdir $qt_depot_path 2>&1");
        filter_system("perl $QPEDIR/src/build/bin/syncqt -outdir $QTDIR 2>&1");
    }
    fix_qt_headers($qt_depot_path);
    fix_qt_headers($QTDIR);
    $ENV{QTDIR} = $qtdir_backup;

    # Hide some files
    my @hidden_files = qw(projects.pro bin/syncqt);
    # The GPL package has trouble when both Qt and Qtopia Core sources are located in
    # the same directory. Hide this file from Qt so that it doesn't get confused.
    if ( configopt("free") && $QTDIR eq $DQTDIR ) {
        push(@hidden_files, "src/gui/kernel/qapplication_qws.cpp");
    }
    for ( @hidden_files ) {
        if ( -f "$qt_depot_path/$_" ) {
            move("$qt_depot_path/$_", "$qt_depot_path/$_.disabled");
        }
    }

    # Clean out any crap from the build tree.
    # This is especially important for 'Makefile' since Qt does not re-create
    # this file if it exists and it could have stale configuration info in it.
    if ( opt("clean") ) {
        print "Cleaning your $qt build tree. Please wait...\n";
        Qtopia::Opt::write_config_cache();
        system("$QPEDIR/bin/qtopiamake", "-clean", $QTDIR);
    }

    if ( $QTDIR ne $qt_depot_path ) {
        # Qt's config.tests accidentally cache their results. This can have dire consequences
        # if you've changed something about your toolchain or system libs.
        rmrf("$QTDIR/config.tests");
    }

    if ( configopt("depot") && $QTDIR eq $DQTDIR ) {
        # qmake can't figure out it's own dependencies properly. This is a big problem when developing
        # against a changing Qt source tree. For now, just blow it away so we can be sure the binary
        # we build is correct.
        my $makefile = "Makefile";
        my $make = opt("make");
        if ( $isWindows ) {
            $makefile = "Makefile.win32";
            $make = fixpath("$qbs_bin/winmake");
            Qtopia::Opt::write_config_cache();
        }
        eval {
            filter_system("$make -C ".fixpath("$QTDIR/qmake")." -f $makefile clean 2>&1");
        };
    }

    if ( !$isWindows && $QTDIR eq $QTEDIR && $HOST_QT eq $DQTDIR ) {
        # qmake has already been built as part of the host build. Since it uses
        # the same code, we can save time by copying it's .o files in to the target
        # build tree.
        mkpath("$QTDIR/qmake");
        system("cp -f $DQTDIR/qmake/*.o $QTDIR/qmake");
        # The exception to the rule above is this file, which has hardcoded paths
        # specific to the version of Qt being built. Just remove the .o file and
        # let it get rebuilt.
        unlink("$QTDIR/qmake/qlibraryinfo.o");
    }

    # A bug in qmake means that Qtopia Core tests can't find the feature files
    # when we pass a value to -xplatform that isn't in the Qt source tree.
    # Work around it by forcing the correct location to be searched.
    $ENV{QMAKEPATH} = "$qt_depot_path";

    # Go ahead and configure
    my $command = fixpath("$qt_depot_path/configure")." ".opt("$qt_config")." 2>&1";
    if ( $isWindows ) {
        $command = fixpath("$qbs_bin/runwithvars")." PATH=\"".fixpath("$QTDIR/bin").";\%PATH\%\" ".$command;
    }
    filter_system($command, sub {
        return 0 if ( /This is the .* Edition\./ );
        return 0 if ( /Qt is now configured for building/ );
        return 0 if ( /Once everything is built, you must/ );
        return 0 if ( /Qt will be installed into/ );
        return 0 if ( /To reconfigure, run/ );
        return 0 if ( /^\s*[Ff]or .*\.pro/ );
        return 0 if ( /projects\.pro/ );
        return 0 if ( /WARNING: Using static linking will disable the use of dynamically/ );
        return 0 if ( /loaded plugins. Make sure to import all needed static plugins,/ );
        return 0 if ( /or compile needed modules into the library./ );
        return 0 if ( /You have already accepted the terms of the/ );
        return 0 if ( /^failed on dirPath=.*attic\\Makefile/ );
        return 1;
    });

    # Restore the hidden files
    push(@hidden_files, "src/gui/kernel/qapplication_qws.cpp");
    for ( @hidden_files ) {
        if ( -f "$qt_depot_path/$_.disabled" ) {
            move("$qt_depot_path/$_.disabled", "$qt_depot_path/$_");
        }
    }

    # Print a banner
    print '*'x($cols-1)."\n".
          "$qt is configured\n".
          '*'x($cols-1)."\n\n";
}

sub fix_qt_headers
{
    my ( $QTDIR ) = @_;
    # This is as close to a "global" file as Qt gets (I think)
    my $reftime = "$qt_depot_path/src/corelib/global/qglobal.h";
    find( sub {
            my $file = fixpath($File::Find::name);
            if ( ! -f $file ) {
                return;
            }
            my $target;
            my $fname = basename($file);
            if ( $file =~ /headers\.pri$/ || $file =~ /\Q$fname\E\/\Q$fname\E$/ ) {
                $target = $file;
            } else {
                $target = resolveHeader($file);
            }
            if ( $target eq $file ) {
                # Not a "typical" header, just set the times to what $reftime has
                $target = $reftime;
            }
            my $s = stat($target);
            if ( $s ) {
                my $now = $s->mtime;
                utime $now, $now, $file;
            } else {
                die "$target does not exist!";
            }
        }, "$QTDIR/include" );
}

sub filter_system
{
    my ( $cmd, $subref ) = @_;

    my $prog = basename((split(/\s+/, $cmd))[0]);

    if ( exists($Qtopia::Opt::optvar_storage{"verbose"}) && opt("verbose") ) {
        print "filter_system $cmd\n";
        system($cmd);
    } else {
        my $pid = open IN, "$cmd |";
        if ( !defined($pid) ) {
            $? = -1;
        } else {
            my $dosub = ( ref($subref) eq "CODE" );
            if ( $dosub ) {
                while ( defined($_ = <IN>) ) {
                    &$subref() and print;
                }
            } else {
                # this is a quicker way to slurp it up (if we don't care about displaying it)
                my @foo = <IN>;
            }
            close IN;
        }
    }
    my $err = undef;
    if ( $? == -1 ) {
        $err = "Could not execute $prog: $!";
    } elsif ( $?&127 ) {
        $err = "$prog died with signal ".($?&127);
    } elsif ( ($?>>8) != 0 ) {
        $err = "$prog exited with value ".($?>>8);
    }
    if ( $err ) {
        croak $err;
    }
}

# Usage: configtest("test", ...);
# "outvar", $var - stdout goes into the specified variable
# "env", "envstring" - set environment variables
# "platform" - do a host compile insetad of a target compile
# "host_qmake" - use the host qmake (implied by "platform")
# "qmake_only" - run qmake only, don't run make
sub configtest
{
    my $test = shift(@_);
    my $platform = "xplatform";
    my $captureoutput = 0;
    my $verbose = 0;
    my $verbosebackup = undef;
    if ( exists($Qtopia::Opt::optvar_storage{"verbose"}) ) {
        $verbosebackup = opt("verbose");
        $verbose = opt("verbose");
    }
    my $subref = 0;
    my $envstring = undef;
    my $qmake_only = 0;
    my $qmake = $TARGET_QMAKE;
    while ( scalar(@_) != 0 ) {
        if ( $_[0] eq "outvar" ) {
            shift(@_);
            $captureoutput = 1;
            if ( defined($verbosebackup) ) {
                opt("verbose") = 0;
            }
            my $retref = \$_[0];
            $$retref = "";
            $subref = sub {
                $$retref .= $_;
                return $verbose;
            };
            shift(@_);
        } elsif ( $_[0] eq "env" ) {
            shift(@_);
            $envstring = shift(@_);
        } elsif ( $_[0] eq "platform" ) {
            shift(@_);
            $platform = "platform";
            $qmake = $HOST_QMAKE;
        } elsif ( $_[0] eq "host_qmake" ) {
            shift(@_);
            $qmake = $HOST_QMAKE;
        } elsif ( $_[0] eq "qmake_only" ) {
            shift(@_);
            $qmake_only = 1;
        }
    }
    my $source = ("$depotpath/config.tests/$test");
    debugMsg("Running config test $test");
    eval {
        my $command_header = "";
        if ( $envstring ) {
            $command_header .= fixpath("$qbs_bin/runwithvars".($isWindows?"":".sh"))." $envstring ";
        }
        if ( -f "$source.test" ) {
            filter_system($command_header."$source.test", $subref);
        } elsif ( -d "$source" ) {
            if ( $isWindows ) {
                $qmake .= ".exe";
            }
            if ( -f $qmake ) {
                if ( !exists($Qtopia::Opt::optvar_storage{$platform}) ||
                     !exists($Qtopia::Opt::optvar_storage{"make"}) ) {
                    croak "ERROR: configtest() requires opt(\"$platform\") and opt(\"make\")!";
                }
                my $dest = fixpath("$QPEDIR/config.tests/$test");
                mkpath($dest);
                chdir $dest or die "Can't enter $dest";
                open CACHE_FILE, ">$dest/.qmake.cache" or die "Can't write ".fixpath("$dest/.qmake.cache");
                print CACHE_FILE "include($QPEDIR/src/config.pri)\n";
                close CACHE_FILE;
                filter_system($command_header.$qmake." -spec ".fixpath(opt($platform, "absolute"))." -o ".fixpath("$dest/Makefile")." ".fixpath("$source/$test.pro")." 2>&1", $subref);
                if ( !$qmake_only ) {
                    filter_system($command_header.opt("make")." clean >/dev/null 2>&1");
                    filter_system($command_header.opt("make")." 2>&1", $subref);
                }
            } else {
                croak "ERROR: Missing qmake $qmake";
            }
        } else {
            croak "ERROR: Missing test $test";
        }
    };
    if ( defined($verbosebackup) ) {
        opt("verbose") = $verbosebackup;
    }
    # This means that die was called from within the eval block above
    if ( $@ ) {
        debugMsg($@);
        return 0;
    }
    return 1;
}

sub get_system_id_flags
{
    my ( $config_file, $flags, $defines, $outdir ) = @_;

    open IN, "$helix_build_path/build/umakecf/$config_file" or die "Can't read $helix_build_path/build/umakecf/$config_file";
    my @data = <IN>;
    close IN;
    while ( @data ) {
        # collapse lines escaped with a \
        $_ = "";
        do {
            $_ .= shift(@data) or last;
        } while ( s/\\$// );

        # handle indirect includes
        if ( /^exec_config_file\('(.*)'\)/ ) {
            get_system_id_flags($1, $flags, $defines, $outdir);
        }

        # look for -march, -mcpu and -mtune (gcc 4) added to cxx.args
        if ( /^platform\.cxx\.args/ ) {
            if ( /(-march=[^\s"]+)/ ) {
                push(@$flags, $1);
                #print "$1\n";
            }
            if ( /(-mcpu=[^\s"]+)/ ) {
                push(@$flags, $1);
                #print "$1\n";
            }
            if ( opt("compiler", "target_gcc4") && /(-mtune=[^\s"]+)/ ) {
                push(@$flags, $1);
                #print "$1\n";
            }
        }

        # look for defines
        if ( /^project\.AddDefines\(.*,\s*["'](.*)["']\)/ ) {
            push(@$defines, "$1");
            #print "$1\n";
        }

        # look for the output dir
        if ( /project.output_dir.*["'](.*)["']/ ) {
            my $od = $1;
            if ( opt("release") && $od =~ /rel$/ ) {
                $$outdir = $od;
            } 
            if ( !opt("release") && $od =~ /dbg$/ ) {
                $$outdir = $od;
            } 
        }
    }
}

sub getVersions
{
    my ( $qtopiaMajorVersion, $qtopiaMinorVersion, $qtopiaRevVersion );
    my ( $qtMajorVersion, $qtMinorVersion, $qtRevVersion );
    my $verfile = "$depotpath/src/libraries/qtopia/version.h";
    $verfile = "$depotpath/src/libraries/qtopiabase/version.h" unless ( -f $verfile );
    if ( open(IN, "$verfile" ) ) {
        while ( defined($_ = <IN>) ) {
            if ( /QPE_VERSION\s+"(\d+\.\d+\.\d+)"/ ) {
                $qtopiaVersionStr = $1;
                ( $qtopiaMajorVersion, $qtopiaMinorVersion, $qtopiaRevVersion ) = ( $qtopiaVersionStr =~ /(\d+)\.(\d+)\.(\d+)/ );
                last;
            }
        }
        close IN;
    }
    if ( $qtopiaVersionStr eq "0.0.0" ) {
        die "ERROR: Could not read version from ".fixpath("$verfile")."\n";
    }

    if ( open(IN, "$qt_depot_path/src/corelib/global/qglobal.h" ) ) {
        while ( defined($_ = <IN>) ) {
            if ( /QT_VERSION_STR\s+"(\d+\.\d+\.\d+)"/ ) {
                $qtVersionStr = $1;
                ( $qtMajorVersion, $qtMinorVersion, $qtRevVersion ) = ( $qtVersionStr =~ /(\d+)\.(\d+)\.(\d+)/ );
                last;
            }
        }
        close IN;
    }
    if ( $qtVersionStr eq "0.0.0" ) {
        die "ERROR: Could not read version from ".fixpath("$qt_depot_path/src/corelib/global/qglobal.h")."\n";
    }

    if ( ( $build_phone || $build_pda || $build_media || $build_platform )
         && ( $qtMajorVersion != 4 || $qtMinorVersion != 3 ) ) {
        die <<END;
ERROR: Qtopia $qtopiaMajorVersion.$qtopiaMinorVersion is designed to work with Qt 4.3.
       Found Qt $qtMajorVersion.$qtMinorVersion.$qtRevVersion.
END
    }
}

sub clean_qt_sources
{
    my $found = 0;
    for ( ".qmake.cache", "config.status",
          "src/corelib/global/qconfig.cpp",
          "src/corelib/global/qconfig.h",
          "src/corelib/global/qconfig.h.qmake",
          "mkspecs/qconfig.pri" ) {
        my $file = "$qt_depot_path/$_";
        if ( -d $file ) {
            rmrf($file);
            $found = 1;
        } elsif ( -f $file ) {
            unlink $file;
            $found = 1;
        }
    }
    if ( $found ) {
        print "Your Qt source tree has a build in it. This must be removed. Please wait...\n";
        Qtopia::Opt::write_config_cache();
        system("$QPEDIR/bin/qtopiamake", "-clean", $qt_depot_path);
    }
}

sub clean_qtopia_sources
{
    my $found = 0;
    for ( "config.cache",
          "src/3rdparty/tools/bluez/hcid/parser.c",
          "src/3rdparty/tools/bluez/hcid/parser.h",
          "src/3rdparty/tools/bluez/hcid/lexer.c",
          "src/config.pri",
          "src/libraries/qtopiabase/custom-qtopia.h" ) {
        my $file = "$depotpath/$_";
        if ( -d $file ) {
            rmrf($file);
            $found = 1;
        } elsif ( -f $file ) {
            unlink $file;
            $found = 1;
        }
    }
    if ( $found ) {
        print "Your Qtopia source tree has a build in it. This must be removed. Please wait...\n";
        Qtopia::Opt::write_config_cache();
        system("$QPEDIR/bin/qtopiamake", "-clean", $depotpath);
    }
}

sub debugMsg
{
    if ( exists($Qtopia::Opt::optvar_storage{"verbose"}) && opt("verbose") ) {
	print @_;
        my $test = $_[scalar(@_)-1];
        if ( chop $test ne "\n" ) {
            print "\n";
        }
    }
}

my $confline_what;
my $confline_msg;
sub print_configure_line
{
    ( $confline_what, $confline_msg ) = @_;
    format_name STDOUT "CONFLINE";
    write;
}

my $wrapmsg_msg;
sub print_wrapping_msg
{
    print "\n\n";
    format_name STDOUT "WRAPMSG";
    for ( @_ ) {
        $wrapmsg_msg = $_;
        write;
        print "\n";
    }
    print "\n";
}

sub init_formats
{
    my $fmt = "format CONFLINE =\n\n".
              '*'x($cols-1)."\n".
              "Configuring @".'<'x($cols-14)."\n\$confline_what\n".
              "^".'<'x($cols-2)."~~\n\$confline_msg\n".
              '*'x($cols-1)."\n\n.";
    eval $fmt;
    die $@ if ( $@ );

    $fmt = "format WRAPMSG =\n".
              "^".'<'x($cols-2)."~~\n\$wrapmsg_msg\n.";
    eval $fmt;
    die $@ if ( $@ );

    # Only split on spaces, not the - character
    $: = " ";
}

sub symlink_all_files
{
    my ( $dir ) = @_;

    if ( -l "$QPEDIR/$dir" ) {
        unlink "$QPEDIR/$dir";
    }
    mkpath("$QPEDIR/$dir");
    for ( glob("$depotpath/$dir/*") ) {
	my $filename = basename($_, "");
	symlink_file($_, "$QPEDIR/$dir/$filename");
    }
}

sub die_if_not_auto
{
    my ( $optname ) = @_;
    if ( !opt($optname, "auto") ) {
        my $word = opt($optname, "die_if_not_auto");
        if ( !$word ) {
            $word = "option '$optname'";
            my $setref = opt($optname, "set");
            if ( ref($setref) eq "ARRAY" ) {
                my $switch = $setref->[0];
                $switch =~ s/%/$optname/;
                $switch = "-$switch";
                $word = $switch;
            }
        }
        die "ERROR: You requested $word but it was disabled.\n";
    }
}

sub checkLicenseKey
{
    #print "product = $licenseInfo{Product}\n";
    if ( -f "$depotpath/LICENSE.GPL" && configopt("free") ) {
        $licenseInfo{Product} .= " Open Source";
        $licenseInfo{LicenseFile} = "LICENSE.GPL";
        $licenseInfo{DestLicenseFile} = "LICENSE.GPL";
    } elsif ( -f "$depotpath/LICENSE.TROLL" && configopt("depot") ) {
        $licenseInfo{Product} .= " Trolltech Internal";
        $licenseInfo{LicenseFile} = "LICENSE.TROLL";
        $licenseInfo{DestLicenseFile} = "LICENSE.TROLL";
    } else {
        $licenseInfo{DestLicenseFile} = "LICENSE.Qtopia";
        # read in the license file
        my $license = fixpath($ENV{HOME}."/.qt-license");
        if ( -f $license and open IN, $license ) {
            my @data = <IN>;
            close IN;
            for ( @data ) {
                if ( /^([^=]+)="?(.+)"?$/ ) {
                    $licenseInfo{$1} = $2;
                }
            }
            if ( ! $licenseInfo{LicenseKeyExt} ) {
                print <<END;

You are using an old license file.

Please install the license file supplied by Trolltech,
or install the Qtopia Open Source Edition if you intend to
develop free software.
END
                exit 1;
            }
            if ( ! $licenseInfo{Licensee} ) {
                print <<END;

Invalid license key. Please check the license key.
END
                exit 1;
            }
        } else {
            print <<END;

Missing file $license. Please install your license file to proceed
END
            exit 1;
        }

        # Key verification
        if ( ! $licenseInfo{LicenseKeyExt} =~ /(.)....*-(.)...*-(....*)-(.)...*-.....*-.....*-..../ ) {
            print <<END;

Invalid license key. Please check the license key.
END
            exit 1;
        }

        my ( $ProductCode, $PlatformCode, $LicenseTypeCode, $LicenseFeatureCode ) = ( $licenseInfo{LicenseKeyExt} =~ /(.)....*-(.)...*-(....*)-(.)...*-.....*-.....*-..../ );

        my $LicenseType;
        if ( $LicenseTypeCode eq "F4M" ) {
            $LicenseType = "Commercial";
        } elsif ( $LicenseTypeCode eq "Z4M" ||
                  $LicenseTypeCode eq "R4M" ||
                  $LicenseTypeCode eq "Q4M" ) {
            $LicenseType = "Evaluation";
        }
        if ( ! $LicenseType ) {
            print <<END;

Invalid license key. Please check the license key.
END
            exit 1;
        }

        if ( $LicenseFeatureCode eq "G" ) {
            # US
            if ( $LicenseType eq "Commercial" ) {
                copy("$depotpath/.LICENSE-US", "$depotpath/LICENSE");
            } else {
                copy("$depotpath/.LICENSE-EVALUATION-US", "$depotpath/LICENSE");
            }
        } elsif ( $LicenseFeatureCode eq "2" ) {
            # non-US
            if ( $LicenseType eq "Commercial" ) {
                copy("$depotpath/.LICENSE", "$depotpath/LICENSE");
            } else {
                copy("$depotpath/.LICENSE-EVALUATION", "$depotpath/LICENSE");
            }
        } else {
            print <<END;

Invalid license key. Please check the license key.
END
            exit 1;
        }

        if ( ! -f "$depotpath/LICENSE" ) {
            print <<END;

The LICENSE or LICENSE.GPL file shipped with
this software has disappeared.

Sorry, you are not licensed to use this software.
Try re-installing.
END
            exit 1;
        }

        $licenseInfo{Product} = "$licenseInfo{Product} $LicenseType";
        $licenseInfo{LicenseFile} = "LICENSE";
    }

}

sub validateLicense
{
    print "\nThis is the ".$licenseInfo{Product}." Edition.\n\n";
    if ( $licenseInfo{LicenseFile} eq "LICENSE" ) {
        if ( $licenseInfo{ExpiryDate} ) {
            my $ExpiryDate = $licenseInfo{ExpiryDate};
            $ExpiryDate =~ s/-//g;
            chomp $ExpiryDate;
            chomp $ExpiryDate;
            if ( ! $ExpiryDate ) {
                $ExpiryDate = "0";
            }
            my $Today = strftime("%Y%m%d", localtime());
            chop $Today;
            if ( $Today > $ExpiryDate ) {
                print <<END;

WARNING  WARNING  WARNING  WARNING

  Your support and upgrade period has expired.

  You may continue to use your last licensed release
  of Qt under the terms of your existing license
  agreement. But you are not entitled to technical
  support, nor are you entitled to use any more recent
  Qt releases.

  Please contact sales\@trolltech.com to renew your
  support and upgrades for this license.

WARNING  WARNING  WARNING  WARNING

END
                sleep 3;
            }
        }
    }

    if ( $licenseInfo{Product} =~ m/Evaluation/ ) {
        if ( $licenseInfo{LicenseFile} ne "LICENSE.TROLL" ) {
            open IN, "$depotpath/$licenseInfo{LicenseFile}" or die "Can't read $depotpath/$licenseInfo{LicenseFile}";
            my $TheLicense = <IN>;
            close IN;
            chomp $TheLicense;
            chomp $TheLicense;
            while ( 1 ) {
                my $acceptance = "no";
                if ( opt("confirm_license") ) {
                    print "You have already accepted the terms of the $TheLicense.\n";
                    $acceptance = "yes";
                } else {
                    print <<END;
You are licensed to use this software under the terms of
the $TheLicense.

Type '?' to view the $TheLicense.
Type 'yes' to accept this license offer.
Type 'no' to decline this license offer.

END
                    print "Do you accept the terms of the $TheLicense? ";
                    $acceptance = <STDIN>;
                    chomp $acceptance;
                }
                print "\n";
                if ( $acceptance eq "yes" ) {
                    last;
                } elsif ( $acceptance eq "no" ) {
                    print <<END;
You are not licensed to use this software.

END
                    exit 1;
                } elsif ( $acceptance eq "?" ) {
                    system("more $depotpath/".$licenseInfo{LicenseFile});
                }
            }
        }
    } else {
        if ( $licenseInfo{LicenseFile} ne "LICENSE.TROLL" ) {
            while ( 1 ) {
                my $acceptance = "no";
                if ( opt("confirm_license") ) {
                    print "Skipping confirmation of the Qtopia license agreement.\n";
                    $acceptance = "yes";
                } else {
                    if ( $licenseInfo{LicenseFile} eq "LICENSE.GPL" ) {
                        print <<END;
You are licensed to use this software under the terms of the GPL.
Please see the file LICENSE.GPL for the licensing terms.

Type 'yes' to accept this license offer.
Type 'no' to decline this license offer.

END
                        print "Do you accept this license agreement? ";
                    } else {
                        print "------------------------------------------------------------------------\n\n";
                        my $source = fixpath("$depotpath/".$licenseInfo{LicenseFile});
                        open( F, "$source" );
                        print <F>;
                        close( F );
                        print "\n------------------------------------------------------------------------\n";
                        print <<END;

Type 'yes' if you have a Qtopia license agreement that is signed by you and Trolltech.
Type 'no' if you do NOT have a Qtopia license agreement that is signed by you and Trolltech.

END
                        print "Do you have a signed license agreement? ";
                    }
                    $acceptance = <STDIN>;
                    chomp $acceptance;
                }
                print "\n";
                if ( $acceptance eq "yes" ) {
                    last;
                } elsif ( $acceptance eq "no" ) {
                    print <<END;
You are not licensed to use this software.
Please contact sales\@trolltech.com to arrange a license.

END
                    exit 1;
                }
            }
        }
    }
}

sub get_qtopiacore_paths
{
    # Qt/Qtopia Core stuff
    $qt_depot_path = fixpath("$depotpath/qtopiacore/qt");
    if ( configopt("depot") ) {
        $qt_depot_path = fixpath("$QPEDIR/qtopiacore/qt");
    }
    $QTEDIR = fixpath("$QPEDIR/qtopiacore/target");
    $DQTDIR = fixpath("$QPEDIR/qtopiacore/host");

    # Since Windows doesn't support symlinks, we must provide an alternate
    # means to connect the Qtopia and Qt depots together. If "qt" is a file
    # then the first line is used as the path to the Qt depot.
    #
    # For now we assume that only "host" Qt will be built on Windows.
    # Ideally, Qt would support shadow builds on Windows so that both host
    # and target Qt can be built on Windows without copying the Qt source
    # code.
    if ( $isWindows ) {
        if ( -f $qt_depot_path ) {
            open IN, $qt_depot_path or die "Can't read $qt_depot_path";
            chomp($qt_depot_path = <IN>);
            close IN;
        }
        $DQTDIR = $qt_depot_path;
        $QTEDIR = $qt_depot_path;

=pod
        if ( -f $QTEDIR ) {
            open IN, $QTEDIR or die "Can't read $QTEDIR";
            $QTEDIR = <IN>;
            warn "Using $QTEDIR for the target Qt\n";
            close IN;
        } elsif ( ! -d $QTEDIR ) {
            recursive_copy($qt_depot_path, $QTEDIR);
        }
        $qt_depot_path = $QTEDIR;
=cut
    }

    # Check that the Qt source and build trees exist
    chdir($qt_depot_path) or die "ERROR: Missing $qt_depot_path\n";
    chdir($QTEDIR) or mkpath($QTEDIR);
    chdir($DQTDIR) or mkpath($DQTDIR);
    # The paths might be misleading (especially if we're a depot build)
    for ( $qt_depot_path, $QTEDIR, $DQTDIR ) {
        chdir $_ or die "Can't enter $_";
        $_ = fixpath(getcwd());
    }
}

sub get_host_qt
{
    if ( defined($ENV{PATH}) ) {
        DIR: for my $dir ( split(/:/, $ENV{PATH}) ) {
            $HOST_QMAKE = fixpath("$dir/qmake");
            if ( -x $HOST_QMAKE ) {
                if ( open IN, "$HOST_QMAKE -version |" ) {
                    my @data = <IN>;
                    close IN;
                    for ( @data ) {
                        if ( /Qt version (\d+)\.(\d+)\.(\d+)/ ) {
                            my $qt_maj = $1;
                            my $qt_min = $2;
                            my $qt_patch = $3;
                            if ( $qt_maj == 4 && $qt_min >= 2 ) {
                                my $out;
                                my $ok = configtest("host_qt", "env", "QMAKE=$HOST_QMAKE", "outvar", $out);
                                if ( $ok ) {
                                    print "Found Qt $qt_maj.$qt_min.$qt_patch\n";
                                    my ( $QT_PREFIX ) = ( $out =~ /QT_PREFIX=([^\s]+)/ );
                                    my ( $QT_LIBS ) = ( $out =~ /QT_LIBS=([^\s]+)/ );
                                    my ( $QT_BINS ) = ( $out =~ /QT_BINS=([^\s]+)/ );
                                    if ( fixpath($QT_LIBS) ne fixpath("$QT_PREFIX/lib") ) {
                                        print "QT_LIBS $QT_LIBS vs $QT_PREFIX/lib\n";
                                        print "Qtopia does not currently support Qt's libraries being in a location other than PREFIX/lib\n";
                                        $ok = 0;
                                    }
                                    if ( fixpath($QT_BINS) ne fixpath("$QT_PREFIX/bin") ) {
                                        print "QT_BINS $QT_BINS vs $QT_PREFIX/bin\n";
                                        print "Qtopia does not currently support Qt's binaries being in a location other than PREFIX/bin\n";
                                        $ok = 0;
                                    }
                                    next if ( !$ok );
                                    $HOST_QT = $QT_PREFIX;
                                    $HOST_QT_LIBS = $QT_LIBS;
                                    $HOST_QT_BINS = $QT_BINS;
                                    last DIR;
                                }
                            }
                        }
                    }
                }
            }
        }
    }
}

sub touch_force_qmake
{
    mkpath("$QPEDIR/src/build/qt_patch");
    open OUT, ">$QPEDIR/src/build/qt_patch/force_qmake.pri" or die "Can't write $QPEDIR/src/build/qt_patch/force_qmake.pri\n";
    print OUT "# a fake file used to force qmake to be re-run\n";
    close OUT;
}

