#!/usr/bin/perl
use strict;
use warnings;

use File::Glob;
use File::Copy;
use File::Path;
use Cwd;
use File::Basename;
use lib ( dirname($0) );
use Qtopia::Paths;
use Qtopia::Vars;
use Qtopia::File;

Qtopia::Paths::get_paths();

# Windows depot builds use the perl scripts directly rather than the compiled code
if ( $isWindows ) {
    check_script($0, "$depotpath/bin", $ARGV[0]);
}


use constant OUTPUT => 1;
use constant DEBUG => 0;

my @SIZEDIRS = ();

# Turn "en_US ja" into a hash map with each language as a key (easy lookup later)
my %languages = ();
$_ = shift(@ARGV) or usage();
s/^\s+//;
s/\s+$//;
map { $languages{$_}++ } split;
# We MUST install en_US resources because they are used as a fallback
$languages{"en_US"}++;
# Handle non-underscored languages to (eg. 'en')
for my $lang ( keys %languages ) {
    if ( $lang =~ s/_.*// ) {
        $languages{$lang}++;
    }
}

while ($ARGV[0] =~ /^(\d+)(?:x(\d+))?$/ ) {
    push @SIZEDIRS, $1."x".($2||$1);
    shift @ARGV;
}

my $srcdir = shift(@ARGV) || usage();

my $picsSource = undef;
my $picsDest = shift(@ARGV) || usage();
$picsDest =~ s,\\,/,g;

if ( ! @ARGV ) {
    usage();
}

my %pngscale_files;
processFiles( @ARGV );
for my $key ( keys(%pngscale_files) ) {
    my $data = $pngscale_files{$key};
    my @list = @$data;
    system("$QPEDIR/bin/pngscale", split(/\s+/, $key), @list);
}

exit 0;


sub usage
{
    print "Usage:  ".script_name($0)." \"languages\" <size1> ... [sizen] <source dir> <pics dest> <pics>\n";
    exit 2;
}

sub processFiles
{
    my @files = @_;
    foreach my $file ( @files ) {
	$file =~ s,\\,/,g;
        if ( $shadow && $file !~ /^\// ) {
            $file = "$srcdir/$file";
        }
	# Windows doesn't glob. Lets try this again with a glob.
	if ( $file =~ /\*/ ) {
	    processFiles(glob($file));
	    return;
	}
        # skip .ai files because they're huge
        next if ( $file =~ /\.ai$/ );
        if ( $file !~ /\.svg$/ ) {
            my $svgfile = $file;
            $svgfile =~ s/\.[^.]*$/\.svg/;
            if ( -f $svgfile ) {
                # skip 
                DEBUG and print "skipping file $file because $svgfile exists\n";
                next;
            }
        }
	DEBUG and print "processing file $file\n";
	( $picsSource ) = $file =~ /(.*)\/.*/;
        my $oldpwd = getcwd();
        chdir $picsSource;
        my $prevPicsSource = $picsSource;
        $picsSource = getcwd();
        chdir $oldpwd;
	DEBUG and print "picsSource = $picsSource\n";
	my $srcfile = $file;
        $srcfile =~ s,^\Q$prevPicsSource\E,$picsSource,;
	DEBUG and print "picsDest = $picsDest\n";
	my $dest = "$picsDest/$srcfile";
	DEBUG and print "dest = $dest\n";
	if ( $picsSource ) {
	    $dest =~ s,$picsSource/,,;
        }
	DEBUG and print "after munging dest = $dest\n";
	installpic($srcfile, $dest);
    }
}

sub installpic
{
    my ( $srcfile, $dest ) = @_;

    if ( ! -d $srcfile ) {
        # skip .ai files because they're huge
        return if ( $srcfile =~ /\.ai$/ );
	DEBUG and print "installing picture $srcfile\n";
	if ( ! -d dirname($dest) ) {
	    OUTPUT and print "mkdir ".dirname($dest)."\n";
	    mkpath(dirname($dest));
	}
	if ( needCopy($srcfile, $dest) ) {
	    OUTPUT and print "install -c $srcfile $dest\n";
	    copy($srcfile, $dest);
	}
	return;
    }

    if ( -l $srcfile ) {
        warn "Skipping link file $srcfile\n";
        return;
    }

    DEBUG and print "installing dir $srcfile\n";
    if ( ! -d $dest ) {
	mkpath($dest);
    }
    OUTPUT and print "copyallpics $srcfile $dest\n";
    copyallpics($srcfile, $dest);

}

sub installicons
{
    my ( $srcdir, $dest, $width, $height ) = @_;
    return unless ( -d $srcdir );
    mkpath($dest) unless ( -d $dest );

    chdir($srcdir);
    opendir(ICONDIR, "$srcdir") or die "Could not open icon dir $srcdir: $!";
    my @allicondirs = grep { /^\d+x\d+$/ || /^scalable$/; } readdir ICONDIR;
    closedir ICONDIR;

    # try to pick icons closest to the dest size.
    my %iconinfo;
    foreach my $icondir ( @allicondirs ) {
	# should be either one twice the size, or the next biggest from the size given.
	# for now, just the next biggest form the size given.
	if ( -d $icondir ) {
	    opendir(ICONDIR, "$icondir") or die "Could not open icon dir $srcdir/$icondir: $!";
	    my @maybeicons = readdir ICONDIR;
	    closedir ICONDIR;
	    my ( $nwidth, $nheight ) = ( $icondir =~ /(\d+)x(\d+)/ );
            my $nscalable = ( $icondir eq "scalable" );

            my @allicons;
	    foreach my $icon ( @maybeicons ) {
                # skip .ai files because they're huge
                next if ( $icon =~ /\.ai$/ );
                # We install files here as well as files in i18n/<lang>
                if ( -f "$icondir/$icon" ) {
                    push(@allicons, $icon);
                } elsif ( -d "$icondir/$icon" && "$icondir/$icon" =~ m{/i18n$} ) {
                    for my $lang ( keys %languages ) {
                        if ( -d "$icondir/$icon/$lang" ) {
                            mkpath("$dest/$icon/$lang");
                            for my $file ( glob("$icondir/$icon/$lang/*") ) {
                                # skip .ai files because they're huge
                                next if ( $file =~ /\.ai$/ );
                                if ( -f $file ) {
                                    # strip this bit off
                                    $file =~ s/^\Q$icondir\E\///;
                                    push(@allicons, $file);
                                }
                            }
                        }
                    }
                }
            }
	    foreach my $iconfile ( @allicons ) {
                my $icon = $iconfile;
                # strip the extension
                $icon =~ s/\.[^.]+//;
		if (!defined($iconinfo{$icon})) {
                    DEBUG and print "choose $icondir for $icon.  (initial)\n";
		    $iconinfo{$icon} = +{
                        "file" => $iconfile,
                        "dir" => $icondir,
                    };
                } else {
                    my $info = $iconinfo{$icon};
		    my ( $cwidth, $cheight ) = ( $info->{dir} =~ /(\d+)x(\d+)/ );
                    if ( $nscalable ) {
                        # scalable icons are always preferred
                        DEBUG and print "choose $icondir over $info->{dir} for $icon.  (scalable)\n";
                        $info->{file} = $iconfile;
                        $info->{dir} = $icondir;
                    } elsif ($cheight < $height && $cwidth < $width) {
			# if it's bigger, use it
			if ($nheight > $cheight && $nwidth > $cwidth) {
			    DEBUG and print "choose $icondir over $info->{dir} for $icon.  (bigger)\n";
                            $info->{file} = $iconfile;
                            $info->{dir} = $icondir;
			}
		    } else {
			# current is larger or equal to match.
			# if it's smaller, but still bigger than the target height, use it
			if ($nheight < $cheight && $nwidth < $cwidth 
			    && $nheight >= $height && $nwidth >= $width) {
			    DEBUG and print "choose $icondir over $info->{dir} for $icon.  (closer)\n";
                            $info->{file} = $iconfile;
                            $info->{dir} = $icondir;
			}
		    }
		}
	    }
	}
    }

    my $key = "-width $width -height $height";
    my @files;
    if ( exists($pngscale_files{$key}) ) {
        my $data = $pngscale_files{$key};
        @files = @$data;
    }
    foreach my $icon ( keys %iconinfo ) {
        my $info = $iconinfo{$icon};
        my $file = $info->{file};
        my $dir = $info->{dir};
	my $from = "$srcdir/$dir/$file";
        my $to = basename($from);
        if ( $from =~ m{/i18n/} ) {
            $to =~ s{^.*/(i18n/)}{$1};
        }
        $to =~ s{\d+x\d+/}{};
        $to = "$dest/$to";
	if (-f $from) {
            if ( $dir eq "scalable" ) {
                DEBUG and print "Skipping $to because there's a scalable version.\n";
            } elsif ( needCopy($from, $to) ) {
		OUTPUT and print "Generate $to from $from\n";
                push(@files, $from, $to);
            }
        }
    }
    $pngscale_files{$key} = \@files;
}

sub copyallpics
{
    # Handles "icons" directories specially.

    my ( $srcfile, $dest ) = @_;
    if ( -f $srcfile ) {
	if ( needCopy($srcfile, $dest) ) {
	    DEBUG and print "copy $srcfile $dest\n";
	    copy($srcfile, $dest);
	}
    } else {
	if ( ! -d $dest ) {
	    DEBUG and print "mkpath $dest\n";
	    mkpath($dest);
	}
	if ( $dest =~ m{/icons$} && $srcfile !~ m{/scalable$} ) {
	    foreach my $size ( @SIZEDIRS ) {
		my ( $width, $height ) = ( $size =~ /(\d+)x(\d+)/ );
		DEBUG and print "installicons $srcfile $dest ($size)\n";
		installicons($srcfile, "$dest", $width, $height);
	    }
            if ( -d "$srcfile/scalable" ) {
                OUTPUT and print "copyallpics $srcfile/scalable $dest\n";
                copyallpics("$srcfile/scalable", "$dest");
            }
	} else {
	    DEBUG and print "glob($srcfile/*)\n";
	    my @maybe_tocp = glob("$srcfile/*");
            my @tocp = ();
            if ( $dest =~ m{/i18n$} ) {
                # Only install i18n files for the selected languages
                foreach my $file ( @maybe_tocp ) {
                    if ( exists($languages{basename($file)}) ) {
                        push(@tocp, $file);
                    }
                }
            } else {
                @tocp = @maybe_tocp;
            }
	    foreach my $file ( @tocp ) {
                # skip .ai files because they're huge
                next if ( $file =~ /\.ai$/ );
                my $picdest = "$dest/".basename($file);
                DEBUG and print "installpic $file $picdest\n";
                    installpic($file, $picdest);
	    }
	}
    }
}


