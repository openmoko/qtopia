#!/usr/bin/perl

use strict;
use File::stat;
use File::Glob;
use File::Copy;
use File::Basename;
use File::Path;

use constant OUTPUT => 1;
use constant DEBUG => 0;

# None of this stuff is used although it may provide a speed boost on non-Windows platforms
my $INSTALL_FILE = defined($ENV{'INSTALL_FILE'}) ? $ENV{'INSTALL_FILE'} : "install -c";
my $MKDIR = defined($ENV{'MKDIR'}) ? $ENV{'MKDIR'} : "mkdir -p";
my $COPY = defined($ENV{'COPY'}) ? $ENV{'COPY'} : "cp -f";

my @SIZEDIRS = ();

while ($ARGV[0] =~ /^(\d+)(?:x(\d+))?$/ ) {
    push @SIZEDIRS, $1."x".($2||$1);
    shift @ARGV;
}

if ( scalar(@SIZEDIRS) == 0 ) {
    warn "Sizes should be specified as NUMBERxNUMBER or just NUMBER (same height and width).\n".
         "Separate sizes by whitespace.\n";
    usage();
}

my $picsSource = undef;
my $picsDest = shift(@ARGV) || usage();
$picsDest =~ s,\\,/,g;

if ( ! @ARGV ) {
    usage();
}

processFiles( @ARGV );

exit 0;


sub usage
{
    my $app = $0;
    $app =~ s,.*/(.*),$1,;
    print "Usage:  $app <size1> ... [sizen] <pics dest> <pics>\n";
    exit 2;
}

sub processFiles
{
    my @files = @_;
    foreach my $file ( @files ) {
	$file =~ s,\\,/,g;
	# Windows doesn't glob. Lets try this again with a glob.
	if ( $file =~ /\*/ ) {
	    processFiles(glob($file));
	    return;
	}
	DEBUG and print "processing file $file\n";
	( $picsSource ) = $file =~ /(.*)\/.*/;
	DEBUG and print "picsSource = $picsSource\n";
	my $srcfile = $file;
	DEBUG and print "picsDest = $picsDest\n";
	my $dest = "$picsDest/$srcfile";
	DEBUG and print "dest = $dest\n";
	$dest =~ s,$picsSource/,,;
	DEBUG and print "after munging dest = $dest\n";
	installpic($srcfile, $dest);
    }
}

sub installpic
{
    my ( $srcfile, $dest ) = @_;

    if ( ! -d $srcfile ) {
	DEBUG and print "installing picture $srcfile\n";
	if ( ! -d dirname($dest) ) {
	    OUTPUT and print "$MKDIR dirname($dest)\n";
	    mkpath(dirname($dest));
	}
	if ( needCopy($srcfile, $dest) ) {
	    OUTPUT and print "$INSTALL_FILE $srcfile $dest\n";
	    copy($srcfile, $dest);
	}
	return;
    }

    DEBUG and print "installing dir $srcfile\n";
    if ( ! -d $dest ) {
	mkpath($dest);
    }
    OUTPUT and print "copyallpics $srcfile $dest\n";
    copyallpics($srcfile, $dest);

}

sub installicons {
    my ( $srcdir, $dest, $width, $height ) = @_;
    return unless ( -d $srcdir );
    mkpath($dest) unless ( -d $dest );

    chdir($srcdir);
    opendir(ICONDIR, "$srcdir") or die "Could not open icon dir $srcdir: $!";
    my @allicondirs = grep /^\d+x\d+$/, readdir ICONDIR;
    closedir ICONDIR;

    # try to pick icons closest to the dest size.
    my %iconfiles;
    foreach my $icondir ( @allicondirs ) {
	# should be either one twice the size, or the next biggest from the size given.
	# for now, just the next biggest form the size given.
	if ( -d $icondir ) {
	    opendir(ICONDIR, "$icondir") or die "Could not open icon dir $srcdir/$icondir: $!";
	    my @allicons = readdir ICONDIR;
	    closedir ICONDIR;
	    my ( $nwidth, $nheight ) = ( $icondir =~ /(\d+)x(\d+)/ );

	    foreach my $icon ( @allicons ) {
		next if ( -d $icon );
		if (defined($iconfiles{$icon})) {
		    my ( $cwidth, $cheight ) = ( $iconfiles{$icon} =~ /(\d+)x(\d+)/ );
		    if ($cheight < $height && $cwidth < $width) {
			# if its bigger, use it
			if ($nheight > $cheight && $nwidth > $cwidth) {
			    DEBUG and print "choose $icondir over $iconfiles{$icon} for $icon.  (bigger)\n";
			    $iconfiles{$icon} = $icondir;
			}
		    } else {
			# current is larger or equal to match.
			# if its smaller, but still bigger than the target height, use it
			if ($nheight < $cheight && $nwidth < $cwidth 
			    && $nheight >= $height && $nwidth >= $width) {
			    
			    DEBUG and print "choose $icondir over $iconfiles{$icon} for $icon.  (closer)\n";
			    $iconfiles{$icon} = $icondir;
			}
		    }
		} else {
		    $iconfiles{$icon} = $icondir;
		}
	    }
	}
    }

    foreach my $file ( keys %iconfiles ) {
	my $from = "$srcdir/$iconfiles{$file}/$file";
	my $to = "$dest/".basename($from);
	if ($to ne $from && -f $from && ! -f $to) {
	    if (needCopy($from, $to) ) {
		OUTPUT and print "Generate $to from $from\n";
		system "$ENV{QPEDIR}/bin/pngscale -width $width -height $height" .
			   " \"$from\" \"$to\"";
	    }
	}
    }
}

sub copyallpics
{
    # Handles "icons" directories specially.

    my ( $srcfile, $dest ) = @_;
    if ( -f $srcfile ) {
	if ( needCopy($srcfile, $dest) ) {
	    DEBUG and print "copy $srcfile $dest\n";
	    copy($srcfile, $dest);
	}
    } else {
	if ( ! -d $dest ) {
	    DEBUG and print "mkpath $dest\n";
	    mkpath($dest);
	}
	if ( $dest =~ m{/icons$} ) {
	    foreach my $size ( @SIZEDIRS ) {
		my ( $width, $height ) = ( $size =~ /(\d+)x(\d+)/ );
		DEBUG and print "installicons $srcfile $dest ($size)\n";
		installicons($srcfile, "$dest/$size", $width, $height);
	    }
	} else {
	    DEBUG and print "glob($srcfile/*)\n";
	    my @tocp = glob("$srcfile/*");
	    foreach my $file ( @tocp ) {
		my $picdest = "$dest/".basename($file);
		DEBUG and print "installpic $file $picdest\n";
		installpic($file, $picdest);
	    }
	}
    }
}

sub needCopy
{
    my ( $srcfile, $dest ) = @_;
    my $src_s = stat($srcfile);
    my $dest_s = stat($dest);
    return ( ! -f $srcfile || ! -f $dest || $src_s->mtime > $dest_s->mtime );
}

