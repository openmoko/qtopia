#!/usr/bin/perl
use strict;
use warnings;

use Cwd;
use POSIX qw(uname);
use FileHandle;
use Sys::Hostname;
use File::stat;
use File::Find;
use File::Copy;
use File::Path;
use File::Glob;
use File::Basename;
use lib ( dirname($0)."/bin" );
use Qtopia::Paths;
use Qtopia::Vars;
use Qtopia::Opt;
use Qtopia::File;
use Hash::Ordered;

use constant DEBUG => 0;

# Turn on autoflush (fast pipes)
$| = 1;

Qtopia::Paths::get_paths();

# Windows depot builds use the perl scripts directly rather than the compiled code
if ( $isWindows ) {
    check_script($0, $depotpath, $ARGV[0]);
}

my $cols = $ENV{COLUMNS};
$cols = 80 unless ( $cols );
# Setup the terminal-width-dependant formats;
init_formats();

# Find out where we are (needed for relative path stuff later on)
my $outpath = $QPEDIR;

# Qt/Qtopia Core stuff
$qt_depot_path = fixpath("$depotpath/qtopiacore/qt");
if ( configopt("depot") ) {
    $qt_depot_path = fixpath("$QPEDIR/qtopiacore/qt");
}
$QTEDIR = fixpath("$QPEDIR/qtopiacore/target");
$DQTDIR = fixpath("$QPEDIR/qtopiacore/host");

# Since Windows doesn't support symlinks, we must provide an alternate
# means to connect the Qtopia and Qt depots together. If "qt" is a file
# then the first line is used as the path to the Qt depot.
#
# For now we assume that only "host" Qt will be built on Windows.
# Ideally, Qt would support shadow builds on Windows so that both host
# and target Qt can be built on Windows without copying the Qt source
# code.
if ( $isWindows ) {
    if ( -f $qt_depot_path ) {
        open IN, $qt_depot_path or die "Can not open $qt_depot_path\n";
        chomp($qt_depot_path = <IN>);
        close IN;
    }
    $DQTDIR = $qt_depot_path;
    $QTEDIR = $qt_depot_path;

=pod
    if ( -f $QTEDIR ) {
        open IN, $QTEDIR or die "Can not open $QTEDIR\n";
        $QTEDIR = <IN>;
        warn "Using $QTEDIR for the target Qt\n";
        close IN;
    } elsif ( ! -d $QTEDIR ) {
        recursive_copy($qt_depot_path, $QTEDIR);
    }
    $qt_depot_path = $QTEDIR;
=cut
}

# Check that the Qt source and build trees exist
chdir($qt_depot_path) or die "ERROR: Missing $qt_depot_path\n";
chdir($QTEDIR) or mkpath($QTEDIR);
chdir($DQTDIR) or mkpath($DQTDIR);
# The paths might be misleading (especially if we're a depot build)
for ( $qt_depot_path, $QTEDIR, $DQTDIR ) {
    chdir $_ or die "Can not enter $_\n";
    $_ = fixpath(getcwd());
}

Qtopia::Paths::write_config_cache();

# special early bail-out hook
if ( @ARGV && $ARGV[0] eq "-init-cache" ) {
    exit 0;
}

# Test building a free package from the depot (not a great test but better than nothing)
if ( configopt("depot") ) {
    for ( @ARGV ) {
        if ( $_ eq "-test-free" || $_ eq "-test-free-plus-binaries" ) {
            @Qtopia::Vars::configureoptions = qw(depot free phone);
            if ( ! -e "$depotpath/LICENSE.GPL" ) {
                open OUT, ">$depotpath/LICENSE.GPL" or die "Can not write $depotpath/LICENSE.GPL";
                print OUT "GPL TEST\n";
                close OUT;
            }
            unshift(@ARGV, "-confirm-license");
            last;
        }
    }
}

# Check the license
my %licenseInfo = ();
if ( -f "$depotpath/LICENSE.GPL" && configopt("free") ) {
    $licenseInfo{Product} = "Free";
    $licenseInfo{LicenseFile} = "LICENSE.GPL";
    $licenseInfo{DestLicenseFile} = "LICENSE.GPL";
} elsif ( -f "$depotpath/LICENSE.TROLL" && configopt("depot") ) {
    $licenseInfo{Product} = "Trolltech";
    $licenseInfo{LicenseFile} = "LICENSE.TROLL";
    $licenseInfo{DestLicenseFile} = "LICENSE.TROLL";
} else {
    $licenseInfo{DestLicenseFile} = "LICENSE.Qtopia";
    # read in the license file
    my $license = fixpath($ENV{HOME}."/.qt-license");
    if ( -f $license and open IN, $license ) {
        my @data = <IN>;
        close IN;
        for ( @data ) {
            if ( /^([^=]+)="?(.+)"?$/ ) {
                $licenseInfo{$1} = $2;
            }
        }
        if ( ! $licenseInfo{LicenseKeyExt} ) {
            print <<END;

You are using an old license file.

Please install the license file supplied by Trolltech,
or install the Qtopia Open Source Edition if you intend to
develop free software.
END
            exit 1;
        }
	if ( ! $licenseInfo{Licensee} ) {
            print <<END;

Invalid license key. Please check the license key.
END
	    exit 1;
        }
    } else {
        print <<END;

Missing file $license. Please install your license file to proceed
END
        exit 1;
    }

    # Key verification
    if ( ! $licenseInfo{LicenseKeyExt} =~ /(.)....*-(.)...*-(....*)-(.)...*-.....*-.....*-..../ ) {
        print <<END;

Invalid license key. Please check the license key.
END
        exit 1;
    }

    my ( $ProductCode, $PlatformCode, $LicenseTypeCode, $LicenseFeatureCode ) = ( $licenseInfo{LicenseKeyExt} =~ /(.)....*-(.)...*-(....*)-(.)...*-.....*-.....*-..../ );

    my $LicenseType;
    if ( $LicenseTypeCode eq "F4M" ) {
        $LicenseType = "Commercial";
    } elsif ( $LicenseTypeCode eq "Z4M" ||
              $LicenseTypeCode eq "R4M" ||
              $LicenseTypeCode eq "Q4M" ) {
        $LicenseType = "Evaluation";
    }
    if ( ! $LicenseType ) {
        print <<END;

Invalid license key. Please check the license key.
END
        exit 1;
    }

    if ( $LicenseFeatureCode eq "G" ) {
        # US
        if ( $LicenseType eq "Commercial" ) {
            copy("$depotpath/.LICENSE-US", "$depotpath/LICENSE");
        } else {
            copy("$depotpath/.LICENSE-EVALUATION-US", "$depotpath/LICENSE");
        }
    } elsif ( $LicenseFeatureCode eq "2" ) {
        # non-US
        if ( $LicenseType eq "Commercial" ) {
            copy("$depotpath/.LICENSE", "$depotpath/LICENSE");
        } else {
            copy("$depotpath/.LICENSE-EVALUATION", "$depotpath/LICENSE");
        }
    } else {
        print <<END;

Invalid license key. Please check the license key.
END
        exit 1;
    }

    if ( ! -f "$depotpath/LICENSE" ) {
        print <<END;

The LICENSE or LICENSE.GPL file shipped with
this software has disappeared.

Sorry, you are not licensed to use this software.
Try re-installing.
END
        exit 1;
    }

    $licenseInfo{Product} = "$LicenseType";
    $licenseInfo{LicenseFile} = "LICENSE";
}

{
    my @products;
    push (@products, "Phone") if ( configopt("phone") );
    push (@products, "Platform") if ( configopt("platform") );
    push (@products, "Media") if ( configopt("media") );
    push (@products, "PDA") if ( configopt("pda") );
    $licenseInfo{Product} .= " Qtopia ".join("/", @products);
}

# Remove any license files left over
if ( !configopt("depot") ) {
    for my $location ( $qt_depot_path ) {
        for my $file ( glob("$location/LICENSE*"), glob("$location/.LICENSE*") ) {
            unlink $file;
        }
        my $source = "$depotpath/".$licenseInfo{LicenseFile};
        my $dest = "$location/".$licenseInfo{DestLicenseFile};
        if ( -f $dest ) {
            unlink $dest;
        }
        copy("$depotpath/".$licenseInfo{LicenseFile}, "$location/".$licenseInfo{DestLicenseFile});
    }
}

# Version stuff
my $qtopiaVersionStr = "0.0.0";
my $qtVersionStr = "0.0.0";
getVersions();

# The $build_ variables limit what you can build
my $build_desktop = configopt("desktop");
my $build_pda = configopt("pda");
my $build_phone = configopt("phone");
my $build_media = configopt("media");
my $build_platform = configopt("platform");
# For now, Windows and Mac OS X cannot build Qtopia
if ( $isWindows || $isMac ) {
    $build_platform = 0;
    $build_pda = 0;
    $build_phone = 0;
    $build_media = 0;
}

# Edition-specific defaults
my %dispsz = ( "phone" => "160-240",
               "pda" => "240-320",
               "media" => "240-320",
               "platform" => "160-800" );

# edition limiters
my $qtopia_visref = sub { $build_platform || $build_pda || $build_phone  || $build_media };
my $qtopia_autoref = sub { opt("edition") };
my $qtopia_nonfree_visref = sub { !configopt("free") && &$qtopia_visref() };
my $qtopia_nonfree_autoref = sub { !configopt("free") && &$qtopia_autoref() };
my $qtopia_nonfree_or_binaries_visref = sub { ( !configopt("free") || opt("phonelibs") ) && &$qtopia_visref() };
my $qtopia_nonfree_or_binaries_autoref = sub { ( !configopt("free") || opt("phonelibs") ) && &$qtopia_autoref() };
my $nonplatform_visref = sub { $build_pda || $build_phone || $build_media };
my $nonplatform_autoref = sub { opt("edition") && opt("edition") ne "platform" };
my $desktop_visref = sub { $build_desktop };
my $desktop_autoref = sub { opt("qtopiadesktop") };

# general build stuff
set_optvar( "help", +{
    "set" => [ "%", "Print help and usage information." ],
    "default" => 0,
});
set_optvar( "verbose", +{
    "set" => [ "%", "Print out extra information while configuring." ],
    "setfunc" => sub {
        # Turn off silent output
        opt("silent", "default") = 0;
        opt("verbose") = 1;
    },
    "value" => 0,
});
set_optvar( "silent", +{
    "set" => [ "%", "Hide compiler commandlines." ],
    "unset" => [ "no-%", "Show compiler commandlines." ],
    "default" => 0,
    "visible" => sub { !$isWindows },
    "config_pri" => "CONFIG+=silent",
});
set_optvar( "release", +{
    "set" => [ "%", "Create a release build." ],
    "unset" => [ "debug", "Create a debug build." ],
    "default" => 1,
    "showauto" => 1,
});
set_optvar( "separate_debug_info", +{
    "set" => [ "%", "Separate debug info into a .debug file." ],
    "unset" => [ "no-%", "Do not separate debug info into a .debug file." ],
    "default" => 0,
    "showauto" => 1,
});
set_optvar( "clean", +{
    "set" => [ "%", "Clean the build tree." ],
    "unset" => [ "no-%", "Do not clean the build tree." ],
    "default" => 1,
    "showauto" => 1,
    "no_keep" => 1,
});
set_optvar( "profile", +{
    "set" => [ "%", "Create a build with profiling." ],
    "unset" => [ "no-%", "Create a build without profiling." ],
    "default" => 0,
    "config_pri" => "CONFIG+=nostrip\n".
                    "QMAKE_CFLAGS+=-pg\n".
                    "QMAKE_CXXFLAGS+=-pg\n".
                    "QMAKE_LFLAGS+=-pg",
});
set_optvar( "reduce_exports", +{
    "set" => [ "%=s", "Reduce symbol exports in Qt/Qtopia Core/Qtopia (requires GCC 4)." ],
    "available" => [ qw(auto yes no) ],
    "default" => "auto",
});
add_separator();
set_optvar( "extraIncPaths", +{
    "set" => [ "I=s", "Add an explicit include path." ],
    "arg" => "dir",
    "type" => '@',
});
set_optvar( "extraLibPaths", +{
    "set" => [ "L=s", "Add Add an explicit library path." ],
    "arg" => "dir",
    "type" => '@',
});
set_optvar( "extraLibs", +{
    "set" => [ "l=s", "Add Add an explicit library." ],
    "arg" => "lib",
    "type" => '@',
});
set_optvar( "extraRPaths", +{
    "set" => [ "R=s", "Add an explicit dynamic library runtime search path." ],
    "arg" => "dir",
    "type" => '@',
});
set_optvar( "extraDefines", +{
    "set" => [ "D=s", "Add an explicit define to the build. Use -D FOO=bar to give it a value." ],
    "arg" => "def",
    "type" => '@',
});
set_optvar( "rpath", +{
    "set" => [ "%", "Set an automatic RPATH (so LD_LIBRARY_PATH is not required to run Qtopia)." ],
    "unset" => [ "no-%", "Do not set an automatic RPATH." ],
    "default" => 1,
    "showauto" => 1,
    "visible" => sub { !$isWindows },
    "config_pri" => [ "!isEmpty(QTOPIA_RPATH):EMBEDDED_RPATH=\$\${QTOPIA_RPATH}%{prefix}",
                      "CONFIG+=enable_rpath" ],
});
add_separator();
set_optvar( "posix_locks", +{
    "set" => [ "%", "Use POSIX file locking." ],
    "unset" => [ "flock-locks", "Use flock() for file locking." ],
    "default" => 1,
    "config_pri" => "DEFINES+=QTOPIA_POSIX_LOCKS",
});
set_optvar( "error", +{
    "set" => [ "%", "Treat warnings as errors when compiling Qtopia (except for code in src/3rdparty)." ],
    "unset" => [ "no-%", "Do not treat warnings as errors." ],
    "default" => 0,
    "config_pri" => "CONFIG+=enable_werror",
});
add_separator();
set_optvar( "device", +{
    "set" => [ "%=s", "Build using a device profile." ],
    "arg" => "device",
    "visible" => $qtopia_visref,
    "autodep" => $qtopia_autoref,
    "available" => sub {
        my @avail;
        map { push(@avail, basename($_)) if ( -d $_ ); } glob("$depotpath/devices/*");
        @avail;
    },
    "config_pri" => [ "device=%", "CONFIG+=build_device", "DEVICE_CONFIG_PATH=%{config_path}" ],
});
set_optvar( "using_device", +{
    "set" => [ "%=s", "hidden" ],
    "setfunc" => sub { opt("using_device") = $_[1]; opt("device") = $_[1]; },
    "visible" => $qtopia_visref,
    "autodep" => $qtopia_autoref,
});
add_note("Using -device may cause many defaults to change.");
add_separator();
set_optvar( "edition", +{
    "set" => [ "%=s", "Build Qtopia <edn> Edition." ],
    "arg" => "edn",
    "available" => [],
    "visible" => $qtopia_visref,
    "default" => 0,
    "showauto" => $qtopia_visref,
    "config_pri" => "QTOPIA_EDITION=%",
});
set_optvar( "qtopiadesktop", +{
    "set" => [ "%", "Build Qtopia Desktop." ],
    "visible" => $desktop_visref,
    "default" => 0,
    "showauto" => $desktop_visref,
    "config_pri" => "CONFIG+=build_qtopiadesktop",
});
add_separator();
set_optvar( "platform", +{
    "set" => [ "%=s",
        "The host platform that you are compiling on. ".
        "If not specified, configure will attempt to autodetect the host." ],
    "arg" => "host",
    "config_pri" => "PLATFORM=%",
});
set_optvar( "xplatform", +{
    "set" => [ "%=s",
        "The target platform that you are compiling for. ".
        "If not specified, configure will attempt to autodetect the target based on the host." ],
    "arg" => "target",
    "visible" => $qtopia_visref,
    "autodep" => $qtopia_autoref,
    "config_pri" => "XPLATFORM=%",
});
set_optvar( "arch", +{
    "set" => [ "%=s", "The CPU family you are building for." ],
    "arg" => "architecture",
    "visible" => $qtopia_visref,
    "autodep" => $qtopia_autoref,
    "config_pri" => "arch=%",
});
set_optvar( "defaultbuttons", +{
    "set" => [ "%=s", "Use <arg> (if you pass a complete path) or \$QTOPIA_DEPOT_PATH/etc/defaultbuttons-<arg>.conf (if you do not pass a complete path)." ],
    "arg" => "arg",
    "visible" => $qtopia_visref,
    "autodep" => $qtopia_autoref,
});
set_optvar( "sdkroot", +{
    "set" => [ "sdk=s", "Set the SDK location to <dir>. Note that you cannot run 'make sdk' with -sdk $QPEDIR." ],
    "arg" => "dir",
    "default" => fixpath("$QPEDIR"),
    "visible" => $qtopia_visref,
    "config_pri" => "QTOPIA_SDKROOT=%",
});
set_optvar( "image", +{
    "set" => [ "%=s", "Set the Qtopia install location to <dir>." ],
    "arg" => "dir",
    "default" => fixpath("$QPEDIR/image"),
    "visible" => $qtopia_visref,
    "showauto" => sub { opt("edition") },
});
set_optvar( "prefix", +{
    "set" => [ "%=s", "Set the runtime location of Qtopia to <dir>." ],
    "arg" => "dir",
    "default" => sub { opt_resolve("image") },
    "visible" => $qtopia_visref,
    "showauto" => sub { opt("edition") },
    "config_pri" => "QTOPIA_PREFIX=%",
});
set_optvar( "dimage", +{
    "set" => [ "%=s", "Set the Qtopia Desktop install location to <dir>." ],
    "arg" => "dir",
    "default" => fixpath("$QPEDIR/dimage"),
    "visible" => $desktop_visref,
    "showauto" => sub { opt("qtopiadesktop") },
});
set_optvar( "dprefix", +{
    "set" => [ "%=s", "Set the runtime location of Qtopia Desktop to <dir>." ],
    "arg" => "dir",
    "default" => sub { opt("dimage") },
    "visible" => $desktop_visref,
    "showauto" => sub { opt("qtopiadesktop") },
    "config_pri" => "QTOPIA_DPREFIX=%",
});
add_separator();
set_optvar( "qvfb", +{
    "set" => [ "%", "Enable QVfb support." ],
    "unset" => [ "no-%", "Disable QVfb support." ],
    "default" => 1,
    "visible" => $qtopia_visref,
    "autodep" => $qtopia_autoref,
    "config_pri" => [ "CONFIG+=enable_qvfb", "(!)DEFINES+=QT_NO_QWS_VFB" ],
});
set_optvar( "launch_method", +{
    "set" => [ "%=s", "Launch applications using the selected method. Please see the documentation for a description of each launch method." ],
    "arg" => "method",
    "available" => [ qw(normal quicklaunch quicklaunchforked) ],
    "default" => "quicklaunch",
    "visible" => $qtopia_visref,
    "autodep" => $qtopia_autoref,
    "showauto" => 1,
    "config_pri" => "LAUNCH_METHOD=%\n".
                    "equals(LAUNCH_METHOD,normal):CONFIG+=no_quicklaunch",
});
set_optvar( "force_quicklaunch", +{
    "set" => [ "%", "Force apps using QTOPIA_MAIN to be quicklaunched. This results in larger binaries but faster launching." ],
    "unset" => [ "no-%", "Do not force apps using QTOPIA_MAIN to be quicklaunched." ],
    "default" => 0,
    "visible" => $qtopia_visref,
    "autodep" => $qtopia_autoref,
    "config_pri" => "CONFIG+=force_quicklaunch",
});
set_optvar( "singleexec", +{
    "set" => [ "%",
        "Qtopia is compiled into a single binary that contains all the libraries, plug-ins and applications. ".
        "This implies -no-sxe." ],
    "unset" => [ "shared",
        "Qtopia is compiled as a collection of libraries, plug-ins and applications." ],
    "default" => 0,
    "visible" => $qtopia_visref,
    "autodep" => $qtopia_autoref,
    "config_pri" => "CONFIG+=enable_singleexec",
});
set_optvar( "languages", +{
    "set" => [ "%=s",
        "Resources (translations, dictionary files, icons) are updated/installed for the specified languages." ],
    "arg" => "lang,lang",
    "type" => "multi-value",
    "available" => sub {
        # Figure out what languages exist
        my @avail;
        map { push(@avail, basename($_)) if ( -f "$_/.directory" ); } glob("$depotpath/i18n/*");
        if ( !@avail ) {
            warn "WARNING: Could not detect any langauges... Assuming that en_US is available.\n";
            push(@avail, "en_US");
        }
        @avail;
    },
    "default" => sub {
        my $def;
        if ( configopt("depot") ) {
            # In the depot, default to en_US, en_SU (for RTL testing), and de
            $def = "en_US en_SU de";
        } else {
            $def = join(" ", Qtopia::Opt::_resolve_to_array(opt("languages", "available")));
        }
        $def;
    },
    "config_pri" => "LANGUAGES=%",
});
set_optvar( "iconsize", +{
    "set" => [ "%=s", "Non-scalable icons are installed at the requested size. ".
                      "Can be a single number (for square icons) or WxH. ".
                      "Images will be scaled from one of the available sizes." ],
    "arg" => "size",
    "available" => sub {
        my @avail;
        map { if ( -d $_ ) { $_ = basename($_); s/x.*//; push(@avail, $_); } } glob("$depotpath/pics/icons/[0-9]*");
        @avail = sort { $a <=> $b } @avail;
        @avail;
    },
    "default" => sub { my @all = Qtopia::Opt::_resolve_to_array(opt("iconsize", "available")); return $all[$#all]; },
    "showauto" => 1,
    "config_pri" => "QTOPIA_ICON_SIZE=%",
});
set_optvar( "image_extension_order", +{
    "set" => [ "%=s", "An image may exist with multiple extensions but only 1 of these will be installed. ".
                      "This list determines the priority of extensions. ".
                      "An image with multiple extensions, none of which appear in this list will have the first ".
                      "(as determined by perl's glob(\"\$file.*\");) extension chosen." ],
    "arg" => "ext,ext",
    "type" => "multi-value",
    "available" => [ "png", "gif", "xpm" ],
    "default" => sub { join(" ", Qtopia::Opt::_resolve_to_array(opt("image_extension_order", "available"))); },
    "showauto" => 1,
    "config_pri" => "IMAGE_EXTENSION_ORDER=%",
});
add_note("You CANNOT force extensions other than .svg to have the highest priority with -image-extension-order.");
set_optvar( "displaysize", +{
    "set" => [ "%=s",
        "Resources (images) suitable for the requested size are installed. ".
        "Size can be a single width and height or a minimum and maximum width and height." ],
    "arg" => "WxH[-WxH]",
    "default" => sub { $dispsz{opt_resolve("edition")} },
    "visible" => $qtopia_visref,
    "autodep" => $qtopia_autoref,
    "showauto" => $qtopia_visref,
    "config_pri" => "QTOPIA_DISP_SIZES=%{codes}\n".
                    "QTOPIA_DISP_WIDTH=%{width}\n".
                    "QTOPIA_DISP_HEIGHT=%{height}",
});
add_separator();
set_optvar( "displayrot", +{
    "set" => [ "%=s",
        "Enables the display to be rotated by the requested <angle> rotations and ".
        "installs the required fonts." ],
    "arg" => "angle,angle",
    "type" => "multi-value",
    "available" => ["0", "90", "180", "270"],
    "default" => "0",
    "visible" => $qtopia_visref,
    "autodep" => $qtopia_autoref,
    "config_pri" => "QTOPIA_DISP_ROTS=%",
});
set_optvar( "auto_i18n_fonts", +{
    "set" => [ "%", "Allow automatic installation of i18n fonts based on the configured language (needed when using -font)." ],
    "unset" => [ "no-%", "Do not automatically install i18n fonts." ],
    "default" => 1,
});
set_optvar( "font", +{
    "set" => [ "%=s", "Install font <fontspec> (defined as \"family:sizes:styles\"). Pass -font multiple times to install multiple fonts." ],
    "arg" => "fontspec",
    "type" => '@',
    "config_pri" => "QTOPIA_FONTS=%{files}",
});
add_note("family is the name of the font.");
add_note("sizes is a list or range. For example, '80,100,120', '80-120', '*'.");
add_note("styles is a list of weights. ".
         "For example: '50,50i,80', '*'.");
add_note("-font is provided to allow finegrained control over the fonts that are installed. ".
         "Using it means that -fontsizes, -fontfamilies and -fontstyles options are ignored. ".
         "This can have severe consequences for i18n");
set_optvar( "fontsizes", +{
    "set" => [ "%=s",
        "Fonts are installed that match the requested sizes. ".
        "Use 'all' to install all available sizes." ],
    "arg" => "size,size",
    "type" => "multi-value",
    "available" => sub {
        my %avail;
        for ( glob("$qt_depot_path/dist/embedded/lib/fonts/*.qpf"), glob("$depotpath/dist/fonts/*.qpf") ) {
            my $size;
            if ( /(.*)_(\d+)_(\d+i?)\.qpf/ ) {
                $size = $2;
            } elsif ( /(.*)_(\d+)_(\d+i?)_(t\d+)\.qpf/) {
                $size = $2;
            }
            if ( $size ) {
                $avail{$size}++;
            }
        }
        my @avail = sort { $a <=> $b } keys %avail;
        @avail;
    },
    "default" => sub { join(" ", Qtopia::Opt::_resolve_to_array(opt("fontsizes", "available"))); },
    "visible" => $qtopia_visref,
    "autodep" => $qtopia_autoref,
    "showauto" => $qtopia_visref,
    "config_pri" => "QTOPIA_FONT_SIZES=%",
});
set_optvar( "fontfamilies", +{
    "set" => [ "%=s",
        "Fonts are installed that match the requested families." ],
    "arg" => "family,family",
    "type" => "multi-value",
    "available" => sub {
        my %avail;
        for ( glob("$qt_depot_path/dist/embedded/lib/fonts/*.qpf"), glob("$depotpath/dist/fonts/*.qpf") ) {
            $_ = basename($_);
            my $family;
            if ( /(.*)_(\d+)_(\d+i?)\.qpf/ ) {
                $family = $1;
            } elsif ( /(.*)_(\d+)_(\d+i?)_(t\d+)\.qpf/) {
                $family = $1;
            }
            if ( $family ) {
                $avail{$family}++;
            }
        }
        my @avail = sort keys %avail;
        @avail;
    },
    "visible" => $qtopia_visref,
    "autodep" => $qtopia_autoref,
    "showauto" => $qtopia_visref,
    "config_pri" => "QTOPIA_FONT_FAMILIES=%",
});
set_optvar( "fontstyles", +{
    "set" => [ "%=s",
        "Fonts are installed that match the requested styles. ".
        "The styles are as follows: 50 = normal, 75 = bold, i = italic. ".
        "Italic can be applied to normal or bold (eg. 50i, 75i)." ],
    "arg" => "style,style",
    "type" => "multi-value",
    "available" => sub {
        my %avail;
        for ( glob("$qt_depot_path/dist/embedded/lib/fonts/*.qpf"), glob("$depotpath/dist/fonts/*.qpf") ) {
            my $style;
            if ( /(.*)_(\d+)_(\d+i?)\.qpf/ ) {
                $style = $3;
            } elsif ( /(.*)_(\d+)_(\d+i?)_(t\d+)\.qpf/) {
                $style = $3;
            }
            if ( $style ) {
                $avail{$style}++;
            }
        }
        my @avail = sort keys %avail;
        @avail;
    },
    "default" => sub { join(" ", Qtopia::Opt::_resolve_to_array(opt("fontstyles", "available"))); },
    "visible" => $qtopia_visref,
    "autodep" => $qtopia_autoref,
    "showauto" => $qtopia_visref,
    "config_pri" => "QTOPIA_FONT_STYLES=%",
});
add_note("Unless you have changed the Qtopia Core configuration, fonts must be in .qpf ".
         "format and are searched for in $qt_depot_path/dist/embedded/lib/fonts ".
         "and $depotpath/dist/fonts. ".
         "One file is installed for each combination of family, size, style and rotation. ".
         "Note that fonts may not be available in all styles and sizes.");
add_separator();
set_optvar( "make", +{
    "set" => [ "%=s", "Use <makecmd> when building." ],
    "arg" => "makecmd",
    "default" => ($isWindows?"nmake /nologo":"make"),
});
set_optvar( "extraBuildPaths", +{
    "set" => [ "build=s",
        "Add directory <dir> to the Qtopia build system. ".
        "For example, -build /path/to/myapp will add /path/to/myapp to ".
        "the build system." ],
    "arg" => "dir",
    "type" => '@',
});
add_separator();
set_optvar( "qdoc", +{
    "set" => [ "run-%", "Automatically build class documentation to provide documentation errors and warnings at compile time." ],
    "unset" => [ "no-run-%", "Do not automatically build class documentation." ],
    "default" => 0,
    "visible" => sub { configopt("depot") },
    "config_pri" => "CONFIG+=qdoc",
});
add_separator();
set_optvar( "ssl", +{
    "set" => [ "%", "Enable the use of OpenSSL. This lets qtmail connect over SSL and use SMTP authentication. It also allows communication with Google services." ],
    "setaliases" => [ "qtmail-ssl" ],
    "unset" => [ "no-%", "Disable the use of OpenSSL." ],
    "unsetaliases" => [ "no-qtmail-ssl" ],
    "default" => sub { configopt("depot") && opt_resolve("edition") ne "media" },
    "visible" => $qtopia_visref,
    "autodep" => $qtopia_autoref,
    "config_pri" => "CONFIG+=enable_ssl",
});
set_optvar( "ssl_ciphers", +{
    "set" => [ "%=s", "Use additional ciphers when building OpenSSL. WARNING: These ciphers are patented and should only be enabled if a suitable licensing agreement is in place." ],
    "arg" => "cipher,cipher",
    "type" => "multi-value",
    "available" => [ qw(dsa idea mdc2 rc5) ],
    "default" => "",
    "visible" => $qtopia_visref,
    "autodep" => $qtopia_autoref,
    "config_pri" => [ "SSL_CIPHERS=%",
                      "SSL_DISABLED_CIPHERS=%{available}\nSSL_DISABLED_CIPHERS-=\$\$SSL_CIPHERS" ],
    "qtopiaconfig" => sub {
        my @ret;
        my %disabled;
        map { $disabled{$_}++ } Qtopia::Opt::_resolve_to_array(opt("ssl_ciphers", "available"));
        map { $disabled{$_}-- } split(/ /, opt("ssl_ciphers"));
        for ( keys %disabled ) {
            if ( $disabled{$_} ) {
                push(@ret, "#define OPENSSL_NO_".uc($_));
            }
        }
        @ret;
    },
    "value" => "",
});
set_optvar( "qtopiabase", +{
    "set" => [ "%", "Enable moving most configuration and ipc functionality out of libQtopia, into a smaller libQtopiaBase library to reduce dependencies." ],
    "unset" => [ "no-%", "Disable the libQtopiaBase library." ],
    "default" => 1,
    "visible" => 0,
    "autodep" => $qtopia_autoref,
    "config_pri" => "CONFIG+=enable_qtopiabase",
});
set_optvar( "sxe", +{
    "set" => [ "%", "Enable the Safe Execution Environment so that native third party applications can run safely." ],
    "unset" => [ "no-%", "Disable the Safe Execution Environment." ],
    "default" => 0,
    "visible" => $qtopia_nonfree_visref,
    "autodep" => $qtopia_nonfree_autoref,
    "config_pri" => "CONFIG+=enable_sxe",
});
set_optvar( "sxe_discovery", +{
    "set" => [ "%", "Turn on support for SXE discovery mode so that new policy rules can be tested. ".
                    "To utilise SXE discovery mode you must set the SXE_DISCOVERY_MODE environment variable to 1. ".
                    "WARNING: This option creates a security hole and should only be used when creating new policy rules." ],
    "unset" => [ "no-%", "Turn off support for SXE discovery mode." ],
    "default" => 0,
    "visible" => $qtopia_nonfree_visref,
    "autodep" => $qtopia_nonfree_autoref,
});
set_optvar( "bluetooth", +{
    "set" => [ "%", "Enable Bluetooth." ],
    "setfunc" => sub { opt("bluetooth") = 1; opt("dbus") = 1; },
    "unset" => [ "no-%", "Disable Bluetooth." ],
    "default" => 0,
    "visible" => $qtopia_visref,
    "autodep" => $qtopia_autoref,
    "config_pri" => "CONFIG+=enable_bluetooth",
});
set_optvar( "infrared", +{
    "set" => [ "%", "Enable Infrared." ],
    "unset" => [ "no-%", "Disable Infrared." ],
    "default" => 1,
    "visible" => $qtopia_visref,
    "autodep" => $qtopia_autoref,
    "config_pri" => "CONFIG+=enable_infrared",
});
set_optvar( "dbus", +{
    "set" => [ "%", "Enable DBUS support." ],
    "unset" => [ "no-%", "Disable DBUS support." ],
    "default" => 0,
    "visible" => $qtopia_visref,
    "autodep" => $qtopia_autoref,
    "config_pri" => "CONFIG+=enable_dbus",
});
set_optvar( "dbuspath", +{
    "set" => [ "%=s", "Locate the DBUS build." ],
    "setfunc" => sub { opt("dbuspath") = $_[1]; opt("dbus") = 1; },
    "arg" => "dir",
    "default" => (configopt("depot")?"/usr/local":"/usr"),
    "visible" => $qtopia_visref,
    "autodep" => $qtopia_autoref,
    "config_pri" => "DBUS_PREFIX=%",
    "showauto" => 1,
});
# FIXME: Disable this configuration switch until DBUS IPC support is resurrected
#set_optvar( "dbusipc", +{
#    "set" => [ "%", "Enable DBUS IPC support (instead of QCop)." ],
#    "unset" => [ "no-%", "Disable DBUS IPC support." ],
#    "default" => 0,
#    "visible" => $qtopia_visref,
#    "autodep" => $qtopia_autoref,
#    "config_pri" => "CONFIG+=enable_dbusipc",
#});
set_optvar( "drm", +{
    "set" => [ "%", "Enable support for DRM (Using the Beep Science DRM Agent v2.3)." ],
    "unset" => [ "no-%", "Disable support for DRM." ],
    "default" => 1,
    "visible" => $qtopia_nonfree_visref,
    "autodep" => $qtopia_nonfree_autoref,
    "config_pri" => "CONFIG+=drmagent",
});
set_optvar( "sound_system", +{
    "set" => [ "%=s", "Select the sound system to use. ".
                      "You might need to force OSS if your toolchain has ALSA but your kernel does not." ],
    "arg" => "ss",
    "available" => ["alsa", "oss"],
    "default" => "alsa",
    "visible" => $qtopia_visref,
    "autodep" => $qtopia_autoref,
    "config_pri" => "QTOPIA_SOUND_SYSTEM=%",
    "showauto" => 1,
});

add_separator();
set_optvar( "phonelibs", +{
    "set" => [ "use-phone-libraries", "Use the binary-only Qtopia phone libraries." ],
    "setaliases" => [ "test-free-plus-binaries" ],
    "setfunc" => sub { opt("phonelibs") = 1; opt("test_free") = 1 if configopt("depot"); },
    "unset" => [ "no-phone-libraries", "Do not use the binary-only Qtopia phone libraries." ],
    "value" => 0,
    "default" => 0,
    "config_pri" => "free_package:CONFIG+=free_plus_binaries",
    "visible" => sub { configopt("free") },
    "autodep" => sub { configopt("free") },
});
if ( configopt("free") ) {
    add_note("The presence of the binary-only Qtopia phone libraries cannot be detected until late in the configure ".
             "process. Some options will be disabled if the libraries cannot be found.");
    add_note("The binary-only Qtopia phone libraries must be present in order to build a complete system ".
             "using the GPL source package.");
}
set_optvar( "modem", +{
    "set" => [ "%", "Enable Modem communication." ],
    "unset" => [ "no-%", "Disable Modem communication." ],
    "default" => 1,
    "visible" => $qtopia_nonfree_or_binaries_visref,
    "autodep" => $qtopia_nonfree_or_binaries_autoref,
    "config_pri" => "CONFIG+=enable_modem enable_cell",
});
set_optvar( "phonevendors", +{
    "set" => [ "%=s",
        "Build and install phonevendor plugins." ],
    "arg" => "plugin,plugin",
    "type" => "multi-value",
    "available_device" => sub {
        # Figure out what phonevendor plugins exist
        my @avail;
        if ( opt("device", "config_path") ) {
            map { push(@avail, basename($_)) if ( -f "$_/".basename($_).".pro" ); } glob(opt("device", "config_path")."/src/plugins/phonevendors/*");
        }
        @avail;
    },
    "available_depot" => sub {
        # Figure out what phonevendor plugins exist
        my @avail;
        map { push(@avail, basename($_)) if ( -f "$_/".basename($_).".pro" ); } glob("$depotpath/src/plugins/phonevendors/*");
        @avail;
    },
    "available" => sub {
        # Figure out what phonevendor plugins exist
        my @avail;
        push(@avail, Qtopia::Opt::_resolve_to_array(opt("phonevendors", "available_depot")));
        push(@avail, Qtopia::Opt::_resolve_to_array(opt("phonevendors", "available_device")));
        @avail;
    },
    "default" => sub {
        my $ret;
        if ( opt("device", "config_path") || !configopt("depot") ) {
            $ret = join(" ", Qtopia::Opt::_resolve_to_array(opt("phonevendors", "available_device")));
        } elsif ( configopt("depot") ) {
            $ret = join(" ", Qtopia::Opt::_resolve_to_array(opt("phonevendors", "available")));
        }
        $ret;
    },
    "config_pri" => "PHONEVENDORS=%",
    "visible" => $qtopia_nonfree_visref,
    "autodep" => $qtopia_nonfree_autoref,
});
set_optvar( "multiplexers", +{
    "set" => [ "%=s",
        "Build and install multiplexer plugins." ],
    "arg" => "plugin,plugin",
    "type" => "multi-value",
    "available_device" => sub {
        # Figure out what multiplexer plugins exist
        my @avail;
        if ( opt("device", "config_path") ) {
            map { push(@avail, basename($_)) if ( -f "$_/".basename($_).".pro" ); } glob(opt("device", "config_path")."/src/plugins/multiplexers/*");
        }
        @avail;
    },
    "available_depot" => sub {
        # Figure out what multiplexer plugins exist
        my @avail;
        map { push(@avail, basename($_)) if ( -f "$_/".basename($_).".pro" ); } glob("$depotpath/src/plugins/multiplexers/*");
        @avail;
    },
    "available" => sub {
        # Figure out what multiplexer plugins exist
        my @avail;
        push(@avail, Qtopia::Opt::_resolve_to_array(opt("multiplexers", "available_depot")));
        push(@avail, Qtopia::Opt::_resolve_to_array(opt("multiplexers", "available_device")));
        @avail;
    },
    "default" => sub {
        my $ret;
        if ( opt("device", "config_path") || !configopt("depot") ) {
            $ret = join(" ", Qtopia::Opt::_resolve_to_array(opt("multiplexers", "available_device")));
        } elsif ( configopt("depot") ) {
            $ret = join(" ", Qtopia::Opt::_resolve_to_array(opt("multiplexers", "available")));
        }
        $ret;
    },
    "config_pri" => "MULTIPLEXERS=%",
    "visible" => $qtopia_nonfree_visref,
    "autodep" => $qtopia_nonfree_autoref,
});
set_optvar( "voip", +{
    "set" => [ "%", "Enable VoIP (Voice over IP) communication. Note that the reference SIP agent will not build in singleexec mode." ],
    "setaliases" => [ "enable-voip" ],
    "unset" => [ "no-%", "Disable VoIP communication." ],
    "unsetaliases" => [ "disable-voip" ],
    "default" => configopt("depot"),
    "visible" => $qtopia_nonfree_visref,
    "autodep" => $qtopia_nonfree_autoref,
    "config_pri" => "CONFIG+=enable_voip",
});
add_note("Modem and VoIP communication are not exclusive or mandatory. You can enable one, both or none.");
set_optvar( "sipagent_socket", +{
    "set" => [ "%", "Enable socket-based sipagent implementation." ],
    "unset" => [ "no-%", "Disable socket-based sipagent implementation." ],
    "default" => 0,
    "config_pri" => "CONFIG+=enable_sipagent_socket",
    "visible" => $qtopia_nonfree_visref,
    "autodep" => $qtopia_nonfree_autoref,
});
add_separator();
set_optvar( "vpn", +{
    "set" => [ "%", "Enable VPN (Virtual Private Network) support." ],
    "unset" => [ "no-%", "Disable VPN." ],
    "default" => configopt("depot"),
    "visible" => $qtopia_visref,
    "autodep" => $qtopia_autoref,
    "config_pri" => "CONFIG+=enable_vpn",
});

add_separator();
my $helix_depot_path = "$depotpath/src/3rdparty/libraries/helix/src";
my $helix_build_path = "$QPEDIR/src/3rdparty/libraries/helix/helixbuild";
my $helix_visref = sub { &$nonplatform_visref && -d $helix_depot_path };
my $helix_autoref = sub { &$nonplatform_autoref && -d $helix_depot_path };
set_optvar( "helix", +{
    "set" => [ "%", "Enable the Helix media player. Please read the documentation for instructions on how to enable Helix." ],
    "unset" => [ "no-%", "Disable the Helix media player." ],
    "default" => 1,
    "visible" => $nonplatform_visref,
    "autodep" => $nonplatform_autoref,
    "showauto" => 1,
    "config_pri" => [ "CONFIG+=build_helix\n".
                      "DEFINES+=MEDIA_SERVER",
                      "HELIX_CONFIG=%{atomic} %{alsa}" ],
});
set_optvar( "helix_system_id", +{
    "set" => [ "%=s", "Use SYSTEM_ID when building Helix."],
    "arg" => "SYSTEM_ID",
    "available" => "See ".fixpath("$helix_depot_path/build/umakecf")." or ".
                   fixpath("$depotpath/src/3rdparty/libraries/helix/trolltech/src/build/umakecf").
                   " for suitable values.",
    "visible" => $helix_visref,
    "autodep" => $helix_autoref,
    "silentignore" => 1,
    "config_pri" => "HELIX_SYSTEM_ID=%",
});

add_separator();
set_optvar( "libamr", +{
    "set" => [ "%", "Enable libamr." ],
    "unset" => [ "no-%", "Disable libamr." ],
    "setaliases" => [ "with-libamr" ],
    "unsetaliases" => [ "without-libamr" ],
    "visible" => $nonplatform_visref,
    "autodep" => $nonplatform_autoref,
    "default" => 1,
    "config_pri" => "CONFIG+=build_libamr",
});
set_optvar( "readline", +{
    "set" => [ "%", "Enable GNU readline for vsexplorer." ],
    "unset" => [ "no-%", "Disable GNU readline." ],
    "default" => configopt("depot"),
    "visible" => sub { configopt("depot") && ($build_platform || $build_pda || $build_phone  || $build_media) },
    "autodep" => $qtopia_autoref,
    "config_pri" => "CONFIG+=enable_readline",
});
set_optvar( "test", +{
    "set" => [ "%", "Enable the test framework which provides automated unit (class) and GUI testing functionality." ],
    "unset" => [ "no-%", "Disable the test framework." ],
    "visible" => sub { configopt("depot") && &$qtopia_visref() },
    "autodep" => sub { configopt("depot") && &$qtopia_autoref() },
    "default" => 0,
    "config_pri" => "CONFIG+=qtopiatest",
});
set_optvar( "perftest", +{
    "set" => [ "%", "Enables code based performance testing in Qtopia Core." ],
    "unset" => [ "no-%", "Disable the code based performance testing in Qtopia Core." ],
    "visible" => $qtopia_visref,
    "autodep" => $qtopia_autoref,
    "default" => 0,
    "config_pri" => "CONFIG+=qtopia_performance_test",
});

add_note("Qtopia should not be configured with -test for a final release as it creates a potential security hole.");
set_optvar( "samples", +{
    "set" => [ "enable-%", "Enable server widget samples." ],
    "unset" => [ "no-%", "Disable server widget samples." ],
    "default" => 1,
    "visible" => $qtopia_nonfree_or_binaries_visref,
    "autodep" => $qtopia_nonfree_or_binaries_visref,
    "config_pri" => "CONFIG+=enable_samples",
});

# Platform-specific settings
add_separator();
set_optvar( "kde", +{
    "set" => [ "enable-%",
        "Enable KDE 3.x integration. This requires KDE 3.x headers and libraries to be installed." ],
    "unset" => [ "disable-%", "Disable KDE 3.x integration." ],
    "default" => 0,
    "visible" => sub { !$isWindows && !$isMac && opt_resolve("qtopiadesktop") },
    "config_pri" => "CONFIG+=enable_kde_integration",
});

# Qt passthrough options
add_separator();
set_optvar( "gif", +{
    "set" => [ "%", "Enable GIF support." ],
    "unset" => [ "no-%", "Disable GIF support." ],
    "setaliases" => [ "with-gif" ],
    "unsetaliases" => [ "without-gif" ],
    "default" => 1,
});
set_optvar( "qte_config", +{
    "set" => [ "qtopiacore-config=s", "hidden" ],
    "setaliases" => [ "qte-config=s", "target-qt-config=s" ],
});
set_optvar( "extra_qte_config", +{
    "set" => [ "extra-qtopiacore-config=s", "Add something to the Qt/Embedded configure commandline." ],
    "setaliases" => [ "extra_qte_config=s", "extra-target-qt-config=s" ],
    "arg" => '"-option arg"',
    "type" => '@',
});
set_optvar( "dqt_config", +{
    "set" => [ "qt-config=s", "hidden" ],
    "setaliases" => [ "dqt-config=s", "host-qt-config=s" ],
});
set_optvar( "extra_dqt_config", +{
    "set" => [ "extra-qt-config=s", "Add something to the Qt configure commandline." ],
    "setaliases" => [ "extra-dqt-config=s", "extra-host-qt-config=s" ],
    "type" => '@',
    "arg" => '"-option arg"',
});

# These are the "hidden" options.
set_optvar( "save_options", +{
    "set" => [ "%", "hidden" ],
    "unset" => [ "no-%", "hidden" ],
    "value" => 1,
    "no_keep" => 1,
});
set_optvar( "config", +{
    "set" => [ "%=s", "hidden" ],
    "type" => '@',
});
set_optvar( "skip_qt_configure", +{
    "set" => [ "%", "hidden" ],
});
set_optvar( "skip_qt", +{
    "set" => [ "%", "hidden" ],
    "setfunc" => sub { opt("skip_dqt") = 1; opt("skip_qte") = 1; },
});
set_optvar( "skip_dqt", +{
    "set" => [ "%", "hidden" ],
    "config_pri" => "(!)CONFIG+=build_dqt",
});
set_optvar( "skip_qte", +{
    "set" => [ "%", "hidden" ],
    "config_pri" => "(!)CONFIG+=build_qte",
});
set_optvar( "qmake", +{
    "set" => [ "%", "hidden" ],
    "unset" => [ "no-%", "hidden" ],
    "value" => 1,
    "behaviors" => "",
    "config_pri" => "QMAKE_BEHAVIORS=%{behaviors}",
});
set_optvar( "qmake_debug", +{
    "set" => [ "%", "hidden" ],
});
set_optvar( "confirm_license", +{
    "set" => [ "%", "hidden" ],
    "unset" => [ "no-%", "hidden" ],
    "no_keep" => 1,
});
set_optvar( "test_free", +{
    "set" => [ "%", "hidden" ],
    "visible" => sub { configopt("free") },
    "value" => 0,
});
set_optvar( "config_defaults", +{
    "set" => [ "%=s", "hidden" ],
});
set_optvar( "quick", +{
    "set" => [ "%", "hidden" ],
    "setfunc" => sub { opt("skip_qt_configure") = 1; opt("clean") = 0; },
    "no_keep" => 1,
});
# compatibility option for the QA team
set_optvar( "quicklaunch", +{
    "set" => [ "%", "hidden" ],
    "unset" => [ "no-%", "hidden" ],
    "setfunc" => sub { opt("launch_method") = "quicklaunch"; opt("launch_method", "auto") = 1; },
    "unsetfunc" => sub { opt("launch_method") = "normal"; opt("launch_method", "auto") = 1; },
});

# New (experimental) features. These options should go away as soon as the features are stable.

# placeholders. These aren't switches but the values get propagated via config.cache
set_optvar( "gcc4", +{
    "role" => "placeholder",
});
set_optvar( "version", +{
    "role" => "placeholder",
    "qtopia" => $qtopiaVersionStr,
    "qt" => $qtVersionStr,
});
set_optvar( "storage_conf_file", +{
    "role" => "placeholder",
    "config_pri" => "STORAGE_CONF_FILE=%",
});
set_optvar( "hardware_conf_file", +{
    "role" => "placeholder",
    "config_pri" => "HARDWARE_CONF_FILE=%",
});
set_optvar( "motd_html_file", +{
    "role" => "placeholder",
    "config_pri" => "MOTD_HTML_FILE=%",
});
set_optvar( "page_size", +{
    "role" => "placeholder",
    "config_pri" => [ "QTOPIA_PAGE_SIZE=%{page_size}",
                      "QTOPIA_PAGE_MASK=%{page_mask}" ],
});
set_optvar( "builder", +{
    "role" => "placeholder",
    "value" => (getlogin()?getlogin():"unknown").'@'.(hostname()?hostname():"unknown"),
    "config_pri" => "BUILDER=%",
});
set_optvar( "libqtopiaphone", +{
    "role" => "placeholder",
    "config_pri" => [ "QTOPIA_LIBQTOPIAPHONE=%",
                      "QTOPIA_LIBQTOPIAPHONE_VERSION=%{version}",
                      "QTOPIA_LIBQTOPIAPHONE_MAJOR_VERSION=%{major_version}",
                      "QTOPIA_LIBQTOPIAPHONE_MINOR_VERSION=%{minor_version}" ],
});
set_optvar( "libqtopiaphonemodem", +{
    "role" => "placeholder",
    "config_pri" => [ "QTOPIA_LIBQTOPIAPHONEMODEM=%",
                      "QTOPIA_LIBQTOPIAPHONEMODEM_VERSION=%{version}",
                      "QTOPIA_LIBQTOPIAPHONEMODEM_MAJOR_VERSION=%{major_version}",
                      "QTOPIA_LIBQTOPIAPHONEMODEM_MINOR_VERSION=%{minor_version}" ],
});
set_optvar( "overloaded_virtual", +{
    "role" => "placeholder",
    "value" => 1,
    "config_pri" => "CONFIG+=enable_woverloaded_virtual",
});

# If we are a non-depot or desktop-only package, turn on Qtopia Desktop
#if ( !configopt("depot") || ($build_desktop && !$build_platform && !$build_pda && !$build_phone) ) {
if ( $build_desktop && !$build_platform && !$build_pda && !$build_phone && !$build_media )  {
    opt("qtopiadesktop", "default") = 1;
}

# Setup available editions and the default edition
if ( $build_platform ) {
    my $availref = opt("edition", "available");
    push(@$availref, "platform");
    opt("edition", "default") = "platform";
}
if ( $build_media ) {
    my $availref = opt("edition", "available");
    push(@$availref, "media");
    opt("edition", "default") = "media";
}
if ( $build_pda ) {
    my $availref = opt("edition", "available");
    push(@$availref, "pda");
    opt("edition", "default") = "pda";
}
if ( $build_phone ) {
    my $availref = opt("edition", "available");
    push(@$availref, "phone");
    opt("edition", "default") = "phone";
}

# sxe_discovery defaults to on when built from the depot (a convenience thing for Qtopia developers)
if ( configopt("depot") ) {
    opt("sxe_discovery", "default") = 1;
}

# Do a sanity check on the opt_ variables
if ( configopt("depot") ) {
    opt_sanity_check();
}

# Save the command line
my $configure;
my $quote;
if ( $isWindows ) {
    $configure = fixpath("$QPEDIR/bin/configure");
    $quote = '"';
} else {
    $configure = fixpath("$depotpath/configure");
    $quote = "'";
}
my @command_line = @ARGV;
# strip out options marked with "no_keep" => 1,
for my $optname ( keys %Qtopia::Opt::optvar_storage ) {
    if ( opt($optname, "no_keep") ) {
        my $setref = opt($optname, "set");
        my $set = $setref?$setref->[0]:"";
        my $unsetref = opt($optname, "unset");
        my $unset = $unsetref?$unsetref->[0]:"";
        for ( $set, $unset ) {
            s/%/$optname/;
            s/_/-/g;
        }
        if ( $set || $unset ) {
            @command_line = grep { (!$set || $_ ne "-$set") && (!$unset || $_ ne "-$unset") } @command_line;
        }
    }
}
my $command_line = (@command_line?$quote:"").join("$quote $quote", @command_line).(@command_line?$quote:"");

# Get options and print help
my @ARGV_SAVE = @ARGV;
my $ok = opt_get_options( "nohelp" );

# config.defaults simplifies configuring and building Qtopia for a specific environment (eg. greenphone SDK)
if ( opt("config_defaults") ) {
    my $configure_changes = opt("config_defaults")."/configure.pl";
    if ( -e $configure_changes ) {
        open IN, "$configure_changes" or die "Cannot open $configure_changes\n";
        eval join("", <IN>) or die "Error while evaluating config.defaults/configure.pl: $!\n$@";
        close IN;
    }
} else {
    my $conf_dir;
    if ( -d "$QPEDIR/config.defaults" ) {
        $conf_dir = "$QPEDIR/config.defaults";
    } elsif ( -d "$depotpath/config.defaults" ) {
        $conf_dir = "$depotpath/config.defaults";
    }
    if ( $conf_dir ) {
        # Write config.status now so that it doesn't have the contents of config.defaults/configure
        if ( opt("save_options") ) {
            write_config_status();
        }
        my $conf = "";
        if ( open IN, "$conf_dir/configure" ) {
            $conf = join(" ", <IN>);
            $conf =~ s/\n//g;
            close IN;
        }
        my $command_line = "$configure '".join("' '", @ARGV_SAVE)."'";
        $command_line .= " -config-defaults '$conf_dir' $conf";
        $command_line .= " -no-save-options";
        exec <<END;
CONFIG_DEFAULTS_PATH="$conf_dir"
[ -f "\$CONFIG_DEFAULTS_PATH/environment" ] && . "\$CONFIG_DEFAULTS_PATH/environment"
cd $cwd && $configure $command_line
END
        die "ERROR: Could not re-run confiure!\n";
    }
}
# Device profiles simplify configuring and building Qtopia
if ( opt("device") ) {
    opt("device", "config_path") = fixpath("$depotpath/devices/".opt("device"));
    if ( ! -e opt("device", "config_path") ) {
        $ok = 0;
    }
    # If the user selected a device, configure might need to be re-run with extra arguments
    if ( $ok && !opt("using_device") ) {
        # Write config.status now so that it has -device foo instead of the replaced line
        if ( opt("save_options") ) {
            write_config_status();
        }
        my $conf = "";
        if ( open IN, opt("device", "config_path")."/configure" ) {
            $conf = join(" ", <IN>);
            $conf =~ s/\n//g;
            close IN;
        }
        my $device = opt("device");
        my $command_line = "$configure ".(@ARGV_SAVE?"'":"").join("' '", @ARGV_SAVE).(@ARGV_SAVE?"'":"");
        $command_line =~ s/'(-device' '\Q$device\E')/'-using$1 $conf/;
        $command_line .= " -no-save-options";
        my $device_config_path = opt("device", "config_path");
        exec <<END;
DEVICE_CONFIG_PATH="$device_config_path"
[ -f "\$DEVICE_CONFIG_PATH/environment" ] && . "\$DEVICE_CONFIG_PATH/environment"
cd $cwd && $configure $command_line
END
        die "ERROR: Could not re-run confiure!\n";
    }
}

if ( !$ok || opt("help") ) {
    Qtopia::Opt::get_help();
}

# Check license stuff
if ( $licenseInfo{LicenseFile} eq "LICENSE.GPL" ) {
    print "\nThis is the Qtopia Open Source Edition.\n\n";
} else {
    print "\nThis is the ".$licenseInfo{Product}." Edition.\n\n";
}
if ( $licenseInfo{LicenseFile} eq "LICENSE" ) {
    if ( $licenseInfo{ExpiryDate} ) {
        my $ExpiryDate = `echo $licenseInfo{ExpiryDate} | sed -e "s,-,,g" | tr -d "\n\r"`;
        chomp $ExpiryDate;
        if ( ! $ExpiryDate ) {
            $ExpiryDate = "0";
        }
        my $Today = `date +%Y%m%d`;
        chop $Today;
        if ( $Today > $ExpiryDate ) {
            print <<END;

WARNING  WARNING  WARNING  WARNING

  Your support and upgrade period has expired.

  You may continue to use your last licensed release
  of Qt under the terms of your existing license
  agreement. But you are not entitled to technical
  support, nor are you entitled to use any more recent
  Qt releases.

  Please contact sales\@trolltech.com to renew your
  support and upgrades for this license.

WARNING  WARNING  WARNING  WARNING

END
            sleep 3;
        }
    }
}

if ( $licenseInfo{Product} =~ m/Evaluation/ ) {
    if ( $licenseInfo{LicenseFile} ne "LICENSE.TROLL" ) {
        my $TheLicense = `head -n 1 $depotpath/$licenseInfo{LicenseFile}`;
        chop $TheLicense;
        while ( 1 ) {
            my $acceptance = "no";
            if ( opt("confirm_license") ) {
                print "You have already accepted the terms of the $TheLicense.\n";
                $acceptance = "yes";
            } else {
                print <<END;
You are licensed to use this software under the terms of
the $TheLicense.

Type '?' to view the $TheLicense.
Type 'yes' to accept this license offer.
Type 'no' to decline this license offer.

END
                print "Do you accept the terms of the $TheLicense? ";
                $acceptance = <STDIN>;
                chomp $acceptance;
            }
            print "\n";
            if ( $acceptance eq "yes" ) {
                last;
            } elsif ( $acceptance eq "no" ) {
                print <<END;
You are not licensed to use this software.

END
                exit 1;
            } elsif ( $acceptance eq "?" ) {
                system("more $depotpath/".$licenseInfo{LicenseFile});
            }
        }
    }
} else {
    if ( $licenseInfo{LicenseFile} ne "LICENSE.TROLL" ) {
        while ( 1 ) {
            my $acceptance = "no";
            if ( opt("confirm_license") ) {
                print "Skipping confirmation of the Qtopia license agreement.\n";
                $acceptance = "yes";
            } else {
                if ( $licenseInfo{LicenseFile} eq "LICENSE.GPL" ) {
                    print <<END;
You are licensed to use this software under the terms of the GPL.
Please see the file LICENSE.GPL for the licensing terms.

Type 'yes' to accept this license offer.
Type 'no' to decline this license offer.

END
                    print "Do you accept this license agreement? ";
                } else {
                    print "------------------------------------------------------------------------\n\n";
                    my $source = fixpath("$depotpath/".$licenseInfo{LicenseFile});
                    open( F, "$source" );
                    print <F>;
                    close( F );
                    print "\n------------------------------------------------------------------------\n";
                    print <<END;

Type 'yes' if you have a Qtopia license agreement that is signed by you and Trolltech.
Type 'no' if you do NOT have a Qtopia license agreement that is signed by you and Trolltech.

END
                    print "Have you signed an license agreement? ";
                }
                $acceptance = <STDIN>;
                chomp $acceptance;
            }
            print "\n";
            if ( $acceptance eq "yes" ) {
                last;
            } elsif ( $acceptance eq "no" ) {
                print <<END;
You are not licensed to use this software.
Please contact sales\@trolltech.com to arrange a license.

END
                exit 1;
            }
        }
    }
}

# Let the user know which locations we're using
print "Qtopia is using the following locations:\n";
print "Qt          SOURCE tree = $qt_depot_path\n";
print "Qt          BUILD  tree = $DQTDIR\n";
print "Qtopia Core SOURCE tree = $qt_depot_path\n";
print "Qtopia Core BUILD  tree = $QTEDIR\n";
print "Qtopia      SOURCE tree = $depotpath\n";
print "Qtopia      BUILD  tree = $QPEDIR\n";

# shadow build checks
if ( $shadow ) {
    if ( $isWindows ) {
	die "ERROR: Shadow builds are not supported on win32\n";
    }
    if ( index( $QPEDIR, fixpath("$depotpath/") ) != -1 ) {
	die "ERROR: You cannot shadow build from inside the source tree\n";
    }

    if ( -f "$depotpath/.shadow_warn" ) {
        unlink "$depotpath/.shadow_warn";
    }

    symlink_all_files("bin");
    symlink_all_files("scripts");

    symlink_all_files("etc");
    unlink("$QPEDIR/etc/defaultbuttons.conf");
    unlink("$QPEDIR/etc/themes");
    mkpath("$QPEDIR/etc/themes");

    mkpath("$QPEDIR/src/build");
    symlink_file($depotpath."/apps",$QPEDIR."/apps");
    symlink_file($depotpath."/doc",$QPEDIR."/doc");
    symlink_file($depotpath."/pics",$QPEDIR."/pics");
    symlink_file($depotpath."/services",$QPEDIR."/services");
    symlink_file($depotpath."/sounds",$QPEDIR."/sounds");
    symlink_file($depotpath."/help",$QPEDIR."/help");
    symlink_file($depotpath."/i18n",$QPEDIR."/i18n");

    # Clean out any builds found in the Qtopia source tree
    clean_qtopia_sources();
} elsif ( ! -f "$depotpath/.shadow_warn" ) {
    if ( open OUT, ">$depotpath/.shadow_warn" ) {
        print OUT "\n";
        close OUT;
    }
    my $dir = basename($depotpath);
    warn <<END;


WARNING: In-source builds are not reliable. You should build from a different
         directory to ensure that you do not run into problems.

         eg.

             cd ..
             mkdir build
             cd build
             ../$dir/configure [options]


Note: This warning will not display again.


END
    sleep 30
}
mkpath("$QPEDIR/lib/host");

# If the user selected Qtopia Desktop but not Qtopia, do not build Qtopia
if ( opt("qtopiadesktop") && !opt("edition") ) {
    opt("edition", "default") = undef;
}
# And vice versa
if ( opt("edition") && !opt("qtopiadesktop") ) {
    opt("qtopiadesktop", "default") = undef;
}

if ( opt("singleexec") ) {
    # There's no point doing "normal" launching in singleexec (no cost for symbol relocations)
    if ( opt_resolve("launch_method") eq "normal" ) {
        opt("launch_method") = "quicklaunch";
        opt("launch_method", "showauto") = 1;
    }

    # Disable sxe (it's pointless)
    opt("sxe") = undef;
    opt("sxe", "default") = undef;
}

# cross-compile defaults
if ( opt("xplatform") ) {
    # QVFb is not useful for a real device
    opt("qvfb", "default") = 0;
}

{
    my $fontref = opt("font");
    if ( @$fontref ) {
        opt("fontsizes", "showauto") = 0;
        opt("fontfamilies", "showauto") = 0;
        opt("fontstyles", "showauto") = 0;
    } else {
        if ( !opt("fontsizes") && !opt("fontfamilies") && !opt("fontstyles") ) {
            # the default fonts
            push(@$fontref, "dejavu:*:*", "dejavu-mono:*:*");
            opt("font", "auto") = 1;
        }
    }
}

if ( opt("font") ) {
    opt("fontsizes", "showauto") = 0;
    opt("fontfamilies", "showauto") = 0;
    opt("fontstyles", "showauto") = 0;
}

# i18n fonts
if ( opt("font") && opt_resolve("auto_i18n_fonts") ) {
    my $fontref = opt("font");
    if ( index(opt_resolve("languages"), "zh_CN") != -1 ) {
        push(@$fontref, "wenquanyi:*:*");
        opt("font", "auto") = 1;
    }
    if ( index(opt_resolve("languages"), "ko") != -1 ||
         index(opt_resolve("languages"), "ar") != -1 ) {
        push(@$fontref, "unifont:*:*");
        opt("font", "auto") = 1;
    }
    if ( index(opt_resolve("languages"), "ja") != -1 ) {
        push(@$fontref, "japanese:*:*");
        opt("font", "auto") = 1;
    }
}

# Apply defaults
opt_apply_defaults("edition", "qtopiadesktop");

# Host detection
if ( !opt("platform") ) {
    opt("platform", "auto") = 1;
    if ( defined($ENV{QMAKESPEC}) && $ENV{QMAKESPEC} ne "" ) {
	opt("platform") = basename($ENV{QMAKESPEC});
	if ( ! -d $qt_depot_path."/mkspecs/".opt("platform") ) {
	    warn "WARNING: Spec ".opt("platform")." could not be found. Attempting autodetection.\n";
	    opt("platform") = undef;
	}
    }
    if ( !opt("platform") ) {
	if ( $^O eq "linux" ) {
	    opt("platform") = "linux-g++";
	} elsif ( $isMac ) {
	    opt("platform") = "macx-g++";
	} else { 
            die <<END;
ERROR: Can not autodetect the host platform. Host = $^O.
Please explicitly set a -platform parameter.
END
	}
    }
}

if ( opt("edition") ) {
    if ( opt("edition") && opt("xplatform") && !defined(opt("qvfb")) ) {
        opt("qvfb", "auto") = 1;
	opt("qvfb") = 0;
    }

    if (!opt("xplatform")) {
        opt("xplatform", "auto") = 1;
	if ( opt("platform") =~ /^([^-]+)-([^-]+)$/ ) {
	    opt("xplatform") = $1."-generic-".$2;
	} else {
	    opt("xplatform") = opt("platform");
	}
    }
    # Allow architecture short-hands
    if ( index(opt("xplatform"), "-") == -1 ) {
        opt("xplatform", "auto") = 1;
	opt("xplatform") = "linux-".opt("xplatform")."-g++";
    }
    if ( !opt("arch") ) {
        opt("arch", "auto") = 1;
	( opt("arch") ) = ( opt("xplatform") =~ /-(.*?)-/ );
    }
    if ( grep { $_ eq opt("arch") } qw(x86 generic) ) {
        opt("arch", "auto") = 1;
        opt("arch") = "i386";
    }
    if ( ! -d "$qt_depot_path/src/corelib/arch/".opt("arch") ) {
        die "ERROR: Architecture ".opt("arch")." is not supported by Qtopia Core.\n".
            "       Please see the documentation for information about porting to a new architecture.\n";
    }
    # Check for defaultbuttons.conf in the device configuration
    if ( !opt("defaultbuttons") && opt("device") && -e opt("device", "config_path")."/defaultbuttons.conf" ) {
        opt("defaultbuttons") = opt("device", "config_path")."/defaultbuttons.conf";
    }
    if ( opt("defaultbuttons") ) {
        chdir $cwd;
        # If we do not have a full path, pick one based on the default location
        if ( ! -f opt("defaultbuttons") ) {
            opt("defaultbuttons") = "$depotpath/etc/defaultbuttons-".opt("defaultbuttons").".conf";
        }
        if ( ! -f opt("defaultbuttons") ) {
            warn "WARNING: Cannot find ".opt("defaultbuttons")."\n";
            opt("defaultbuttons") = undef;
        }
    }
    if ( !opt("defaultbuttons") ) {
        if ( opt("edition") eq "phone" || opt("edition") eq "platform" || opt("edition") eq "media" ) {
            opt("defaultbuttons") = "phone";
        } else {
            opt("defaultbuttons") = "pda";
        }
        # Use the proper path
        opt("defaultbuttons") = "$depotpath/etc/defaultbuttons-".opt("defaultbuttons").".conf";
        warn "Using ".opt("defaultbuttons")."\n";
    }

    # Check for x86_64
    my $x86_64 = 0;
    if ( !$isWindows && !$isMac ) {
        my ( $sysname, $nodename, $release, $version, $machine ) = uname();
        if ( $machine eq "x86_64" ) {
            $x86_64 = 1;
            if ( opt("platform") eq "linux-g++" ) {
                opt("platform") = "linux-g++-32";
                warn "WARNING: Qtopia does not support x86_64. Using -platform ".opt("platform")."\n";
            }
            if ( opt("xplatform") eq "linux-generic-g++" || opt("xplatform") eq "linux-x86-g++" ) {
                opt("xplatform") = "linux-generic-g++-32";
                warn "WARNING: Qtopia does not support x86_64. Using -xplatform ".opt("xplatform")."\n";
            }
        }
        if ( opt("platform") eq "linux-g++-64" ) {
            $x86_64 = 1;
            opt("platform") = "linux-g++-32";
            warn "WARNING: Qtopia does not support x86_64. Using -platform ".opt("platform")."\n";
        }
        if ( opt("xplatform") eq "linux-x86_64-g++" ) {
            $x86_64 = 1;
            opt("xplatform") = "linux-generic-g++-32";
            warn "WARNING: Qtopia does not support x86_64. Using -xplatform ".opt("xplatform")."\n";
        }
    }

    # Check for Storage.conf in the device configuration
    if ( opt("device") && -e opt("device", "config_path")."/Storage.conf" ) {
        opt("storage_conf_file") = fixpath(opt("device", "config_path")."/Storage.conf");
    } elsif ( -e "$depotpath/etc/default/Trolltech/Storage.conf" ) {
        opt("storage_conf_file") = fixpath("$depotpath/etc/default/Trolltech/Storage.conf");
    }

    # Check for Hardware.conf in the device configuration
    if ( opt("device") && -e opt("device", "config_path")."/Hardware.conf" ) {
        opt("hardware_conf_file") = fixpath(opt("device", "config_path")."/Hardware.conf");
    }
    #elsif ( -e "$depotpath/etc/default/Trolltech/Hardware.conf" ) {
    #    opt("hardware_conf_file") = fixpath("$depotpath/etc/default/Trolltech/Hardware.conf");
    #}

    # Check for motd.html in the device configuration
    if ( opt("device") && -e opt("device", "config_path")."/motd.html" ) {
        opt("motd_html_file") = fixpath(opt("device", "config_path")."/motd.html");
    } elsif ( -e "$depotpath/etc/motd.html" ) {
        opt("motd_html_file") = fixpath("$depotpath/etc/motd.html");
    }
}

# Convert platform and xplatform to absolute paths
opt("platform", "absolute") = opt("platform");
opt("xplatform", "absolute") = opt("xplatform");
if ( !defined(opt("xplatform", "absolute")) ) {
    opt("xplatform", "absolute") = "";
}
chdir $cwd;
# The spec file might be inside the device configuration directory
if ( opt("device") && -e opt("device", "config_path")."/mkspecs/".opt("platform") ) {
    opt("platform", "absolute") = opt("device", "config_path")."/mkspecs/".opt("platform");
}
if ( ! -d opt("platform", "absolute") ) {
    opt("platform", "absolute") = "$qt_depot_path/mkspecs/".opt("platform");
}
if ( opt("edition") ) {
    # The spec file might be inside the device configuration directory
    if ( opt("device") && -e opt("device", "config_path")."/mkspecs/qws/".opt("xplatform") ) {
        opt("xplatform", "absolute") = opt("device", "config_path")."/mkspecs/qws/".opt("xplatform");
    }
    if ( ! -d opt("xplatform", "absolute") ) {
        opt("xplatform", "absolute") = "$qt_depot_path/mkspecs/qws/".opt("xplatform");
    }
}
opt("platform", "absolute") = fixpath(opt("platform", "absolute"));
opt("xplatform", "absolute") = fixpath(opt("xplatform", "absolute"));
if ( ! -e opt("platform", "absolute") ) {
    die "ERROR: ".fixpath(opt("platform", "absolute"))." does not exist, check -platform parameter is correct.\n";
}
if ( opt("edition") && ! -e opt("xplatform", "absolute") ) {
    die "ERROR: ".fixpath(opt("xplatform", "absolute"))." does not exist, check -xplatform parameter is correct.\n";
}


# Qt assumes non-absolute paths to -platform and -xplatform and some tests (eg. x86_64
# support) rely on this. If the values are in the Qt depot path then make them relative
# again. This is better than assuming a relative path was passed to our -platform and
# -xplatform arguments.
my $qt_platform = opt("platform", "absolute");
my $qt_xplatform = opt("xplatform", "absolute");
my $qt_mkspecs = fixpath("$qt_depot_path/mkspecs/");
$qt_platform =~ s,^\Q$qt_mkspecs\E,,;
if ( opt("edition") ) {
    $qt_xplatform =~ s,^\Q$qt_mkspecs\E,,;
}

# Don't use a relative prefix!
for my $prefix ( opt("prefix"), opt("dprefix") ) {
    if ( !$prefix ) {
        next;
    }
    my $path = $prefix;
    if ( !$isWindows && index($path, "/") != 0 ) {
        my $old_prefix = $path;
        $prefix = fixpath($cwd."/".$path);
        warn "WARNING: Using $prefix instead of $old_prefix.\n";
    }
}

# set the prefix for the implicit rpath
opt("rpath", "prefix") = fixpath(opt("prefix")."/lib");

# Detect the Beep Science DRM Agent include directory
if ( configopt("depot") && opt("edition") && opt("drm") ) {
    my $drmdir = fixpath("/usr/lib/bscidrm2/include");
    if ( -d $drmdir ) {
        opt("extraIncPaths", "auto") = 1;
        my $ref = opt("extraIncPaths");
        push(@$ref, $drmdir);
    }
}

# Early config tests (needed before we build Qt)
print "\n";
opt("gcc4", "host") = 0;
opt("gcc4", "target") = 0;
my @combinations = ( "host", opt("platform", "absolute"),
                     "target", opt("xplatform", "absolute") );
while ( @combinations ) {
    my $host = shift(@combinations);
    my $plat = shift(@combinations);
    next if ( !$plat );

    # Detect gcc 4
    open IN, "$plat/qmake.conf" or die "Can not open $plat/qmake.conf\n";
    my @data = <IN>;
    close IN;
    my @old = @data;
    @data = ();
    for ( @old ) {
        if ( /include\((.*)\)/ ) {
            chdir $plat;
            open INC, "$1" or die "Can not open $1\n";
            push(@data, <INC>);
            close INC;
        } else {
            push(@data, $_);
        }
    }
    my ( $cxx ) = ( (grep /^QMAKE_CXX\s*\+?=/, @data)[0] =~ /=(.*)/ );
    my ( $cflags ) = ( (grep /^QMAKE_CFLAGS\s*\+?=/, @data)[0] =~ /=(.*)/ );
    my ( $cxxflags ) = ( (grep /^QMAKE_CXXFLAGS\s*\+?=/, @data)[0] =~ /=(.*)/ );
    my ( $lflags ) = ( (grep /^QMAKE_LFLAGS\s*\+?=/, @data)[0] =~ /=(.*)/ );
    for ( $cxx, $cflags, $cxxflags, $lflags ) {
        chomp;
        s/^\s+//;
        s/\s+$//;
    }
    $cxxflags =~ s/\$\$QMAKE_CFLAGS/$cflags/;
    my $envstring = "CXX='$cxx' CXXFLAGS='$cxxflags' LFLAGS='$lflags' QPEDIR='$QPEDIR' QTOPIA_DEPOT_PATH='$depotpath' HOST='$host' VERBOSE='".opt("verbose")."'";

    if ( !$isWindows ) {
        print "Checking the compiler ($host): ";
        print "\n" if ( opt("verbose") );
        my $out;
        my $ret = configtest("compiler", "env", $envstring, "outvar", $out);
        if ( $ret ) {
            if ( grep /^GCC VERSION 4/, split(/\n/, $out)) {
                opt("gcc4", $host) = 1;
            } else {
                opt("gcc4", $host) = 0;
            }
            if ( opt("gcc4", $host) ) {
                print "OK (GCC 4)\n";
            } else {
                print "OK\n";
            }
        } else {
            if ( $out =~ /CANNOT RUN BINARIES/ ) {
                print "FAIL (cannot run binaries)\n";
            } else {
                print "FAIL\n";
            }
            exit 1;
        }
    }
}

if ( opt("sxe") ) {
    # Change 186258 in Qtopia renders SXE impotent unless change
    # 256275/256276/256278 (Qt 4.2/4.3/main) has been applied.
    # The problem is that change 186258 removes the per-app keys,
    # opting for magic in /proc instead. This gains us many things
    # but means that out-of-sync builds will have ALL operations denied.
    #
    # So because SXE has been enabled and because we don't want to
    # produce a build that can't do anything we're going to test that
    # Qt actually contains the required change and warn/die if it's missing.
    my $enable = 0;
    if ( open IN, "$qt_depot_path/src/gui/embedded/qtransportauth_qws.cpp" ) {
        my @data = <IN>;
        close IN;
        my @tmp = grep(/SxeRegistryLocker::SxeRegistryLocker/, @data);
        if ( @tmp ) {
            $enable = 1;
        }
    }
    if ( !$enable ) {
        if ( opt("sxe", "auto") ) {
            warn <<END;
WARNING: SXE cannot be enabled because change 256275 has not been applied to
         Qt. Please apply this change to your Qt sources if you want SXE to
         be enabled.
END
            opt("sxe", "auto") = 1;
            opt("sxe") = 0;
        } else {
            die <<END;
ERROR: SXE cannot be enabled because change 256275 has not been applied to
       Qt. Please apply this change to your Qt sources if you want SXE to
       be enabled.
END
        }
    }
}

# Validate options

if ( opt("edition") ) {
    my $availref = opt("edition", "available");
    if ( !grep { $_ eq opt("edition") } @$availref ) {
        my $edn = $$availref[scalar(@$availref)-1];
	warn "WARNING: Edition '".opt("edition")."' is not supported by this package.\n".
	     "         Using edition '$edn' instead.\n";
        opt("edition") = $edn;
    }

    # TODO Enable this warning for Qtopia 4.3 
    if ( 0 && !opt("singleexec") && !opt("sxe") && configopt("depot") && !configopt("free") ) {
        warn "WARNING: You are building without SXE. This is not a supported configuration!\n";
    }

    # Check that helix exists
    if ( opt("helix") ) {
        print "Testing for helix: ";
        if ( -d $helix_depot_path ) {
            print "PRESENT\n";
        } else {
            print "MISSING\n";
            print "Helix is disabled. Please read the documentation for instructions on how to enable Helix.\n";
            opt("helix", "auto") = 1;
            opt("helix") = 0;
        }
    }
}

if ( opt("kde") && !defined($ENV{KDEDIR}) ) {
    die "ERROR: You must set KDEDIR to the location of your KDE installation.\n";
}

# Apply options
opt("displaysize", "codes") = "";
opt("displaysize", "width") = "";
opt("displaysize", "height") = "";
if ( opt("edition") ) {
    my ($szlo,$szhi);
    my ($szw,$szh);
    if ( ($szw,$szh) = opt("displaysize") =~ m{(\d+)[xX](\d+)} ) {
	$szhi=$szlo=$szw;
	opt("displaysize", "codes").=" X";
	opt("displaysize", "width").=$szw;
	opt("displaysize", "height").=$szh;
    } elsif ( ($szlo,$szhi) = opt("displaysize") =~ m{(\d*)(?:-(\d*))?} ) {
	$szhi=$szlo if !$szhi;
    } else {
	exit 1;
    }
    opt("displaysize", "codes").=" C" if $szlo <= 176;
    opt("displaysize", "codes").=" P" if $szlo <= 240 && 240 <= $szhi;
    opt("displaysize", "codes").=" W" if $szlo <= 640 && 640 <= $szhi;
    opt("displaysize", "codes").=" T" if                 800 <= $szhi;

    mkpath("$QPEDIR/etc/default/Trolltech/");
}

# Fix up the font definitions (easier in perl than in qmake)
if ( opt("font") ) {
    my $fontref = opt("font");
    my @fonts;
    my @files;
    push(@files, glob("$qt_depot_path/dist/embedded/lib/fonts/*.qpf"));
    push(@files, glob("$depotpath/dist/fonts/*.qpf"));
    for my $file ( @files ) {
        DEBUG and print "file $file\n";
        my $filename = basename($file);
        my $family;
        my $size;
        my $style;
        my $rotation;
        if ( $filename =~ /(.*)_(\d+)_(\d+i?)\.qpf/ ) {
            $family = $1;
            $size = $2;
            $style = $3;
        } elsif ( $filename =~ /(.*)_(\d+)_(\d+i?)_(t\d+)\.qpf/) {
            $family = $1;
            $size = $2;
            $style = $3;
            $rotation = $4;
        } else {
            warn "Can not understand the naming of font $file\n";
            next;
        }

        FONTSPEC: for my $fontspec ( @$fontref ) {
            my ( $fsfamily, $sizes, $styles ) = split(/:/, $fontspec);
            my @sizes;
            for ( split(/,/, $sizes) ) {
                if ( /(\d+)-(\d+)/ ) {
                    for ( my $i = $1; $i < $2; $i++ ) {
                        push(@sizes, $i);
                    }
                } else {
                    push(@sizes, $_);
                }
            }
            my @styles = split(/,/, $styles);
            if ( $fsfamily eq $family ) {
                for ( @sizes ) {
                    if ( $_ eq "*" || $size eq $_ ) {
                        for ( @styles ) {
                            if ( $_ eq "*" || $style eq $_ ) {
                                DEBUG and print "FILE $file matches $fontspec\n";
                                push(@fonts, $file);
                                last FONTSPEC;
                            } else {
                                DEBUG and print "$style does not equal $_\n";
                            }
                        }
                    } else {
                        DEBUG and print "$size does not equal $_\n";
                    }
                }
            } else {
                DEBUG and print "$family does not equal $fsfamily\n";
            }
        }
    }
    opt("font", "files") = [ @fonts ];
}

#
# This should be the end of the configuring stuff
#

# Write config.status
if ( opt("save_options") ) {
    write_config_status();
}
if ( $shadow ) {
    # Setup the depot hopping config.status file
    $outpath = $depotpath;
    write_config_status();
    $outpath = $QPEDIR;
}

# Clean out any builds found in the Qt source tree
if ( $qt_depot_path ne $DQTDIR ) {
    clean_qt_sources();
}

# Configure Qt
if ( !opt("dqt_config") ) {
    my $args = "-platform $qt_platform -prefix ".fixpath(opt("sdkroot")."/qtopiacore/host")." ".
               "-no-stl -no-exceptions -no-qdbus ".
               "-D QTOPIA_NO_ICONV_OPEN_ERRORS -confirm-license";
    map { $args .= " -no-sql-".basename($_) if ( basename($_) ne "tmp" && -d $_ ); } glob("$qt_depot_path/src/plugins/sqldrivers/*");
    $args .= " -qt-sql-sqlite";
    if ( !$isWindows ) {
        $args .= " -fast";
    }
    if ( opt("release") ) {
        $args .= " -release";
    } else {
        $args .= " -debug";
    }
    if ( opt("gif") ) {
        $args .= " -qt-gif";
    }
    if ( $isWindows ) {
        $args .= " -no-dsp -no-vcproj";
        $args .= " -make ".fixpath("$QPEDIR/bin/winmake.exe");
    } elsif ( $isMac ) {
        $args .= " -no-framework";
    }
    if ( opt("verbose") ) {
        $args .= " -verbose";
    }
    if ( opt("gcc4", "host") && opt("reduce_exports") ne "auto" ) {
        $args .= " --reduce-exports=".opt("reduce_exports");
    }
    if ( opt("silent") ) {
        $args .= " -silent";
    }
    if ( !$isWindows ) {
        $args .= " -no-qdbus";
        if ( !opt("separate_debug_info") ) {
            $args .= " -no-separate-debug-info";
        }
    }
    my $listref = opt("extra_dqt_config");
    if ( @$listref ) {
        $args .= " ".join(" ", @$listref);
    }
    opt("dqt_config") = $args;
}
if ( !opt("skip_dqt") ) {
    configure_qt($DQTDIR, "Qt (host)", "dqt_config");
    if ( -d "$qt_depot_path/util/qdoc3" ) {
        # for some reason Qt 4.2 no longer does the qdoc3 directory
        mkpath("$DQTDIR/util/qdoc3");
        chdir("$DQTDIR/util/qdoc3");
        system("$DQTDIR/bin/qmake", "-o", "$DQTDIR/util/qdoc3/Makefile", "$qt_depot_path/util/qdoc3/qdoc3.pro");
    }
}

#####
Qtopia::Opt::write_config_cache();
system("$QPEDIR/bin/write_config_pri", "tests");

# Different qmake versions have different behaviors. Detect them here so the build system can work around them.
{
    print "Testing for qmake behaviors: ";
    print "\n" if ( opt("verbose") );
    my $out;
    configtest("qmake_behaviors", "outvar", $out, "platform", "qmake_only");
    my @behaviors;
    my @lines = grep /QMAKE_BEHAVIORS:/, split(/\n/, $out);
    my $line = pop(@lines);
    if ( $line ) {
        @behaviors = split(/\s+/, ($line =~ /QMAKE_BEHAVIORS: (.*)/)[0]);
    }
    if ( @behaviors ) {
        opt("qmake", "behaviors") = lc(join(" ", @behaviors));
        $out = uc(join(", ", @behaviors))
    } else {
        $out = "NONE";
    }
    print "$out\n";
    my %test;
    map { $test{$_}++ } @behaviors;
    if ( $test{func_out_join} ) {
        die "ERROR: Qtopia cannot work around the FUNC_OUT_JOIN behavior in qmake.\n".
            "       Please use a newer version of Qt.\n";
    }
    if ( $test{var_parse} ) {
        die "ERROR: Qtopia cannot work around the VAR_PARSE behavior in qmake.\n".
            "       Please use a newer version of Qt.\n";
    }
    if ( exists($test{keep_quotes}) ) {
        die "ERROR: Qtopia cannot work around the KEEP_QUOTES behavior in qmake.\n".
            "       Please use a newer version of Qt.\n";
    }
}

# Check that helix will work
if ( opt("edition") && opt("helix") ) {
    HELIX: while ( 1 ) {
        # setup the helixbuild directory so we can do tests based on it's contents
        print "Setting up the helix sources...\n";
        Qtopia::Opt::write_config_cache();
        filter_system("$QPEDIR/bin/write_config_pri");
        my $MAKE = opt("make");
        my $hide_debug = "exec >/dev/null 2>&1";
        if ( opt("verbose") ) {
            $hide_debug = "set -x";
        }
        system <<END;
$hide_debug
cd $helix_depot_path
cd ..
depot=\$(/bin/pwd)
mkdir -p $helix_build_path
cd $helix_build_path
cd ..
build=\$(/bin/pwd)
$QPEDIR/bin/qtopiamake -projectroots \$build
perl -i -pe '\$build="'\$build'"; \$depot="'\$depot'"; s/\\Q\$build\\E/\Q$QPEDIR/src\E/; s/\\Q\$depot\\E/\Q$depotpath/src\E/;' .qmake.cache
if [ ! -e $QTEDIR/.qmake.cache ]; then
    :>$QTEDIR/.qmake.cache
fi
$MAKE regenerate
END

        # Pick a default helix_system_id if we've detected the xplatform (ie. standard x86 build)
        if ( !opt("helix_system_id") && opt("xplatform", "auto") ) {
            opt("helix_system_id", "auto") = 1;
            # GCC 4 requires a different helix_system_id to avoid the annoying "-mcpu is deprecated" messages
            if ( opt("gcc4", "target") ) {
                opt("helix_system_id") = "linux-2.2-libc6-gcc32-i586-gcc4";
            } else {
                opt("helix_system_id") = "linux-2.2-libc6-gcc32-i586";
            }
        }

        if ( opt("helix_system_id") &&
             ! -e "$helix_build_path/build/umakecf/".opt("helix_system_id").".cf" ) {
            warn "Helix SYSTEM_ID ".opt("helix_system_id")." is not valid.\n";
            opt("helix_system_id") = undef;
        }

        if ( !opt("helix_system_id") ) {
            warn "WARNING: You must supply a SYSTEM_ID (via -helix-system-id) to build Helix.\n";
            opt("helix", "auto") = 1;
            opt("helix") = 0;
            last;
        }

        print "Testing for python: ";
        print "\n" if ( opt("verbose") );
        my $python = configtest("python");
        if ( $python ) {
            print "OK\n";
        } else {
            print "FAIL\n";
            print "Helix is disabled.\n";
            opt("helix", "auto") = 1;
            opt("helix") = 0;
            last;
        }

        if ( opt("helix") &&
             $licenseInfo{Product} !~ /Free/ && $licenseInfo{LicenseFile} ne "LICENSE.TROLL" ) {
            while ( 1 ) {
                my $acceptance = "no";
                if ( opt("confirm_license") ) {
                    print "Skipping confirmation of the Helix license agreement.\n";
                    $acceptance = "yes";
                } else {
                    print <<END;

Type 'yes' if you have a Helix license agreement that is signed by you and RealNetworks.
Type 'no' if you do NOT have a Helix license agreement that is signed by you and RealNetworks.

END
                    print "Do you have a signed license agreement? ";
                    $acceptance = <STDIN>;
                    chomp $acceptance;
                }
                print "\n";
                if ( $acceptance eq "yes" ) {
                    last;
                } elsif ( $acceptance eq "no" ) {
                    print <<END;
You are not licensed to use this software.
Please visit http://helixcommunity.org/ to arrange a license.

END
                    opt("helix", "auto") = 1;
                    opt("helix") = 0;
                    opt("helix_system_id") = undef;
                    opt("helix_system_id", "default") = undef;
                    last HELIX;
                }
            }
        }

        # this needs to be last
        last;
    }
}

if ( opt("edition") && opt("sound_system") eq "alsa" ) {
    print "Testing for ALSA: ";
    print "\n" if ( opt("verbose") );
    my $alsa = configtest("alsa");
    if ( $alsa ) {
        print "OK\n";
    } else {
        print "FAIL\n";
        opt("sound_system") = "oss";
        opt("sound_system", "auto") = 1;
        print "Using OSS as the sound system.\n";
    }
    # let helix know which sound system we're using
    opt("helix", "alsa") = $alsa?"alsa":"";
}

if ( opt("edition") && opt("helix") ) {
    # Steal some flags from the chosen SYSTEM_ID to help atomic stuff work
    my @flags;
    my @defines;
    my $outdir;
    get_system_id_flags(opt("helix_system_id").".cf", \@flags, \@defines, \$outdir);
    open OUT, ">>$QPEDIR/src/config.pri" or die "Can not open $QPEDIR/src/config.pri\n";
    my $cfgref = opt("config");
    for my $flag ( @flags ) {
        for my $cc ( qw(C CXX) ) {
            my $line = "!contains(QMAKE_${cc}FLAGS,$flag):QMAKE_${cc}FLAGS+=$flag";
            push(@$cfgref, $line);
            print OUT $line."\n";
        }
    }
    for my $define ( @defines ) {
        print OUT "DEFINES+=$define\n";
    }
    if ( $outdir ) {
        push(@$cfgref, "HELIX_OUT_DIR=$outdir");
    } else {
        die "ERROR: Can not locate the Helix output dir.\n".
            "       Please ensure your SYSTEM_ID sets project.output_dir = '[prefix-]<rel|dbg>'.\n";
    }
    close OUT;

    print "Testing for atomic operations in helix: ";
    print "\n" if ( opt("verbose") );
    my $atomic = configtest("helix_atomic");
    if ( $atomic ) {
        print "OK\n";
    } else {
        print "FAIL\n";
        print <<END;

WARNING: Your xplatform qmake.conf does not seem to allow building Helix with
         atomic operations. Helix requires the use of atomic operations in order
         to be thread-safe. Please inspect the SYSTEM_ID you are using to see
         if you need to add compiler switches or defines to qmake.conf.

         For more information on atomic operations please see:
         $helix_depot_path/common/include/atomicbase.h

END
    }
    opt("helix", "atomic") = $atomic?"atomic":"";
}

# Configure Qtopia Core
if ( opt("edition") && !opt("qte_config") ) {
    my $qconfig;
    if ( opt("device") && -e opt("device", "config_path")."/qconfig.h" ) {
        $qconfig = opt("device");
    } else {
        $qconfig = "qpe";
    }
    my $args = "-embedded ".opt("arch")." -platform $qt_platform -xplatform $qt_xplatform ".
               "-depths 16,32 -DQT_KEYPAD_NAVIGATION ".
               "-prefix ".fixpath(opt("sdkroot")."/qtopiacore/target")." ".
               "-no-stl -no-exceptions -no-qt3support -make src -make tools ".
               "-qconfig $qconfig -fast -no-glib -no-cups -no-qdbus ".
               "-DQT_NO_PLUGIN_CHECK -DQT_EXTERNAL_SOUND_SERVER -DQT_QWS_KEYEVENT_SINGLECLIENT ".
               "-confirm-license";
    if ( opt("perftest") ) {
        $args .= " -DQTOPIA_PERFTEST";
    }
    map { $args .= " -no-sql-".basename($_) if ( basename($_) ne "tmp" && -d $_ ); } glob("$qt_depot_path/src/plugins/sqldrivers/*");
    $args .= " -qt-sql-sqlite";
    if ( opt("release") ) {
        $args .= " -release";
    } else {
        $args .= " -debug";
    }
    if ( opt("profile") ) {
        $args .= " -profile";
    }
    if ( opt("qvfb") ) {
        $args .= " -qt-gfx-qvfb -qt-mouse-qvfb -qt-kbd-qvfb";
    } else {
        $args .= " -no-gfx-qvfb -no-mouse-qvfb -no-kbd-qvfb";
    }
    if ( ( index(opt("displayrot"), "90") != -1 ) ||
         ( index(opt("displayrot"), "180") != -1 ) ||
         ( index(opt("displayrot"), "270") != -1 ) ) {
        $args .= " -qt-gfx-transformed";
    }
    if ( opt("gif") ) {
        $args .= " -qt-gif";
    }
    if ( opt("verbose") ) {
        $args .= " -verbose";
    }
    if ( opt("singleexec") ) {
        $args .= " -static";
    }
    if ( opt("sxe") ) {
        $args .= " -sxe";
        if ( opt("sxe_discovery") ) {
            # SXE_DISCOVERY is only for use during development of a Qtopia system, and
            # not be defined for a production system build.  When this macro is defined
            # code is compiled to read the environment variable SXE_DISCOVERY_MODE and
            # to TURN OFF the SXE system if that environment variable is defined.  Shipping
            # a system compiled with this macro defined is a security breach.
            $args .= " -DSXE_DISCOVERY";
        }
    }
    if ( opt("helix") ) {
        $args .= " -DMEDIA_SERVER";
    }
    if ( opt("gcc4", "target") && opt("reduce_exports") ne "auto" ) {
        $args .= " --reduce-exports=".opt("reduce_exports");
    }
    if ( opt("silent") ) {
        $args .= " -silent";
    }
    if ( !opt("rpath") ) {
        $args .= " -no-rpath";
    }
    if ( !opt("separate_debug_info") ) {
        $args .= " -no-separate-debug-info";
    }
    my $listref = opt("extra_qte_config");
    if ( @$listref ) {
        $args .= " ".join(" ", @$listref);
    }
    opt("qte_config") = $args;
}
if ( opt("edition") && !opt("skip_qte") ) {
    # Make sure qconfig-qpe.h is there
    symlink_file("$depotpath/qtopiacore/qconfig-qpe.h", "$qt_depot_path/src/corelib/global/qconfig-qpe.h");
    if ( opt("device") && -e opt("device", "config_path")."/qconfig.h" ) {
        # Make sure qconfig-[device].h is there
        symlink_file(opt("device", "config_path")."/qconfig.h", "$qt_depot_path/src/corelib/global/qconfig-".opt("device").".h");
    }
    configure_qt($QTEDIR, "Qtopia Core (target)", "qte_config");
}

# Remove these headers so that people don't get into bad habits.
if ( configopt("depot") ) {
    for my $QTDIR ( $qt_depot_path, $DQTDIR, $QTEDIR ) {
        rmrf("$QTDIR/include/Qt");
    }
}

# Some Qtopia-specific file copying
if ( opt("edition") ) {
    mkpath($QPEDIR."/src/libraries/qtopia");
    my $custom;
    if ( opt("device") && -e opt("device", "config_path")."/custom.h" ) {
        $custom = opt("device", "config_path")."/custom";
    } else {
        $custom = "$depotpath/src/libraries/qtopiabase/custom-".opt("xplatform");
    }
    if ( ! -e "$custom.h" || ! -e "$custom.cpp" ) {
        my $err =   "ERROR: You must provide custom files in the following locations:\n";
        if ( opt("device") ) {
            $err .= "       ".opt("device", "config_path")."/custom.h\n".
                    "       ".opt("device", "config_path")."/custom.cpp\n".
                    "       or\n";
        }
        $err .=     "       $depotpath/src/libraries/qtopiabase/custom-".opt("xplatform").".h\n".
                    "       $depotpath/src/libraries/qtopiabase/custom-".opt("xplatform").".cpp\n";
        die $err;
    }
    symlink_file("$custom.h",   $QPEDIR."/src/libraries/qtopiabase/custom-qtopia.h");
    symlink_file("$custom.cpp", $QPEDIR."/src/libraries/qtopiabase/custom-qtopia.cpp");
    symlink_file(opt("defaultbuttons"), $QPEDIR."/etc/defaultbuttons.conf");
}

#
# config tests go here
#

Qtopia::Opt::write_config_cache();
system("$QPEDIR/bin/write_config_pri", "tests");

# Check that drmagent is present
if ( opt("edition") && opt("drm") ) {
    print "Testing for Beep Science DRM Agent: ";
    print "\n" if ( opt("verbose") );
    my $out;
    my $ok = configtest("locate_drmagent", "outvar", $out);
    if ( $ok ) {
        $ok = 0;
        my @search_paths;
        for my $ref ( opt("extraLibPaths"), opt("extraRPaths") ) {
            push(@search_paths, @$ref);
        }
        my @lines = split(/\n/, $out);
        @lines = grep(/^libraries:/, @lines);
        if ( @lines ) {
            my $compiler_paths = $lines[0];
            $compiler_paths =~ s/^libraries: =//;
            push(@search_paths, split(/:/, $compiler_paths));
        }
        for my $dir ( @search_paths ) {
            debugMsg("searching $dir\n");
            if ( -f "$dir/libdrmagent.so" ) {
                debugMsg("testing $dir/libdrmagent.so\n");
                open OUT, ">$QPEDIR/config.tests/locate_drmagent.pri" or die "Can not write to $QPEDIR/config.tests/locate_drmagent.pri\n";
                print OUT "DRMAGENT=$dir/libdrmagent.so\n";
                close OUT;
                $ok = configtest("test_drmagent", "outvar", $out);
                my @drmout = split(/\n/, $out);
                for ( @drmout ) {
                    if ( /warning.*libstdc\+\+.*conflict/ ) {
                        # If libstdc++ conflicts, don't use drmagent!
                        $ok = 0;
                        last;
                    }
                }
                last if ( $ok );
            }
        }
    } 
    if ( $ok ) {
        print "OK\n";
    } else {
        print "FAIL\n";
        print "DRM is disabled.\n";
        opt("drm", "auto") = 1;
        opt("drm") = 0;
    }
}

if ( opt("error") ) {
    print "Testing for -Werror: ";
    print "\n" if ( opt("verbose") );
    my $err_fail = configtest("error", "env", "XPLATFORM_ABSOLUTE=".opt("xplatform", "absolute")." PLATFORM_ABSOLUTE=".opt("platform", "absolute")." MAKECMD=".opt("make")." QPEDIR=$QPEDIR");
    if ( $err_fail == 0 ) {
        print "OK\n";
    } elsif ( $err_fail == 1 ) {
        print "FAIL\n";
    } else {
        print "BUG\n";
    }

    if ( $err_fail ) {
        print "Use of -Werror is disabled.\n";
        opt("error", "auto") = 1;
        opt("error") = 0;
    }
}

if ( opt("edition") ) {
    print "Checking for PAGE_SIZE and PAGE_MASK: ";
    print "\n" if ( opt("verbose") );
    my $out;
    my $ret = configtest("page_size", "outvar", $out, "env", "XPLATFORM_ABSOLUTE=".opt("xplatform", "absolute")." PLATFORM_ABSOLUTE=".opt("platform", "absolute")." MAKECMD=".opt("make")." QPEDIR=$QPEDIR QTOPIA_DEPOT_PATH=$depotpath DQTDIR=$DQTDIR VERBOSE=".opt("verbose"));
    if ( $ret ) {
        for ( split(/\n/, $out) ) {
            if ( /page_size=(.*)$/ ) {
                opt("page_size", "page_size") = $1;
            }
            if ( /page_mask=(.*)$/ ) {
                opt("page_size", "page_mask") = $1;
            }
            if ( /kernel=(.*)$/ ) {
                opt("page_size", "kernel") = 1;
            }
        }
    }
    if ( opt("page_size", "page_size") && opt("page_size", "page_mask") ) {
        print "PRESENT";
        if ( opt("page_size", "kernel") ) {
            print " (KERNEL)";
        }
        print "\n";
    } else {
        print "MISSING\n";
        print "QSharedMemoryCache will not throw away unused pages\n";
        my $dref = opt("extraDefines");
        push(@$dref, "QTOPIA_NO_PAGE_SIZE_MASK");
    }
}

if ( opt("readline") ) {
    print "Testing for GNU readline: ";
    print "\n" if ( opt("verbose") );
    my $ret = configtest("readline");
    if ( $ret ) {
        print "OK\n";
    } else {
        print "FAIL\n";
        opt("readline", "auto") = 1;
        opt("readline") = 0;
    }
}

if ( opt("phonelibs") ) {
    print "Checking for binary-only Qtopia phone libraries: ";
    print "\n" if ( opt("verbose") );
    my $ok = 1;
    # Expand the include directories. This is needed because there's actually 3 locations we might
    # need to search for Qtopia phone headers in (and it's tedious to require the user to specify
    # all 3).
    my %search_paths;
    tie %search_paths, 'Hash::Ordered';
    my $ref = opt("extraIncPaths");
    map { $search_paths{$_} = 1; } @$ref;
    for my $dir ( keys %search_paths ) {
        for my $qtopiaphone ( qw(qtopiaphone qtopiaphonemodem) ) {
            if ( -f "$dir/$qtopiaphone" && !$search_paths{dirname($dir)} ) {
                opt("extraIncPaths", "auto") = 1;
                $search_paths{dirname($dir)} = 1;
            }
            if ( -f "$dir/$qtopiaphone/$qtopiaphone" && !$search_paths{"$dir/$qtopiaphone"} ) {
                opt("extraIncPaths", "auto") = 1;
                $search_paths{"$dir/$qtopiaphone"} = 1;
            }
        }
    }
    @$ref = keys %search_paths;
    my %headers;
    for my $dir ( keys %search_paths ) {
        for my $qtopiaphone ( qw(qtopiaphone qtopiaphonemodem) ) {
            if ( -f "$dir/$qtopiaphone" ) {
                $headers{$qtopiaphone} = 1;
            }
        }
    }
    for my $qtopiaphone ( qw(qtopiaphone qtopiaphonemodem) ) {
        if ( !$headers{$qtopiaphone} ) {
            $ok = 0;
        }
    }
    if ( $ok ) {
        # locate libqtopiaphone.so and libqtopiaphonemodem.so using the (badly named) locate_drmagent test
        my $out;
        $ok = configtest("locate_drmagent", "outvar", $out);
        if ( $ok ) {
            $ok = 0;
            my @search_paths;
            for my $ref ( opt("extraLibPaths"), opt("extraRPaths") ) {
                push(@search_paths, @$ref);
            }
            my @lines = split(/\n/, $out);
            @lines = grep(/^libraries:/, @lines);
            if ( @lines ) {
                my $compiler_paths = $lines[0];
                $compiler_paths =~ s/^libraries: =//;
                push(@search_paths, split(/:/, $compiler_paths));
            }
            for my $dir ( @search_paths ) {
                debugMsg("searching $dir\n");
                if ( -e "$dir/libqtopiaphone.so" && -e "$dir/libqtopiaphonemodem.so" ) {
                    opt("libqtopiaphone") = "$dir/libqtopiaphone.so";
                    $_ = readlink "$dir/libqtopiaphone.so";
                    my ( $maj, $min, $rev ) = ( /(\d+)\.(\d+)\.(\d+)$/ );
                    opt("libqtopiaphone", "version") = "$maj.$min.$rev";
                    opt("libqtopiaphone", "major_version") = "$maj";
                    opt("libqtopiaphone", "minor_version") = "$min";

                    opt("libqtopiaphonemodem") = "$dir/libqtopiaphonemodem.so";
                    $_ = readlink "$dir/libqtopiaphonemodem.so";
                    ( $maj, $min, $rev ) = ( /(\d+)\.(\d+)\.(\d+)$/ );
                    opt("libqtopiaphonemodem", "version") = "$maj.$min.$rev";
                    opt("libqtopiaphonemodem", "major_version") = "$maj";
                    opt("libqtopiaphonemodem", "minor_version") = "$min";

                    $ok = 1;
                }
            }
        }
    }
    if ( $ok ) {
        print "PRESENT\n";
    } else {
        print "MISSING\n";
        die "ERROR: Please use the -I and -L configure flags to locate the Qtopia phone libraries.\n";
    }
}

if ( opt("dbus") ) {
    print "Testing for dbus: ";
    print "\n" if ( opt("verbose") );
    my $dbustest = configtest("dbus", "env", "DBUS_PREFIX=".opt("dbuspath"));
    if ( $dbustest ) {
        print "OK\n";
    } else {
        print "FAIL\n";
        print "DBUS is disabled.\n";
        opt("dbus", "auto") = 1;
        opt("dbus") = 0;
    }
}

if ( opt("bluetooth") ) {
    print "Testing for bluetooth: ";
    print "\n" if ( opt("verbose") );
    my $test = configtest("bluetooth");
    if ( $test ) {
        print "OK\n";
    } else {
        print "FAIL\n";
        print "Bluetooth is disabled.\n";
        opt("bluetooth", "auto") = 1;
        opt("bluetooth") = 0;
    }
}

if ( opt("bluetooth") ) {
    if ( not opt("dbus") ) {
        print "Bluetooth support requires dbus.\n";
        opt("bluetooth", "auto") = 1;
        opt("bluetooth") = 0;
    }
}

#if ( opt("dbusipc") ) {
#    if ( not opt("dbus") ) {
#        print "QCop over DBUS IPC support requires dbus.\n";
#        opt("dbusipc", "auto") = 1;
#        opt("dbusipc") = 0;
#    }
#}   

if ( opt("vpn") ) {
    if ( !opt("ssl") ) {
        print "VPN requires SSL\n";
        opt("vpn", "auto") = 1;
        opt("vpn") = 0;
    }
}

if ( opt("overloaded_virtual") ) {
    print "Testing for -Woverloaded-virtual: ";
    print "\n" if ( opt("verbose") );
    my $ok = configtest("overloaded_virtual", "env", "XPLATFORM_ABSOLUTE=".opt("xplatform", "absolute")." PLATFORM_ABSOLUTE=".opt("platform", "absolute")." MAKECMD=".opt("make")." QPEDIR=$QPEDIR DQTDIR=$DQTDIR test=overloaded_virtual FLAG=-Woverloaded-virtual");
    if ( $ok ) {
        print "OK\n";
    } else {
        print "FAIL\n";
        print "Use of -Woverloaded-virtual is disabled.\n";
        opt("overloaded_virtual") = 0;
    }
}

print_configure_line("Qtopia Platform", "configure $command_line");

opt_print_autodetect();

#
# Handle project roots (src, src/qtopiadesktop and whatever was passed to -build)
#

my @projectRoots;
my $extraBuildPathsRef = opt("extraBuildPaths");
push(@projectRoots, fixpath("$QPEDIR"),
                    fixpath("$QPEDIR/src"),
                    fixpath("$QPEDIR/etc/themes"),
                    fixpath("$QPEDIR/src/qtopiadesktop"),
                    fixpath("$QPEDIR/tests"),
                    fixpath("$QPEDIR/src/plugins/designer"));
if ( opt("device") && -d opt("device", "config_path")."/src" ) {
    push(@$extraBuildPathsRef, opt("device", "config_path")."/src");
    # Make this a project root (can't rely on the rule below because it
    # rejects this path due to being inside QPEDIR)
    my $dir = fixpath(opt("device", "config_path")."/src");
    # Relocate it to the build tree
    $dir =~ s,\Q$depotpath\E,$QPEDIR,;
    push(@projectRoots, "$dir");
}
# Cleanup the locations passed as -build
for my $dir ( @$extraBuildPathsRef ) {
    chdir $cwd; # in case $dir is relative!
    chdir $dir or die "Can not enter $dir\n";
    $dir = fixpath(getcwd());
    # Relocate it to the build tree
    $dir =~ s,\Q$depotpath\E,$QPEDIR,;
    # Don't make dir a project root if it's inside the Qtopia tree (or you might cause problems)
    if ( $dir !~ /^\Q$QPEDIR\E/ ) {
        push(@projectRoots, $dir);
    }
}
opt("extraBuildPaths", "projectRoots") = \@projectRoots;

Qtopia::Opt::write_config_cache();
system("$QPEDIR/bin/write_config_pri");

system("$QPEDIR/bin/qtopiamake", "-projectroots", @projectRoots);

if ( -d "$QPEDIR/include" ) {
    rmrf("$QPEDIR/include");
}

if ( opt("qmake") ) {
    print "Running qmake...\n";
    my @dirs = ( $QPEDIR );
    for my $dir ( @dirs ) {
        chdir $dir or die "Can not enter ".fixpath($dir)."\n";
        filter_system(opt("make")." first_syncqtopia");
    }
}

my $make = opt("make");
my $prefix = opt("prefix");
my $image = opt("image");
my $config_status = fixpath("$QPEDIR/config.status");

if ( opt("edition") ) {
    print_wrapping_msg( "Qtopia has been configured. You can build Qtopia by running $make.",
                        "After building, you MUST run $make install, which will setup a runnable image in $image. You can override this by running $make install IMAGE=/other/location.",
                        "As configured, Qtopia MUST be run from $prefix. If this is not where you intend to run Qtopia from you should set the location by running configure -prefix /opt/Qtopia.");
    if ( opt("prefix", "auto") && !opt("xplatform", "auto") ) {
        print "WARNING: You have specified -xplatform but not -prefix.\n\n\n";
    }
}
exit 0;

###################################################################

# Helper functions

sub astIf
{
    return $_[0] ? "*" : " ";
}

sub write_config_status
{
    if ( $isWindows ) {
	my $reconf = $outpath."/config.status.bat";
	if ( -f $reconf ) {
	    unlink $reconf or die $!;
	}
	open RECONF, ">".$reconf or die $!;
	print RECONF "\@echo off\n";
	print RECONF "$configure $command_line -confirm-license -no-clean -no-save-options %1 %2 %3 %4 %5 %6 %7 %8 %9\n";
	close RECONF or die $!;
    } else {
	my $reconf = $outpath."/config.status";
	if ( -f $reconf ) {
	    unlink $reconf or die $!;
	}
	open RECONF, ">".$reconf or die "Cannot write to $reconf\n";
	print RECONF '#!/bin/sh'."\n";
        if ( $shadow && $outpath eq $depotpath ) {
            print RECONF 'if [ -z "$QPEDIR" ]; then'."\n".
                         '    echo "ERROR: You must set QPEDIR if you want to shadow build."'."\n".
                         '    echo "When this file was created, QPEDIR was set to:"'."\n".
                         '    echo "    '.$QPEDIR.'"'."\n".
                         '    exit 1'."\n".
                         'fi'."\n".
                         'if [ "`cd $QPEDIR; /bin/pwd | sed \'s/\/$//\'`" != "'.$depotpath.'" ]; then'."\n".
                         '    exec "$QPEDIR/config.status" "$@"'."\n".
                         'fi'."\n";
        } else {
            print RECONF 'if [ "$#" -gt 0 ]; then'."\n".
                         '    cd '.$QPEDIR.' && '.$configure.' '.$command_line.' -confirm-license -no-clean -no-save-options "$@"'."\n".
                         'else'."\n".
                         '    cd '.$QPEDIR.' && '.$configure.' '.$command_line." -confirm-license -no-clean\n".
                         'fi'."\n";
        }
	close RECONF or die $!;
	chmod 0755, $reconf;
    }
}

sub configure_qt
{
    my ( $QTDIR, $qt, $qt_config ) = @_;
    
    # configure sets the output directory to $PWD
    chdir($QTDIR) or die "Can not enter $QTDIR\n";

    if ( opt("skip_qt_configure") ) {
        return;
    } else {
        print_configure_line($qt, "configure ".opt($qt_config));
    }

    # Forcibly re-create the include directory. This solves some wierd compile
    # problems caused by the include directory being out of date.
    print "Setting up the include directory for $qt. Please wait...\n";
    rmrf("$QTDIR/include");
    my $qtdir_backup = $ENV{QTDIR} || "";
    $ENV{QTDIR} = $qt_depot_path;
    open IN, "$qt_depot_path/bin/syncqt" or
        open IN, "$qt_depot_path/bin/syncqt.disabled" or
            die "Can not read $qt_depot_path/bin/syncqt\n";
    my @data = <IN>;
    close IN;
    @data = grep { !/ActiveQt/ } @data;
    mkpath("$QPEDIR/bin");
    open OUT, ">$QPEDIR/bin/syncqt" or die "Can not write $QPEDIR/bin/syncqt\n";
    print OUT @data;
    close OUT;
    if ( $isWindows ) {
        # FIXME this code assumes that Qt is not built in a shadow
        system("perl -S ".fixpath("$QPEDIR/bin/syncqt")." >nul");
    } else {
        system("perl $QPEDIR/bin/syncqt -outdir $qt_depot_path >/dev/null 2>&1");
        system("perl $QPEDIR/bin/syncqt -outdir $QTDIR >/dev/null 2>&1");
    }
    fix_qt_headers($qt_depot_path);
    fix_qt_headers($QTDIR);
    $ENV{QTDIR} = $qtdir_backup;

    # Hide some files
    my @hidden_files = qw(projects.pro bin/syncqt);
    # The GPL package has trouble when both Qt and Qtopia Core sources are located in
    # the same directory. Hide this file from Qt so that it doesn't get confused.
    if ( configopt("free") && $QTDIR eq $DQTDIR ) {
        push(@hidden_files, "src/gui/kernel/qapplication_qws.cpp");
    }
    for ( @hidden_files ) {
        if ( -f "$qt_depot_path/$_" ) {
            move("$qt_depot_path/$_", "$qt_depot_path/$_.disabled");
        }
    }

    # Clean out any crap from the build tree.
    # This is especially important for 'Makefile' since Qt does not re-create
    # this file if it exists and it could have stale configuration info in it.
    if ( opt("clean") ) {
        print "Cleaning your $qt build tree. Please wait...\n";
        Qtopia::Opt::write_config_cache();
        system("$QPEDIR/bin/qtopiamake", "-clean", $QTDIR);
    }

    # Qt's config.tests accidentally cache their results. This can have dire consequences
    # if you've changed something about your toolchain or system libs.
    rmrf("$QTDIR/config.tests");

    if ( configopt("depot") && $QTDIR eq $DQTDIR ) {
        # qmake can't figure out it's own dependencies properly. This is a big problem when developing
        # against a changing Qt source tree. For now, just blow it away so we can be sure the binary
        # we build is correct.
        my $makefile = "Makefile";
        my $make = opt("make");
        if ( $isWindows ) {
            $makefile = "Makefile.win32";
            $make = fixpath("$QPEDIR/bin/winmake");
            Qtopia::Opt::write_config_cache();
        }
        eval {
            filter_system("$make -C ".fixpath("$QTDIR/qmake")." -f $makefile clean 2>&1");
        };
    }

    if ( !$isWindows && $QTDIR eq $QTEDIR ) {
        # qmake has already been built as part of the host build. Since it uses
        # the same code, we can save time by copying it's .o files in to the target
        # build tree.
        mkpath("$QTDIR/qmake");
        system("cp -f $DQTDIR/qmake/*.o $QTDIR/qmake");
        # The exception to the rule above is this file, which has hardcoded paths
        # specific to the version of Qt being built. Just remove the .o file and
        # let it get rebuilt.
        unlink("$QTDIR/qmake/qlibraryinfo.o");
    }

    # A bug in qmake means that Qtopia Core tests can't find the feature files
    # when we pass a value to -xplatform that isn't in the Qt source tree.
    # Work around it by forcing the correct location to be searched.
    $ENV{QMAKEPATH} = "$qt_depot_path";
    
    # Go ahead and configure
    filter_system(fixpath("$qt_depot_path/configure")." ".opt("$qt_config")." 2>&1", sub {
        return 0 if ( /Qt is now configured for building/ );
        return 0 if ( /Once everything is built, you must/ );
        return 0 if ( /Qt will be installed into/ );
        return 0 if ( /To reconfigure, run/ );
        return 0 if ( /^\s*[Ff]or .*\.pro/ );
        return 0 if ( /^Cannot find file: .*projects\.pro\.$/ );
        return 0 if ( /WARNING: Using static linking will disable the use of dynamically/ );
        return 0 if ( /loaded plugins. Make sure to import all needed static plugins,/ );
        return 0 if ( /or compile needed modules into the library./ );
        return 0 if ( /You have already accepted the terms of the/ );
        return 1;
    });

    # Restore the hidden files
    push(@hidden_files, "src/gui/kernel/qapplication_qws.cpp");
    for ( @hidden_files ) {
        if ( -f "$qt_depot_path/$_.disabled" ) {
            move("$qt_depot_path/$_.disabled", "$qt_depot_path/$_");
        }
    }

    # Print a banner
    print '*'x($cols-1)."\n".
          "$qt is configured\n".
          '*'x($cols-1)."\n\n";
}

sub fix_qt_headers
{
    my ( $QTDIR ) = @_;
    # This is as close to a "global" file as Qt gets (I think)
    my $reftime = "$qt_depot_path/src/corelib/global/qglobal.h";
    find( sub {
            my $file = fixpath($File::Find::name);
            if ( ! -f $file ) {
                return;
            }
            my $target = resolveHeader($file);
            if ( $target eq $file ) {
                # Not a "typical" header, just set the times to what $reftime has
                $target = $reftime;
            }
            my $s = stat($target);
            if ( $s ) {
                my $now = $s->mtime;
                utime $now, $now, $file;
            } else {
                die "$target does not exist!\n";
            }
        }, "$QTDIR/include" );
}

sub filter_system
{
    my ( $cmd, $subref ) = @_;

    my $prog = basename((split(/\s+/, $cmd))[0]);

    if ( opt("verbose") ) {
        print "filter_system $cmd\n";
        system($cmd);
    } else {
        my $pid = open IN, "$cmd |";
        if ( !defined($pid) ) {
            $? = -1;
        } else {
            my $dosub = ( ref($subref) eq "CODE" );
            if ( $dosub ) {
                while ( defined($_ = <IN>) ) {
                    &$subref() and print;
                }
            } else {
                # this is a quicker way to slurp it up (if we don't care about displaying it)
                my @foo = <IN>;
            }
            close IN;
        }
    }
    my $err = undef;
    if ( $? == -1 ) {
        $err = "Could not execute $prog: $!\n";
    } elsif ( $?&127 ) {
        $err = "$prog died with signal ".($?&127)."\n";
    } elsif ( ($?>>8) != 0 ) {
        $err = "$prog exited with value ".($?>>8)."\n";
    }
    if ( $err ) {
        die $err;
    }
}

sub configtest
{
    my $test = shift(@_);
    my $platform = "xplatform";
    my $captureoutput = 0;
    my $verbosebackup = opt("verbose");
    my $subref = 0;
    my $envstring = undef;
    my $qmake_only = 0;
    while ( scalar(@_) != 0 ) {
        if ( $_[0] eq "outvar" ) {
            shift(@_);
            $captureoutput = 1;
            opt("verbose") = 0;
            my $retref = \$_[0];
            $$retref = "";
            $subref = sub {
                $$retref .= $_;
                return $verbosebackup;
            };
            shift(@_);
        } elsif ( $_[0] eq "env" ) {
            shift(@_);
            $envstring = shift(@_);
        } elsif ( $_[0] eq "platform" ) {
            shift(@_);
            $platform = "platform";
        } elsif ( $_[0] eq "qmake_only" ) {
            shift(@_);
            $qmake_only = 1;
        }
    }
    my $source = ("$depotpath/config.tests/$test");
    debugMsg("Running config test $test");
    eval {
        my $command_header = "";
        if ( $envstring ) {
            $command_header .= fixpath("$QPEDIR/bin/runwithvars".($isWindows?"":".sh"))." $envstring ";
        }
        if ( -f "$source.test" ) {
            filter_system($command_header."$source.test", $subref);
        } elsif ( -d "$source" ) {
            my $dest = fixpath("$QPEDIR/config.tests/$test");
            mkpath($dest);
            chdir $dest or die "Can not enter $dest\n";
            open CACHE_FILE, ">$dest/.qmake.cache" or die "Can not open ".fixpath("$dest/.qmake.cache")."\n";
            print CACHE_FILE "include($QPEDIR/src/config.pri)\n";
            close CACHE_FILE;
            filter_system($command_header.fixpath("$DQTDIR/bin/qmake")." -spec ".fixpath(opt($platform, "absolute"))." -o ".fixpath("$dest/Makefile")." ".fixpath("$source/$test.pro")." 2>&1", $subref);
            if ( !$qmake_only ) {
                filter_system($command_header.opt("make")." clean >/dev/null 2>&1");
                filter_system($command_header.opt("make")." 2>&1", $subref);
            }
        } else {
            die "ERROR: Missing test $test\n";
        }
    };
    opt("verbose") = $verbosebackup;
    # This means that die was called from within the eval block above
    if ( $@ ) {
        debugMsg($@);
        return 0;
    }
    return 1;
}

sub get_system_id_flags
{
    my ( $config_file, $flags, $defines, $outdir ) = @_;

    open IN, "$helix_build_path/build/umakecf/$config_file" or die "Can not open $helix_build_path/build/umakecf/$config_file\n";
    my @data = <IN>;
    close IN;
    while ( @data ) {
        # collapse lines escaped with a \
        $_ = "";
        do {
            $_ .= shift(@data) or last;
        } while ( s/\\$// );

        # handle indirect includes
        if ( /^exec_config_file\('(.*)'\)/ ) {
            get_system_id_flags($1, $flags, $defines, $outdir);
        }

        # look for -march, -mcpu and -mtune (gcc 4) added to cxx.args
        if ( /^platform\.cxx\.args/ ) {
            if ( /(-march=[^\s"]+)/ ) {
                push(@$flags, $1);
                #print "$1\n";
            }
            if ( /(-mcpu=[^\s"]+)/ ) {
                push(@$flags, $1);
                #print "$1\n";
            }
            if ( opt("gcc4", "target") && /(-mtune=[^\s"]+)/ ) {
                push(@$flags, $1);
                #print "$1\n";
            }
        }

        # look for defines
        if ( /^project\.AddDefines\(.*,\s*["'](.*)["']\)/ ) {
            push(@$defines, "$1");
            #print "$1\n";
        }

        # look for the output dir
        if ( /project.output_dir.*["'](.*)["']/ ) {
            my $od = $1;
            if ( opt("release") && $od =~ /rel$/ ) {
                $$outdir = $od;
            } 
            if ( !opt("release") && $od =~ /dbg$/ ) {
                $$outdir = $od;
            } 
        }
    }
}

sub getVersions
{
    my ( $qtopiaMajorVersion, $qtopiaMinorVersion, $qtopiaRevVersion );
    my ( $qtMajorVersion, $qtMinorVersion, $qtRevVersion );
    my $verfile = "$depotpath/src/libraries/qtopia/version.h";
    $verfile = "$depotpath/src/libraries/qtopiabase/version.h" unless ( -f $verfile );
    if ( open(IN, "$verfile" ) ) {
        while ( defined($_ = <IN>) ) {
            if ( /QPE_VERSION\s+"(\d+\.\d+\.\d+)"/ ) {
                $qtopiaVersionStr = $1;
                ( $qtopiaMajorVersion, $qtopiaMinorVersion, $qtopiaRevVersion ) = ( $qtopiaVersionStr =~ /(\d+)\.(\d+)\.(\d+)/ );
                last;
            }
        }
        close IN;
    }
    if ( $qtopiaVersionStr eq "0.0.0" ) {
        die "ERROR: Could not read version from ".fixpath("$verfile")."\n";
    }

    if ( open(IN, "$qt_depot_path/src/corelib/global/qglobal.h" ) ) {
        while ( defined($_ = <IN>) ) {
            if ( /QT_VERSION_STR\s+"(\d+\.\d+\.\d+)"/ ) {
                $qtVersionStr = $1;
                ( $qtMajorVersion, $qtMinorVersion, $qtRevVersion ) = ( $qtVersionStr =~ /(\d+)\.(\d+)\.(\d+)/ );
                last;
            }
        }
        close IN;
    }
    if ( $qtVersionStr eq "0.0.0" ) {
        die "ERROR: Could not read version from ".fixpath("$qt_depot_path/src/corelib/global/qglobal.h")."\n";
    }

    if ( $qtopiaMajorVersion != $qtMajorVersion || $qtopiaMinorVersion > $qtMinorVersion ) {
        die <<END;
ERROR: Qtopia $qtopiaMajorVersion.$qtopiaMinorVersion is designed to work with Qt $qtopiaMajorVersion.$qtopiaMinorVersion.
       Found Qt $qtMajorVersion.$qtMinorVersion.$qtRevVersion.
END
    }
}

sub clean_qt_sources
{
    my $found = 0;
    for ( ".qmake.cache", "config.status",
          "src/corelib/global/qconfig.cpp",
          "src/corelib/global/qconfig.h",
          "src/corelib/global/qconfig.h.qmake",
          "mkspecs/qconfig.pri" ) {
        my $file = "$qt_depot_path/$_";
        if ( -d $file ) {
            rmrf($file);
            $found = 1;
        } elsif ( -f $file ) {
            unlink $file;
            $found = 1;
        }
    }
    if ( $found ) {
        print "Your Qt source tree has a build in it. This must be removed. Please wait...\n";
        Qtopia::Opt::write_config_cache();
        system("$QPEDIR/bin/qtopiamake", "-clean", $qt_depot_path);
    }
}

sub clean_qtopia_sources
{
    my $found = 0;
    for ( "config.cache",
          "src/3rdparty/tools/bluez/hcid/parser.c",
          "src/3rdparty/tools/bluez/hcid/parser.h",
          "src/3rdparty/tools/bluez/hcid/lexer.c",
          "src/config.pri",
          "src/libraries/qtopiabase/custom-qtopia.h" ) {
        my $file = "$depotpath/$_";
        if ( -d $file ) {
            rmrf($file);
            $found = 1;
        } elsif ( -f $file ) {
            unlink $file;
            $found = 1;
        }
    }
    if ( $found ) {
        print "Your Qtopia source tree has a build in it. This must be removed. Please wait...\n";
        Qtopia::Opt::write_config_cache();
        system("$QPEDIR/bin/qtopiamake", "-clean", $depotpath);
    }
}

sub debugMsg
{
    if ( opt("verbose") ) {
	print @_;
        my $test = $_[scalar(@_)-1];
        if ( chop $test ne "\n" ) {
            print "\n";
        }
    }
}

my $confline_what;
my $confline_msg;
sub print_configure_line
{
    ( $confline_what, $confline_msg ) = @_;
    format_name STDOUT "CONFLINE";
    write;
}

my $wrapmsg_msg;
sub print_wrapping_msg
{
    print "\n\n";
    format_name STDOUT "WRAPMSG";
    for ( @_ ) {
        $wrapmsg_msg = $_;
        write;
        print "\n";
    }
    print "\n";
}

sub init_formats
{
    my $fmt = "format CONFLINE =\n\n".
              '*'x($cols-1)."\n".
              "Configuring @".'<'x($cols-14)."\n\$confline_what\n".
              "^".'<'x($cols-2)."~~\n\$confline_msg\n".
              '*'x($cols-1)."\n\n.";
    eval $fmt;
    die $@ if ( $@ );

    $fmt = "format WRAPMSG =\n".
              "^".'<'x($cols-2)."~~\n\$wrapmsg_msg\n.";
    eval $fmt;
    die $@ if ( $@ );

    # Only split on spaces, not the - character
    $: = " ";
}

sub symlink_all_files
{
    my ( $dir ) = @_;

    if ( -l "$QPEDIR/$dir" ) {
        unlink "$QPEDIR/$dir";
    }
    mkpath("$QPEDIR/$dir");
    for ( glob("$depotpath/$dir/*") ) {
	my $filename = basename($_, "");
	symlink_file($_, "$QPEDIR/$dir/$filename");
    }
}

